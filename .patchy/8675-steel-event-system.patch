From 7f5face9a9e369eafbfcc14d3fed997f7953b2a6 Mon Sep 17 00:00:00 2001
From: NSPC911 <87571998+NSPC911@users.noreply.github.com>
Date: Sun, 29 Jun 2025 00:48:41 +0800
Subject: [PATCH] patchy: Merge 8675/steel-event-system

---
 Cargo.lock                                   | 1457 ++++-
 Cargo.toml                                   |    3 +
 STEEL.md                                     |  256 +
 helix-core/Cargo.toml                        |    2 +
 helix-core/src/command_line.rs               |    9 +-
 helix-core/src/extensions.rs                 |  490 ++
 helix-core/src/lib.rs                        |    2 +
 helix-core/src/selection.rs                  |    3 +
 helix-core/src/syntax.rs                     |   35 +-
 helix-core/src/syntax/config.rs              |   41 +-
 helix-event/Cargo.toml                       |    6 +-
 helix-lsp/src/client.rs                      |   59 +
 helix-lsp/src/lib.rs                         |    6 +-
 helix-term/Cargo.toml                        |   10 +-
 helix-term/src/application.rs                |   41 +-
 helix-term/src/commands.rs                   |   62 +-
 helix-term/src/commands/engine.rs            |  255 +
 helix-term/src/commands/engine/components.rs | 2067 +++++++
 helix-term/src/commands/engine/steel.rs      | 5264 ++++++++++++++++++
 helix-term/src/commands/engine/themes.scm    |  382 ++
 helix-term/src/commands/typed.rs             |  130 +-
 helix-term/src/compositor.rs                 |   21 +-
 helix-term/src/events.rs                     |    5 +-
 helix-term/src/job.rs                        |   49 +-
 helix-term/src/keymap.rs                     |   36 +-
 helix-term/src/main.rs                       |   11 +-
 helix-term/src/ui/document.rs                |    1 +
 helix-term/src/ui/editor.rs                  |   24 +-
 helix-term/src/ui/extension.rs               |   11 +
 helix-term/src/ui/mod.rs                     |    8 +-
 helix-term/src/ui/overlay.rs                 |    6 +
 helix-term/src/ui/prompt.rs                  |    6 +
 helix-term/src/ui/statusline.rs              |    2 +
 helix-tui/Cargo.toml                         |    3 +
 helix-tui/src/extension.rs                   |   20 +
 helix-tui/src/lib.rs                         |    1 +
 helix-tui/src/widgets/list.rs                |   16 +-
 helix-tui/src/widgets/mod.rs                 |    4 +-
 helix-view/Cargo.toml                        |    5 +-
 helix-view/src/document.rs                   |   18 +-
 helix-view/src/editor.rs                     |   29 +-
 helix-view/src/events.rs                     |    1 +
 helix-view/src/extension.rs                  |  107 +
 helix-view/src/graphics.rs                   |   26 +
 helix-view/src/info.rs                       |   24 +-
 helix-view/src/lib.rs                        |    2 +
 helix-view/src/theme.rs                      |   21 +-
 helix-view/src/tree.rs                       |    7 +
 rust-toolchain.toml                          |    2 +-
 steel-docs.md                                | 2841 ++++++++++
 xtask/src/codegen.rs                         |    5 +
 xtask/src/main.rs                            |   61 +
 52 files changed, 13582 insertions(+), 371 deletions(-)
 create mode 100644 STEEL.md
 create mode 100644 helix-core/src/extensions.rs
 create mode 100644 helix-term/src/commands/engine.rs
 create mode 100644 helix-term/src/commands/engine/components.rs
 create mode 100644 helix-term/src/commands/engine/steel.rs
 create mode 100644 helix-term/src/commands/engine/themes.scm
 create mode 100644 helix-term/src/ui/extension.rs
 create mode 100644 helix-tui/src/extension.rs
 create mode 100644 helix-view/src/extension.rs
 create mode 100644 steel-docs.md
 create mode 100644 xtask/src/codegen.rs

diff --git a/Cargo.lock b/Cargo.lock
index b608e17c1..c6ea65eab 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -3,25 +3,67 @@
 version = 3
 
 [[package]]
-name = "addr2line"
-version = "0.22.0"
+name = "abi_stable"
+version = "0.11.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "69d6512d3eb05ffe5004c59c206de7f99c34951504056ce23fc953842f12c445"
+dependencies = [
+ "abi_stable_derive",
+ "abi_stable_shared",
+ "const_panic",
+ "core_extensions",
+ "crossbeam-channel",
+ "generational-arena",
+ "libloading 0.7.4",
+ "lock_api",
+ "parking_lot",
+ "paste",
+ "repr_offset",
+ "rustc_version",
+ "serde",
+ "serde_derive",
+ "serde_json",
+]
+
+[[package]]
+name = "abi_stable_derive"
+version = "0.11.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6e4503c46a5c0c7844e948c9a4d6acd9f50cccb4de1c48eb9e291ea17470c678"
+checksum = "d7178468b407a4ee10e881bc7a328a65e739f0863615cca4429d43916b05e898"
 dependencies = [
- "gimli",
+ "abi_stable_shared",
+ "as_derive_utils",
+ "core_extensions",
+ "proc-macro2",
+ "quote",
+ "rustc_version",
+ "syn 1.0.109",
+ "typed-arena",
 ]
 
 [[package]]
-name = "adler"
-version = "1.0.2"
+name = "abi_stable_shared"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b2b5df7688c123e63f4d4d649cba63f2967ba7f7861b1664fca3f77d3dad2b63"
+dependencies = [
+ "core_extensions",
+]
+
+[[package]]
+name = "addr2line"
+version = "0.24.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"
+checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
+dependencies = [
+ "gimli",
+]
 
 [[package]]
 name = "adler2"
-version = "2.0.0"
+version = "2.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627"
+checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"
 
 [[package]]
 name = "ahash"
@@ -46,9 +88,9 @@ dependencies = [
 
 [[package]]
 name = "allocator-api2"
-version = "0.2.18"
+version = "0.2.21"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5c6cb57a04249c6480766f7f7cef5467412af1490f8d1e243141daddada3264f"
+checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"
 
 [[package]]
 name = "android-tzdata"
@@ -77,25 +119,74 @@ version = "1.7.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "69f7f8c3906b62b754cd5326047894316021dcfe5a194c8ea52bdd94934a3457"
 
+[[package]]
+name = "arrayvec"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "23b62fc65de8e4e7f52534fb52b0f3ed04746ae267519eef2a83941e8085068b"
+
+[[package]]
+name = "as_derive_utils"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ff3c96645900a44cf11941c111bd08a6573b0e2f9f69bc9264b179d8fae753c4"
+dependencies = [
+ "core_extensions",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "async-ffi"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f4de21c0feef7e5a556e51af767c953f0501f7f300ba785cc99c47bdc8081a50"
+dependencies = [
+ "abi_stable",
+]
+
 [[package]]
 name = "autocfg"
-version = "1.3.0"
+version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"
+checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"
 
 [[package]]
 name = "backtrace"
-version = "0.3.73"
+version = "0.3.75"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5cc23269a4f8976d0a4d2e7109211a419fe30e8d88d677cd60b6bc79c5732e0a"
+checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
 dependencies = [
  "addr2line",
- "cc",
  "cfg-if",
  "libc",
- "miniz_oxide 0.7.4",
+ "miniz_oxide",
  "object",
  "rustc-demangle",
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "bigdecimal"
+version = "0.4.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1a22f228ab7a1b23027ccc6c350b72868017af7ea8356fbdf19f8d991c690013"
+dependencies = [
+ "autocfg",
+ "libm",
+ "num-bigint",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "bincode"
+version = "1.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b1f45e9417d87227c7a56d22e471c6206462cba514c7590c09aff4cf6d1ddcad"
+dependencies = [
+ "serde",
 ]
 
 [[package]]
@@ -104,6 +195,15 @@ version = "2.9.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"
 
+[[package]]
+name = "bitmaps"
+version = "2.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "031043d04099746d8db04daf1fa424b2bc8bd69d92b25962dcde24da39ab64a2"
+dependencies = [
+ "typenum",
+]
+
 [[package]]
 name = "block-buffer"
 version = "0.10.4"
@@ -126,9 +226,9 @@ dependencies = [
 
 [[package]]
 name = "bumpalo"
-version = "3.16.0"
+version = "3.18.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"
+checksum = "793db76d6187cd04dff33004d8e6c9cc4e05cd330500379d2394209271b4aeee"
 
 [[package]]
 name = "byteorder"
@@ -138,9 +238,9 @@ checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"
 
 [[package]]
 name = "bytes"
-version = "1.7.1"
+version = "1.10.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8318a53db07bb3f8dca91a600466bdb3f2eaadeedfdbcf02e1accbad9271ba50"
+checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"
 
 [[package]]
 name = "cassowary"
@@ -148,6 +248,15 @@ version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "df8670b8c7b9dae1793364eafadf7239c40d669904660c5960d74cfd80b46a53"
 
+[[package]]
+name = "castaway"
+version = "0.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0abae9be0aaf9ea96a3b1b8b1b55c602ca751eba1b1500220cea4ecbafe7c0d5"
+dependencies = [
+ "rustversion",
+]
+
 [[package]]
 name = "cc"
 version = "1.2.27"
@@ -159,9 +268,9 @@ dependencies = [
 
 [[package]]
 name = "cfg-if"
-version = "1.0.0"
+version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
+checksum = "9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268"
 
 [[package]]
 name = "chardetng"
@@ -201,6 +310,55 @@ version = "0.6.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "cbd0f76e066e64fdc5631e3bb46381254deab9ef1158292f27c8c57e3bf3fe59"
 
+[[package]]
+name = "codegen"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ff61280aed771c3070e7dcc9e050c66f1eb1e3b96431ba66f9f74641d02fc41d"
+dependencies = [
+ "indexmap 1.9.3",
+]
+
+[[package]]
+name = "codespan-reporting"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3538270d33cc669650c4b093848450d380def10c331d38c768e34cac80576e6e"
+dependencies = [
+ "termcolor",
+ "unicode-width 0.1.12",
+]
+
+[[package]]
+name = "compact_str"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b79c4069c6cad78e2e0cdfcbd26275770669fb39fd308a752dc110e83b9af32"
+dependencies = [
+ "castaway",
+ "cfg-if",
+ "itoa",
+ "rustversion",
+ "ryu",
+ "serde",
+ "static_assertions",
+]
+
+[[package]]
+name = "concurrent-queue"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
+dependencies = [
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "const_panic"
+version = "0.2.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2459fc9262a1aa204eb4b5764ad4f189caec88aea9634389c0a25f8be7f6265e"
+
 [[package]]
 name = "content_inspector"
 version = "0.2.4"
@@ -210,12 +368,45 @@ dependencies = [
  "memchr",
 ]
 
+[[package]]
+name = "convert_case"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bb402b8d4c85569410425650ce3eddc7d698ed96d39a73f941b08fb63082f1e7"
+dependencies = [
+ "unicode-segmentation",
+]
+
+[[package]]
+name = "coolor"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "980c2afde4af43d6a05c5be738f9eae595cff86dce1f38f88b95058a98c027f3"
+dependencies = [
+ "crossterm 0.29.0",
+]
+
 [[package]]
 name = "core-foundation-sys"
 version = "0.8.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
 
+[[package]]
+name = "core_extensions"
+version = "1.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "92c71dc07c9721607e7a16108336048ee978c3a8b129294534272e8bac96c0ee"
+dependencies = [
+ "core_extensions_proc_macros",
+]
+
+[[package]]
+name = "core_extensions_proc_macros"
+version = "1.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "69f3b219d28b6e3b4ac87bc1fc522e0803ab22e055da177bff0068c4150c61a6"
+
 [[package]]
 name = "cpufeatures"
 version = "0.2.17"
@@ -234,11 +425,59 @@ dependencies = [
  "cfg-if",
 ]
 
+[[package]]
+name = "crokey"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5282b45c96c5978c8723ea83385cb9a488b64b7d175733f48d07bf9da514a863"
+dependencies = [
+ "crokey-proc_macros",
+ "crossterm 0.29.0",
+ "once_cell",
+ "serde",
+ "strict",
+]
+
+[[package]]
+name = "crokey-proc_macros"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2ea0218d3fedf0797fa55676f1964ef5d27103d41ed0281b4bbd2a6e6c3d8d28"
+dependencies = [
+ "crossterm 0.29.0",
+ "proc-macro2",
+ "quote",
+ "strict",
+ "syn 2.0.103",
+]
+
+[[package]]
+name = "crossbeam"
+version = "0.8.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1137cd7e7fc0fb5d3c5a8678be38ec56e819125d8d7907411fe24ccb943faca8"
+dependencies = [
+ "crossbeam-channel",
+ "crossbeam-deque",
+ "crossbeam-epoch",
+ "crossbeam-queue",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-channel"
+version = "0.5.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2"
+dependencies = [
+ "crossbeam-utils",
+]
+
 [[package]]
 name = "crossbeam-deque"
-version = "0.8.5"
+version = "0.8.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "613f8cc01fe9cf1a3eb3d7f488fd2fa8388403e97039e2f73692932e291a770d"
+checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
 dependencies = [
  "crossbeam-epoch",
  "crossbeam-utils",
@@ -253,11 +492,20 @@ dependencies = [
  "crossbeam-utils",
 ]
 
+[[package]]
+name = "crossbeam-queue"
+version = "0.3.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0f58bbc28f91df819d0aa2a2c00cd19754769c2fad90579b3592b1c9ba7a3115"
+dependencies = [
+ "crossbeam-utils",
+]
+
 [[package]]
 name = "crossbeam-utils"
-version = "0.8.20"
+version = "0.8.21"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80"
+checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"
 
 [[package]]
 name = "crossterm"
@@ -278,6 +526,24 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "crossterm"
+version = "0.29.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d8b9f2e4c67f833b660cdb0a3523065869fb35570177239812ed4c905aeff87b"
+dependencies = [
+ "bitflags",
+ "crossterm_winapi",
+ "derive_more",
+ "document-features",
+ "mio",
+ "parking_lot",
+ "rustix 1.0.7",
+ "signal-hook",
+ "signal-hook-mio",
+ "winapi",
+]
+
 [[package]]
 name = "crossterm_winapi"
 version = "0.9.1"
@@ -311,6 +577,27 @@ dependencies = [
  "parking_lot_core",
 ]
 
+[[package]]
+name = "derive_more"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "093242cf7570c207c83073cf82f79706fe7b8317e98620a47d5be7c3d8497678"
+dependencies = [
+ "derive_more-impl",
+]
+
+[[package]]
+name = "derive_more-impl"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bda628edc44c4bb645fbe0f758797143e4e07926f7ebf4e9bdfbd3d2ce621df3"
+dependencies = [
+ "convert_case",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.103",
+]
+
 [[package]]
 name = "digest"
 version = "0.10.7"
@@ -329,7 +616,16 @@ checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
+]
+
+[[package]]
+name = "document-features"
+version = "0.2.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "95249b50c6c185bee49034bcb378a49dc2b5dff0be90ff6616d31d64febab05d"
+dependencies = [
+ "litrs",
 ]
 
 [[package]]
@@ -340,9 +636,9 @@ checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"
 
 [[package]]
 name = "either"
-version = "1.13.0"
+version = "1.15.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"
+checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
 
 [[package]]
 name = "encoding_rs"
@@ -370,15 +666,15 @@ checksum = "c7f84e12ccf0a7ddc17a6c41c93326024c42920d7ee630d04950e6926645c0fe"
 
 [[package]]
 name = "equivalent"
-version = "1.0.1"
+version = "1.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"
+checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"
 
 [[package]]
 name = "errno"
-version = "0.3.10"
+version = "0.3.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "33d852cb9b869c2a9b3df2f71a3074817f01e1844f839a144f5fcef059a4eb5d"
+checksum = "cea14ef9355e3beab063703aa9dab15afd25f0667c341310c1e5274bb1d0da18"
 dependencies = [
  "libc",
  "windows-sys 0.59.0",
@@ -386,9 +682,9 @@ dependencies = [
 
 [[package]]
 name = "error-code"
-version = "3.2.0"
+version = "3.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a0474425d51df81997e2f90a21591180b38eccf27292d755f3e30750225c175b"
+checksum = "dea2df4cf52843e0452895c455a1a2cfbb842a1e7329671acf418fdc53ed4c59"
 
 [[package]]
 name = "etcetera"
@@ -413,9 +709,9 @@ dependencies = [
 
 [[package]]
 name = "fastrand"
-version = "2.1.1"
+version = "2.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e8c02a5121d4ea3eb16a80748c74f5549a5665e4c21333c6098f283870fbdea6"
+checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"
 
 [[package]]
 name = "fern"
@@ -428,9 +724,9 @@ dependencies = [
 
 [[package]]
 name = "filedescriptor"
-version = "0.8.2"
+version = "0.8.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7199d965852c3bac31f779ef99cbb4537f80e952e2d6aa0ffeb30cce00f4f46e"
+checksum = "e40758ed24c9b2eeb76c35fb0aebc66c626084edd827e07e1552279814c6682d"
 dependencies = [
  "libc",
  "thiserror 1.0.69",
@@ -451,13 +747,13 @@ dependencies = [
 
 [[package]]
 name = "flate2"
-version = "1.1.1"
+version = "1.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7ced92e76e966ca2fd84c8f7aa01a4aea65b0eb6648d72f7c8f3e2764a67fece"
+checksum = "4a3d7db9596fecd151c5f638c0ee5d5bd487b6e0ea232e5dc96d5250f6f94b1d"
 dependencies = [
  "crc32fast",
  "libz-rs-sys",
- "miniz_oxide 0.8.7",
+ "miniz_oxide",
 ]
 
 [[package]]
@@ -498,6 +794,17 @@ dependencies = [
  "futures-util",
 ]
 
+[[package]]
+name = "futures-macro"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.103",
+]
+
 [[package]]
 name = "futures-task"
 version = "0.3.31"
@@ -511,12 +818,31 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
 dependencies = [
  "futures-core",
+ "futures-macro",
  "futures-task",
  "pin-project-lite",
  "pin-utils",
  "slab",
 ]
 
+[[package]]
+name = "fxhash"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c"
+dependencies = [
+ "byteorder",
+]
+
+[[package]]
+name = "generational-arena"
+version = "0.2.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "877e94aff08e743b651baaea359664321055749b398adff8740a7399af7796e7"
+dependencies = [
+ "cfg-if",
+]
+
 [[package]]
 name = "generic-array"
 version = "0.14.7"
@@ -529,32 +855,35 @@ dependencies = [
 
 [[package]]
 name = "getrandom"
-version = "0.2.15"
+version = "0.2.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
+checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
 dependencies = [
  "cfg-if",
  "libc",
- "wasi 0.11.0+wasi-snapshot-preview1",
+ "wasi 0.11.1+wasi-snapshot-preview1",
 ]
 
 [[package]]
 name = "getrandom"
-version = "0.3.1"
+version = "0.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "43a49c392881ce6d5c3b8cb70f98717b7c07aabbdff06687b9030dbfbe2725f8"
+checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
 dependencies = [
  "cfg-if",
+ "js-sys",
  "libc",
- "wasi 0.13.3+wasi-0.2.2",
  "windows-targets 0.52.6",
+ "r-efi",
+ "wasi 0.14.2+wasi-0.2.4",
+ "wasm-bindgen",
 ]
 
 [[package]]
 name = "gimli"
-version = "0.29.0"
+version = "0.31.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "40ecd4077b5ae9fd2e9e169b102c6c330d0605168eb0e8bf79952b256dbefffd"
+checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"
 
 [[package]]
 name = "gix"
@@ -622,9 +951,9 @@ dependencies = [
 
 [[package]]
 name = "gix-attributes"
-version = "0.26.0"
+version = "0.26.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e7e26b3ac280ddb25bb6980d34f4a82ee326f78bf2c6d4ea45eef2d940048b8e"
+checksum = "6f50d813d5c2ce9463ba0c29eea90060df08e38ad8f34b8a192259f8bce5c078"
 dependencies = [
  "bstr",
  "gix-glob",
@@ -657,9 +986,9 @@ dependencies = [
 
 [[package]]
 name = "gix-command"
-version = "0.6.0"
+version = "0.6.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d2f47f3fb4ba33644061e8e0e1030ef2a937d42dc969553118c320a205a9fb28"
+checksum = "d05dd813ef6bb798570308aa7f1245cefa350ec9f30dc53308335eb22b9d0f8b"
 dependencies = [
  "bstr",
  "gix-path",
@@ -717,9 +1046,9 @@ dependencies = [
 
 [[package]]
 name = "gix-date"
-version = "0.10.1"
+version = "0.10.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3a98593f1f1e14b9fa15c5b921b2c465e904d698b9463e21bb377be8376c3c1a"
+checksum = "139d1d52b21741e3f0c72b0fc65e1ff34d4eaceb100ef529d182725d2e09b8cb"
 dependencies = [
  "bstr",
  "itoa",
@@ -808,9 +1137,9 @@ dependencies = [
 
 [[package]]
 name = "gix-filter"
-version = "0.19.1"
+version = "0.19.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f90c21f0d61778f518bbb7c431b00247bf4534b2153c3e85bcf383876c55ca6c"
+checksum = "ecf004912949bbcf308d71aac4458321748ecb59f4d046830d25214208c471f1"
 dependencies = [
  "bstr",
  "encoding_rs",
@@ -843,9 +1172,9 @@ dependencies = [
 
 [[package]]
 name = "gix-glob"
-version = "0.20.0"
+version = "0.20.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2926b03666e83b8d01c10cf06e5733521aacbd2d97179a4c9b1fdddabb9e937d"
+checksum = "90181472925b587f6079698f79065ff64786e6d6c14089517a1972bca99fb6e9"
 dependencies = [
  "bitflags",
  "bstr",
@@ -891,9 +1220,9 @@ dependencies = [
 
 [[package]]
 name = "gix-index"
-version = "0.40.0"
+version = "0.40.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e6d505aea7d7c4267a3153cb90c712a89970b4dd02a2cb3205be322891f530b5"
+checksum = "b38e919efd59cb8275d23ad2394b2ab9d002007b27620e145d866d546403b665"
 dependencies = [
  "bitflags",
  "bstr",
@@ -1014,9 +1343,9 @@ dependencies = [
 
 [[package]]
 name = "gix-path"
-version = "0.10.17"
+version = "0.10.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c091d2e887e02c3462f52252c5ea61150270c0f2657b642e8d0d6df56c16e642"
+checksum = "567f65fec4ef10dfab97ae71f26a27fd4d7fe7b8e3f90c8a58551c41ff3fb65b"
 dependencies = [
  "bstr",
  "gix-trace",
@@ -1236,9 +1565,9 @@ dependencies = [
 
 [[package]]
 name = "gix-traverse"
-version = "0.46.1"
+version = "0.46.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "39094185f6d9a4d81101130fbbf7f598a06441d774ae3b3ae7930a613bbe1157"
+checksum = "b8648172f85aca3d6e919c06504b7ac26baef54e04c55eb0100fa588c102cc33"
 dependencies = [
  "bitflags",
  "gix-commitgraph",
@@ -1305,6 +1634,12 @@ dependencies = [
  "gix-validate",
 ]
 
+[[package]]
+name = "glob"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a8d1add55171497b4705a648c6b583acafb01d58050a51727785f0b2c8e0a2b2"
+
 [[package]]
 name = "globset"
 version = "0.4.16"
@@ -1364,6 +1699,12 @@ dependencies = [
  "byteorder",
 ]
 
+[[package]]
+name = "hashbrown"
+version = "0.12.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
+
 [[package]]
 name = "hashbrown"
 version = "0.14.5"
@@ -1372,6 +1713,7 @@ checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
 dependencies = [
  "ahash",
  "allocator-api2",
+ "serde",
 ]
 
 [[package]]
@@ -1424,6 +1766,7 @@ dependencies = [
  "slotmap",
  "smallvec",
  "smartstring",
+ "steel-core",
  "textwrap",
  "toml",
  "tree-house",
@@ -1546,9 +1889,10 @@ dependencies = [
  "arc-swap",
  "chrono",
  "content_inspector",
- "crossterm",
+ "crossterm 0.28.1",
  "fern",
  "futures-util",
+ "globset",
  "grep-regex",
  "grep-searcher",
  "helix-core",
@@ -1561,7 +1905,7 @@ dependencies = [
  "helix-vcs",
  "helix-view",
  "ignore",
- "indexmap",
+ "indexmap 2.9.0",
  "indoc",
  "libc",
  "log",
@@ -1575,6 +1919,8 @@ dependencies = [
  "signal-hook",
  "signal-hook-tokio",
  "smallvec",
+ "steel-core",
+ "steel-doc",
  "tempfile",
  "termini",
  "thiserror 2.0.12",
@@ -1590,11 +1936,12 @@ version = "25.1.1"
 dependencies = [
  "bitflags",
  "cassowary",
- "crossterm",
+ "crossterm 0.28.1",
  "helix-core",
  "helix-view",
  "log",
  "once_cell",
+ "steel-core",
  "termini",
  "unicode-segmentation",
 ]
@@ -1624,7 +1971,7 @@ dependencies = [
  "bitflags",
  "chardetng",
  "clipboard-win",
- "crossterm",
+ "crossterm 0.28.1",
  "futures-util",
  "helix-core",
  "helix-dap",
@@ -1644,6 +1991,7 @@ dependencies = [
  "serde_json",
  "slotmap",
  "smartstring",
+ "steel-core",
  "tempfile",
  "thiserror 2.0.12",
  "tokio",
@@ -1654,29 +2002,36 @@ dependencies = [
 
 [[package]]
 name = "hermit-abi"
-version = "0.3.9"
+version = "0.5.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"
+checksum = "fc0fef456e4baa96da950455cd02c081ca953b141298e41db3fc7e36b1da849c"
 
 [[package]]
 name = "home"
-version = "0.5.9"
+version = "0.5.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e3d1354bf6b7235cb4a0576c2619fd4ed18183f689b12b006a0ee7329eeff9a5"
+checksum = "589533453244b0995c858700322199b2becb13b627df2851f64a2775d024abcf"
 dependencies = [
- "windows-sys 0.52.0",
+ "windows-sys 0.59.0",
 ]
 
+[[package]]
+name = "httparse"
+version = "1.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6dbf3de79e51f3d586ab4cb9d5c3e2c14aa28ed23d180cf89b4df0454a69cc87"
+
 [[package]]
 name = "iana-time-zone"
-version = "0.1.60"
+version = "0.1.63"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e7ffbb5a1b541ea2561f8c41c087286cc091e21e556a4f09a8f6cbf17b69b141"
+checksum = "b0c919e5debc312ad217002b8048a17b7d83f80703865bbfcfebb0458b0b27d8"
 dependencies = [
  "android_system_properties",
  "core-foundation-sys",
  "iana-time-zone-haiku",
  "js-sys",
+ "log",
  "wasm-bindgen",
  "windows-core",
 ]
@@ -1692,21 +2047,22 @@ dependencies = [
 
 [[package]]
 name = "icu_collections"
-version = "1.5.0"
+version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "db2fa452206ebee18c4b5c2274dbf1de17008e874b4dc4f0aea9d01ca79e4526"
+checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
 dependencies = [
  "displaydoc",
+ "potential_utf",
  "yoke",
  "zerofrom",
  "zerovec",
 ]
 
 [[package]]
-name = "icu_locid"
-version = "1.5.0"
+name = "icu_locale_core"
+version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "13acbb8371917fc971be86fc8057c41a64b521c184808a698c02acc242dbf637"
+checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
 dependencies = [
  "displaydoc",
  "litemap",
@@ -1716,98 +2072,65 @@ dependencies = [
 ]
 
 [[package]]
-name = "icu_locid_transform"
-version = "1.5.0"
+name = "icu_normalizer"
+version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "01d11ac35de8e40fdeda00d9e1e9d92525f3f9d887cdd7aa81d727596788b54e"
+checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
 dependencies = [
  "displaydoc",
- "icu_locid",
- "icu_locid_transform_data",
+ "icu_collections",
+ "icu_normalizer_data",
+ "icu_properties",
  "icu_provider",
- "tinystr",
- "zerovec",
-]
-
-[[package]]
-name = "icu_locid_transform_data"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fdc8ff3388f852bede6b579ad4e978ab004f139284d7b28715f773507b946f6e"
-
-[[package]]
-name = "icu_normalizer"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "19ce3e0da2ec68599d193c93d088142efd7f9c5d6fc9b803774855747dc6a84f"
-dependencies = [
- "displaydoc",
- "icu_collections",
- "icu_normalizer_data",
- "icu_properties",
- "icu_provider",
- "smallvec",
- "utf16_iter",
- "utf8_iter",
- "write16",
+ "smallvec",
  "zerovec",
 ]
 
 [[package]]
 name = "icu_normalizer_data"
-version = "1.5.0"
+version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f8cafbf7aa791e9b22bec55a167906f9e1215fd475cd22adfcf660e03e989516"
+checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"
 
 [[package]]
 name = "icu_properties"
-version = "1.5.1"
+version = "2.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "93d6020766cfc6302c15dbbc9c8778c37e62c14427cb7f6e601d849e092aeef5"
+checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
 dependencies = [
  "displaydoc",
  "icu_collections",
- "icu_locid_transform",
+ "icu_locale_core",
  "icu_properties_data",
  "icu_provider",
- "tinystr",
+ "potential_utf",
+ "zerotrie",
  "zerovec",
 ]
 
 [[package]]
 name = "icu_properties_data"
-version = "1.5.0"
+version = "2.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "67a8effbc3dd3e4ba1afa8ad918d5684b8868b3b26500753effea8d2eed19569"
+checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"
 
 [[package]]
 name = "icu_provider"
-version = "1.5.0"
+version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6ed421c8a8ef78d3e2dbc98a973be2f3770cb42b606e3ab18d6237c4dfde68d9"
+checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
 dependencies = [
  "displaydoc",
- "icu_locid",
- "icu_provider_macros",
+ "icu_locale_core",
  "stable_deref_trait",
  "tinystr",
  "writeable",
  "yoke",
  "zerofrom",
+ "zerotrie",
  "zerovec",
 ]
 
-[[package]]
-name = "icu_provider_macros"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1ec89e9337638ecdc08744df490b221a7399bf8d164eb52a665454e60e075ad6"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn",
-]
-
 [[package]]
 name = "idna"
 version = "1.0.3"
@@ -1821,9 +2144,9 @@ dependencies = [
 
 [[package]]
 name = "idna_adapter"
-version = "1.2.0"
+version = "1.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "daca1df1c957320b2cf139ac61e7bd64fed304c5040df000a745aa1de3b4ef71"
+checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
 dependencies = [
  "icu_normalizer",
  "icu_properties",
@@ -1845,6 +2168,45 @@ dependencies = [
  "winapi-util",
 ]
 
+[[package]]
+name = "im"
+version = "15.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d0acd33ff0285af998aaf9b57342af478078f53492322fafc47450e09397e0e9"
+dependencies = [
+ "bitmaps",
+ "rand_core 0.6.4",
+ "rand_xoshiro",
+ "serde",
+ "sized-chunks",
+ "typenum",
+ "version_check",
+]
+
+[[package]]
+name = "im-lists"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "88485149c4fcec01ebce4e4b8284a3c75b3d8a4749169f5481144e6433e9bcd2"
+dependencies = [
+ "smallvec",
+]
+
+[[package]]
+name = "im-rc"
+version = "15.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "af1955a75fa080c677d3972822ec4bad316169ab1cfc6c257a942c2265dbe5fe"
+dependencies = [
+ "bitmaps",
+ "rand_core 0.6.4",
+ "rand_xoshiro",
+ "serde",
+ "sized-chunks",
+ "typenum",
+ "version_check",
+]
+
 [[package]]
 name = "imara-diff"
 version = "0.1.8"
@@ -1864,6 +2226,16 @@ dependencies = [
  "memchr",
 ]
 
+[[package]]
+name = "indexmap"
+version = "1.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
+dependencies = [
+ "autocfg",
+ "hashbrown 0.12.3",
+]
+
 [[package]]
 name = "indexmap"
 version = "2.9.0"
@@ -1901,15 +2273,15 @@ dependencies = [
 
 [[package]]
 name = "itoa"
-version = "1.0.11"
+version = "1.0.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"
+checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"
 
 [[package]]
 name = "jiff"
-version = "0.2.10"
+version = "0.2.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5a064218214dc6a10fbae5ec5fa888d80c45d611aba169222fc272072bf7aef6"
+checksum = "be1f93b8b1eb69c77f24bbb0afdf66f54b632ee39af40ca21c4365a1d7347e49"
 dependencies = [
  "jiff-static",
  "jiff-tzdb-platform",
@@ -1922,13 +2294,13 @@ dependencies = [
 
 [[package]]
 name = "jiff-static"
-version = "0.2.10"
+version = "0.2.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "199b7932d97e325aff3a7030e141eafe7f2c6268e1d1b24859b753a627f45254"
+checksum = "03343451ff899767262ec32146f6d559dd759fdadf42ff0e227c7c48f72594b4"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
 ]
 
 [[package]]
@@ -1948,10 +2320,11 @@ dependencies = [
 
 [[package]]
 name = "js-sys"
-version = "0.3.70"
+version = "0.3.77"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1868808506b929d7b0cfa8f75951347aa71bb21144b7791bae35d9bccfcfe37a"
+checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
 dependencies = [
+ "once_cell",
  "wasm-bindgen",
 ]
 
@@ -1970,16 +2343,68 @@ version = "0.2.174"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1171693293099992e19cddea4e8b849964e9846f4acee11b3948bcc337be8776"
 
+[[package]]
+name = "lasso"
+version = "0.7.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e14eda50a3494b3bf7b9ce51c52434a761e383d7238ce1dd5dcec2fbc13e9fb"
+dependencies = [
+ "ahash",
+ "dashmap",
+ "hashbrown 0.14.5",
+ "serde",
+]
+
+[[package]]
+name = "lazy-regex"
+version = "3.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "60c7310b93682b36b98fa7ea4de998d3463ccbebd94d935d6b48ba5b6ffa7126"
+dependencies = [
+ "lazy-regex-proc_macros",
+ "once_cell",
+ "regex",
+]
+
+[[package]]
+name = "lazy-regex-proc_macros"
+version = "3.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4ba01db5ef81e17eb10a5e0f2109d1b3a3e29bac3070fdbd7d156bf7dbd206a1"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "regex",
+ "syn 2.0.103",
+]
+
 [[package]]
 name = "libloading"
-version = "0.8.7"
+version = "0.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
+dependencies = [
+ "cfg-if",
+ "windows-targets 0.53.2",
+ "winapi",
+]
+
+[[package]]
+name = "libloading"
+version = "0.8.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6a793df0d7afeac54f95b471d3af7f0d4fb975699f972341a4b76988d49cdf0c"
+checksum = "07033963ba89ebaf1584d767badaa2e8fcec21aedea6b8c0346d487d49c28667"
 dependencies = [
  "cfg-if",
  "windows-targets 0.53.2",
 ]
 
+[[package]]
+name = "libm"
+version = "0.2.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f9fbbcab51052fe104eb5e5d351cf728d30a5be1fe14d9be8a3b097481fb97de"
+
 [[package]]
 name = "libredox"
 version = "0.1.3"
@@ -1993,30 +2418,36 @@ dependencies = [
 
 [[package]]
 name = "libz-rs-sys"
-version = "0.5.0"
+version = "0.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6489ca9bd760fe9642d7644e827b0c9add07df89857b0416ee15c1cc1a3b8c5a"
+checksum = "172a788537a2221661b480fee8dc5f96c580eb34fa88764d3205dc356c7e4221"
 dependencies = [
  "zlib-rs",
 ]
 
 [[package]]
 name = "linux-raw-sys"
-version = "0.4.14"
+version = "0.4.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"
+checksum = "d26c52dbd32dccf2d10cac7725f8eae5296885fb5703b261f7d0a0739ec807ab"
 
 [[package]]
 name = "linux-raw-sys"
-version = "0.9.2"
+version = "0.9.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6db9c683daf087dc577b7506e9695b3d556a9f3849903fa28186283afd6809e9"
+checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"
 
 [[package]]
 name = "litemap"
-version = "0.7.3"
+version = "0.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "643cb0b8d4fcc284004d5fd0d67ccf61dfffadb7f75e1e71bc420f4688a3a704"
+checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"
+
+[[package]]
+name = "litrs"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b4ce301924b7887e9d637144fdade93f9dfff9b60981d4ac161db09720d39aa5"
 
 [[package]]
 name = "lock_api"
@@ -2042,53 +2473,62 @@ checksum = "5cf92c10c7e361d6b99666ec1c6f9805b0bea2c3bd8c78dc6fe98ac5bd78db11"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
+]
+
+[[package]]
+name = "md-5"
+version = "0.10.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d89e7ee0cfbedfc4da3340218492196241d89eefb6dab27de5df917a6d2e78cf"
+dependencies = [
+ "cfg-if",
+ "digest",
 ]
 
 [[package]]
 name = "memchr"
-version = "2.7.4"
+version = "2.7.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"
+checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"
 
 [[package]]
 name = "memmap2"
-version = "0.9.4"
+version = "0.9.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fe751422e4a8caa417e13c3ea66452215d7d63e19e604f4980461212f3ae1322"
+checksum = "fd3f7eed9d3848f8b98834af67102b720745c4ec028fcd0aa0239277e7de374f"
 dependencies = [
  "libc",
 ]
 
 [[package]]
-name = "miniz_oxide"
-version = "0.7.4"
+name = "minimad"
+version = "0.13.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08"
+checksum = "a9c5d708226d186590a7b6d4a9780e2bdda5f689e0d58cd17012a298efd745d2"
 dependencies = [
- "adler",
+ "once_cell",
 ]
 
 [[package]]
 name = "miniz_oxide"
-version = "0.8.7"
+version = "0.8.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ff70ce3e48ae43fa075863cef62e8b43b71a4f2382229920e0df362592919430"
+checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
 dependencies = [
  "adler2",
 ]
 
 [[package]]
 name = "mio"
-version = "1.0.2"
+version = "1.0.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "80e04d1dcff3aae0704555fe5fee3bcfaf3d1fdf8a7e521d5b9d2b42acb52cec"
+checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
 dependencies = [
- "hermit-abi",
  "libc",
  "log",
- "wasi 0.11.0+wasi-snapshot-preview1",
- "windows-sys 0.52.0",
+ "wasi 0.11.1+wasi-snapshot-preview1",
+ "windows-sys 0.59.0",
 ]
 
 [[package]]
@@ -2112,6 +2552,37 @@ dependencies = [
  "unicode-segmentation",
 ]
 
+[[package]]
+name = "num-bigint"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a5e44f723f1133c9deac646763579fdb3ac745e418f2a7af9cd0c431da1f20b9"
+dependencies = [
+ "num-integer",
+ "num-traits",
+ "serde",
+]
+
+[[package]]
+name = "num-integer"
+version = "0.1.46"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "num-rational"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f83d14da390562dca69fc84082e73e548e1ad308d24accdedd2720017cb37824"
+dependencies = [
+ "num-bigint",
+ "num-integer",
+ "num-traits",
+]
+
 [[package]]
 name = "num-traits"
 version = "0.2.19"
@@ -2123,9 +2594,9 @@ dependencies = [
 
 [[package]]
 name = "num_cpus"
-version = "1.16.0"
+version = "1.17.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43"
+checksum = "91df4bbde75afed763b708b7eee1e8e7651e02d97f6d5dd763e89367e957b23b"
 dependencies = [
  "hermit-abi",
  "libc",
@@ -2133,9 +2604,9 @@ dependencies = [
 
 [[package]]
 name = "object"
-version = "0.36.4"
+version = "0.36.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "084f1a5821ac4c651660a94a7153d27ac9d8a53736203f58b31945ded098070a"
+checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
 dependencies = [
  "memchr",
 ]
@@ -2180,11 +2651,17 @@ dependencies = [
  "windows-targets 0.52.6",
 ]
 
+[[package]]
+name = "paste"
+version = "1.0.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"
+
 [[package]]
 name = "pathdiff"
-version = "0.2.1"
+version = "0.2.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8835116a5c179084a830efb3adc117ab007512b535bc1a21c991d3b32a6b44dd"
+checksum = "df94ce210e5bc13cb6651479fa48d14f601d9858cfe0467f43ae157023b938d3"
 
 [[package]]
 name = "percent-encoding"
@@ -2194,9 +2671,9 @@ checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"
 
 [[package]]
 name = "pin-project-lite"
-version = "0.2.14"
+version = "0.2.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"
+checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"
 
 [[package]]
 name = "pin-utils"
@@ -2204,11 +2681,26 @@ version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"
 
+[[package]]
+name = "polling"
+version = "3.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b53a684391ad002dd6a596ceb6c74fd004fdce75f4be2e3f615068abbea5fd50"
+dependencies = [
+ "cfg-if",
+ "concurrent-queue",
+ "hermit-abi",
+ "pin-project-lite",
+ "rustix 1.0.7",
+ "tracing",
+ "windows-sys 0.59.0",
+]
+
 [[package]]
 name = "portable-atomic"
-version = "1.11.0"
+version = "1.11.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "350e9b48cbc6b0e028b0473b114454c6316e57336ee184ceab6e53f72c178b3e"
+checksum = "f84267b20a16ea918e43c6a88433c2d54fa145c92a811b5b047ccbe153674483"
 
 [[package]]
 name = "portable-atomic-util"
@@ -2219,6 +2711,35 @@ dependencies = [
  "portable-atomic",
 ]
 
+[[package]]
+name = "potential_utf"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e5a7c30837279ca13e7c867e9e40053bc68740f988cb07f7ca6df43cc734b585"
+dependencies = [
+ "zerovec",
+]
+
+[[package]]
+name = "ppv-lite86"
+version = "0.2.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
+dependencies = [
+ "zerocopy",
+]
+
+[[package]]
+name = "pretty"
+version = "0.12.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ac98773b7109bc75f475ab5a134c9b64b87e59d776d31098d8f346922396a477"
+dependencies = [
+ "arrayvec",
+ "typed-arena",
+ "unicode-width 0.1.12",
+]
+
 [[package]]
 name = "proc-macro2"
 version = "1.0.95"
@@ -2238,6 +2759,15 @@ dependencies = [
  "parking_lot",
 ]
 
+[[package]]
+name = "psm"
+version = "0.1.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e944464ec8536cd1beb0bbfd96987eb5e3b72f2ecdafdc5c769a37f1fa2ae1f"
+dependencies = [
+ "cc",
+]
+
 [[package]]
 name = "pulldown-cmark"
 version = "0.13.0"
@@ -2255,7 +2785,17 @@ version = "1.0.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "588f6378e4dd99458b60ec275b4477add41ce4fa9f64dcba6f15adccb19b50d6"
 dependencies = [
- "rand",
+ "rand 0.8.5",
+]
+
+[[package]]
+name = "quickscope"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1d47bcfc3e13850589cf9338a02b6dfb5aebb3748a0f93a392e8df91d6193b6b"
+dependencies = [
+ "indexmap 1.9.3",
+ "smallvec",
 ]
 
 [[package]]
@@ -2267,13 +2807,39 @@ dependencies = [
  "proc-macro2",
 ]
 
+[[package]]
+name = "r-efi"
+version = "5.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "74765f6d916ee2faa39bc8e68e4f3ed8949b48cccdac59983d287a7cb71ce9c5"
+
 [[package]]
 name = "rand"
 version = "0.8.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
 dependencies = [
- "rand_core",
+ "rand_core 0.6.4",
+]
+
+[[package]]
+name = "rand"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9fbfd9d094a40bf3ae768db9361049ace4c0e04a4fd6b359518bd7b73a73dd97"
+dependencies = [
+ "rand_chacha",
+ "rand_core 0.9.3",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
+dependencies = [
+ "ppv-lite86",
+ "rand_core 0.9.3",
 ]
 
 [[package]]
@@ -2282,7 +2848,25 @@ version = "0.6.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
 dependencies = [
- "getrandom 0.2.15",
+ "getrandom 0.2.16",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
+dependencies = [
+ "getrandom 0.3.3",
+]
+
+[[package]]
+name = "rand_xoshiro"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6f97cdb2a36ed4183de61b2f824cc45c9f1037f28afe0a322e9fff4c108b5aaa"
+dependencies = [
+ "rand_core 0.6.4",
 ]
 
 [[package]]
@@ -2307,9 +2891,9 @@ dependencies = [
 
 [[package]]
 name = "redox_syscall"
-version = "0.5.3"
+version = "0.5.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2a908a6e00f1fdd0dfd9c0eb08ce85126f6d8bbda50017e74bc4a4b7d4a926a4"
+checksum = "0d04b7d0ee6b4a0207a0a7adb104d23ecb0b47d6beae7152d0fa34b692b29fd6"
 dependencies = [
  "bitflags",
 ]
@@ -2356,6 +2940,15 @@ version = "0.8.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"
 
+[[package]]
+name = "repr_offset"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fb1070755bd29dffc19d0971cab794e607839ba2ef4b69a9e6fbc8733c1b72ea"
+dependencies = [
+ "tstr",
+]
+
 [[package]]
 name = "ropey"
 version = "1.6.1"
@@ -2368,9 +2961,18 @@ dependencies = [
 
 [[package]]
 name = "rustc-demangle"
-version = "0.1.24"
+version = "0.1.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "989e6739f80c4ad5b13e0fd7fe89531180375b18520cc8c82080e4dc4035b84f"
+
+[[package]]
+name = "rustc_version"
+version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"
+checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
+dependencies = [
+ "semver",
+]
 
 [[package]]
 name = "rustix"
@@ -2381,7 +2983,7 @@ dependencies = [
  "bitflags",
  "errno",
  "libc",
- "linux-raw-sys 0.4.14",
+ "linux-raw-sys 0.4.15",
  "windows-sys 0.59.0",
 ]
 
@@ -2394,15 +2996,21 @@ dependencies = [
  "bitflags",
  "errno",
  "libc",
- "linux-raw-sys 0.9.2",
+ "linux-raw-sys 0.9.4",
  "windows-sys 0.59.0",
 ]
 
+[[package]]
+name = "rustversion"
+version = "1.0.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"
+
 [[package]]
 name = "ryu"
-version = "1.0.18"
+version = "1.0.20"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f"
+checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"
 
 [[package]]
 name = "same-file"
@@ -2419,6 +3027,12 @@ version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
 
+[[package]]
+name = "semver"
+version = "1.0.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"
+
 [[package]]
 name = "serde"
 version = "1.0.219"
@@ -2436,7 +3050,7 @@ checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
 ]
 
 [[package]]
@@ -2516,9 +3130,9 @@ dependencies = [
 
 [[package]]
 name = "signal-hook-registry"
-version = "1.4.2"
+version = "1.4.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1"
+checksum = "9203b8055f63a2a00e2f593bb0510367fe707d7ff1e5c872de2f537b339e5410"
 dependencies = [
  "libc",
 ]
@@ -2535,6 +3149,16 @@ dependencies = [
  "tokio",
 ]
 
+[[package]]
+name = "sized-chunks"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "16d69225bde7a69b235da73377861095455d298f2b970996eec25ddbb42b3d1e"
+dependencies = [
+ "bitmaps",
+ "typenum",
+]
+
 [[package]]
 name = "slab"
 version = "0.4.9"
@@ -2579,9 +3203,9 @@ checksum = "b7c388c1b5e93756d0c740965c41e8822f866621d41acbdf6336a6a168f8840c"
 
 [[package]]
 name = "socket2"
-version = "0.5.7"
+version = "0.5.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ce305eb0b4296696835b71df73eb912e0f1ffd2556a501fcede6e0c50349191c"
+checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
 dependencies = [
  "libc",
  "windows-sys 0.52.0",
@@ -2593,23 +3217,156 @@ version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"
 
+[[package]]
+name = "stacker"
+version = "0.1.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cddb07e32ddb770749da91081d8d0ac3a16f1a569a18b20348cd371f5dead06b"
+dependencies = [
+ "cc",
+ "cfg-if",
+ "libc",
+ "psm",
+ "windows-sys 0.59.0",
+]
+
 [[package]]
 name = "static_assertions"
 version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"
 
+[[package]]
+name = "steel-core"
+version = "0.7.0"
+source = "git+https://github.com/mattwparas/steel.git#80a1c96ff0d7b650fa8dd79b76e5391b9c1c116e"
+dependencies = [
+ "abi_stable",
+ "anyhow",
+ "arc-swap",
+ "async-ffi",
+ "bigdecimal",
+ "bincode",
+ "chrono",
+ "codespan-reporting",
+ "compact_str",
+ "crossbeam-channel",
+ "crossbeam-utils",
+ "env_home",
+ "futures-executor",
+ "futures-task",
+ "futures-util",
+ "fxhash",
+ "getrandom 0.3.3",
+ "glob",
+ "httparse",
+ "im",
+ "im-lists",
+ "im-rc",
+ "lasso",
+ "log",
+ "md-5",
+ "num-bigint",
+ "num-integer",
+ "num-rational",
+ "num-traits",
+ "once_cell",
+ "parking_lot",
+ "polling",
+ "quickscope",
+ "rand 0.9.1",
+ "serde",
+ "serde_json",
+ "smallvec",
+ "stacker",
+ "steel-derive",
+ "steel-gen",
+ "steel-parser",
+ "strsim",
+ "termimad",
+ "weak-table",
+ "which 7.0.3",
+ "xdg",
+]
+
+[[package]]
+name = "steel-derive"
+version = "0.6.0"
+source = "git+https://github.com/mattwparas/steel.git#80a1c96ff0d7b650fa8dd79b76e5391b9c1c116e"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.103",
+]
+
+[[package]]
+name = "steel-doc"
+version = "0.7.0"
+source = "git+https://github.com/mattwparas/steel.git#80a1c96ff0d7b650fa8dd79b76e5391b9c1c116e"
+dependencies = [
+ "steel-core",
+]
+
+[[package]]
+name = "steel-gen"
+version = "0.3.0"
+source = "git+https://github.com/mattwparas/steel.git#80a1c96ff0d7b650fa8dd79b76e5391b9c1c116e"
+dependencies = [
+ "codegen",
+ "serde",
+]
+
+[[package]]
+name = "steel-parser"
+version = "0.7.0"
+source = "git+https://github.com/mattwparas/steel.git#80a1c96ff0d7b650fa8dd79b76e5391b9c1c116e"
+dependencies = [
+ "compact_str",
+ "fxhash",
+ "lasso",
+ "num-bigint",
+ "num-rational",
+ "num-traits",
+ "once_cell",
+ "pretty",
+ "serde",
+ "smallvec",
+]
+
 [[package]]
 name = "str_indices"
-version = "0.4.3"
+version = "0.4.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e9557cb6521e8d009c51a8666f09356f4b817ba9ba0981a305bd86aee47bd35c"
+checksum = "d08889ec5408683408db66ad89e0e1f93dff55c73a4ccc71c427d5b277ee47e6"
+
+[[package]]
+name = "strict"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f42444fea5b87a39db4218d9422087e66a85d0e7a0963a439b07bcdf91804006"
+
+[[package]]
+name = "strsim"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"
+
+[[package]]
+name = "syn"
+version = "1.0.109"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
 
 [[package]]
 name = "syn"
-version = "2.0.101"
+version = "2.0.103"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8ce2b7fc941b3a24138a0a7cf8e858bfc6a992e7978a068a5c760deb0ed43caf"
+checksum = "e4307e30089d6fd6aff212f2da3a1f9e32f3223b1f010fb09b7c95f90f3ca1e8"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -2618,13 +3375,13 @@ dependencies = [
 
 [[package]]
 name = "synstructure"
-version = "0.13.1"
+version = "0.13.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c8af7666ab7b6390ab78131fb5b0fce11d6b7a6951602017c35fa82800708971"
+checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
 ]
 
 [[package]]
@@ -2634,12 +3391,37 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e8a64e3985349f2441a1a9ef0b853f869006c3855f2cda6862a94d26ebb9d6a1"
 dependencies = [
  "fastrand",
- "getrandom 0.3.1",
+ "getrandom 0.3.3",
  "once_cell",
  "rustix 1.0.7",
  "windows-sys 0.59.0",
 ]
 
+[[package]]
+name = "termcolor"
+version = "1.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
+dependencies = [
+ "winapi-util",
+]
+
+[[package]]
+name = "termimad"
+version = "0.31.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7301d9c2c4939c97f25376b70d3c13311f8fefdee44092fc361d2a98adc2cbb6"
+dependencies = [
+ "coolor",
+ "crokey",
+ "crossbeam",
+ "lazy-regex",
+ "minimad",
+ "serde",
+ "thiserror 2.0.12",
+ "unicode-width 0.1.12",
+]
+
 [[package]]
 name = "termini"
 version = "1.0.0"
@@ -2657,7 +3439,7 @@ checksum = "c13547615a44dc9c452a8a534638acdf07120d4b6847c8178705da06306a3057"
 dependencies = [
  "smawk",
  "unicode-linebreak",
- "unicode-width 0.2.0",
+ "unicode-width 0.2.1",
 ]
 
 [[package]]
@@ -2686,7 +3468,7 @@ checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
 ]
 
 [[package]]
@@ -2697,7 +3479,7 @@ checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
 ]
 
 [[package]]
@@ -2711,9 +3493,9 @@ dependencies = [
 
 [[package]]
 name = "tinystr"
-version = "0.7.6"
+version = "0.8.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9117f5d4db391c1cf6927e7bea3db74b9a1c1add8f7eda9ffd5364f40f57b82f"
+checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
 dependencies = [
  "displaydoc",
  "zerovec",
@@ -2721,9 +3503,9 @@ dependencies = [
 
 [[package]]
 name = "tinyvec"
-version = "1.8.0"
+version = "1.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "445e881f4f6d382d5f27c034e25eb92edd7c784ceab92a0937db7f2e9471b938"
+checksum = "09b3661f17e86524eccd4371ab0429194e0d7c008abb45f7a7495b1719463c71"
 dependencies = [
  "tinyvec_macros",
 ]
@@ -2760,7 +3542,7 @@ checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
 ]
 
 [[package]]
@@ -2801,7 +3583,7 @@ version = "0.22.27"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
 dependencies = [
- "indexmap",
+ "indexmap 2.9.0",
  "serde",
  "serde_spanned",
  "toml_datetime",
@@ -2815,6 +3597,22 @@ version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5d99f8c9a7727884afe522e9bd5edbfc91a3312b36a77b5fb8926e4c31a41801"
 
+[[package]]
+name = "tracing"
+version = "0.1.41"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
+dependencies = [
+ "pin-project-lite",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-core"
+version = "0.1.34"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
+
 [[package]]
 name = "tree-house"
 version = "0.3.0"
@@ -2839,12 +3637,33 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "690809022f44e3d2329882649724b6e0027ade3fada65e4631d303e744dc32b4"
 dependencies = [
  "cc",
- "libloading",
+ "libloading 0.8.8",
  "regex-cursor",
  "ropey",
  "thiserror 2.0.12",
 ]
 
+[[package]]
+name = "tstr"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7f8e0294f14baae476d0dd0a2d780b2e24d66e349a9de876f5126777a37bdba7"
+dependencies = [
+ "tstr_proc_macros",
+]
+
+[[package]]
+name = "tstr_proc_macros"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e78122066b0cb818b8afd08f7ed22f7fdbc3e90815035726f0840d0d26c0747a"
+
+[[package]]
+name = "typed-arena"
+version = "2.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6af6ae20167a9ece4bcb41af5b80f8a1f1df981f6391189ce00fd257af04126a"
+
 [[package]]
 name = "typenum"
 version = "1.18.0"
@@ -2853,12 +3672,9 @@ checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"
 
 [[package]]
 name = "unicase"
-version = "2.7.0"
+version = "2.8.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f7d2d4dafb69621809a81864c9c1b864479e1235c0dd4e199924b9742439ed89"
-dependencies = [
- "version_check",
-]
+checksum = "75b844d17643ee918803943289730bec8aac480150456169e647ed0b576ba539"
 
 [[package]]
 name = "unicode-bom"
@@ -2874,9 +3690,9 @@ checksum = "24adfe8311434967077a6adff125729161e6e4934d76f6b7c55318ac5c9246d3"
 
 [[package]]
 name = "unicode-ident"
-version = "1.0.12"
+version = "1.0.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"
+checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"
 
 [[package]]
 name = "unicode-linebreak"
@@ -2886,9 +3702,9 @@ checksum = "3b09c83c3c29d37506a3e260c08c03743a6bb66a9cd432c6934ab501a190571f"
 
 [[package]]
 name = "unicode-normalization"
-version = "0.1.23"
+version = "0.1.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a56d1686db2308d901306f92a263857ef59ea39678a5458e7cb17f01415101f5"
+checksum = "5033c97c4262335cded6d6fc3e5c18ab755e1a3dc96376350f3d8e9f009ad956"
 dependencies = [
  "tinyvec",
 ]
@@ -2907,9 +3723,9 @@ checksum = "68f5e5f3158ecfd4b8ff6fe086db7c8467a2dfdac97fe420f2b7c4aa97af66d6"
 
 [[package]]
 name = "unicode-width"
-version = "0.2.0"
+version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1fc81956842c57dac11422a97c3b8195a1ff727f06e85c84ed2e8aa277c9a0fd"
+checksum = "4a1a07cc7db3810833284e8d372ccdc6da29741639ecc70c9ec107df0fa6154c"
 
 [[package]]
 name = "url"
@@ -2923,12 +3739,6 @@ dependencies = [
  "serde",
 ]
 
-[[package]]
-name = "utf16_iter"
-version = "1.0.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c8232dd3cdaed5356e0f716d285e4b40b932ac434100fe9b7e0e8e935b9e6246"
-
 [[package]]
 name = "utf8_iter"
 version = "1.0.4"
@@ -2953,50 +3763,50 @@ dependencies = [
 
 [[package]]
 name = "wasi"
-version = "0.11.0+wasi-snapshot-preview1"
+version = "0.11.1+wasi-snapshot-preview1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
+checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"
 
 [[package]]
 name = "wasi"
-version = "0.13.3+wasi-0.2.2"
+version = "0.14.2+wasi-0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "26816d2e1a4a36a2940b96c5296ce403917633dff8f3440e9b236ed6f6bacad2"
+checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
 dependencies = [
  "wit-bindgen-rt",
 ]
 
 [[package]]
 name = "wasm-bindgen"
-version = "0.2.93"
+version = "0.2.100"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a82edfc16a6c469f5f44dc7b571814045d60404b55a0ee849f9bcfa2e63dd9b5"
+checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
 dependencies = [
  "cfg-if",
  "once_cell",
+ "rustversion",
  "wasm-bindgen-macro",
 ]
 
 [[package]]
 name = "wasm-bindgen-backend"
-version = "0.2.93"
+version = "0.2.100"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9de396da306523044d3302746f1208fa71d7532227f15e347e2d93e4145dd77b"
+checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
 dependencies = [
  "bumpalo",
  "log",
- "once_cell",
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-macro"
-version = "0.2.93"
+version = "0.2.100"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "585c4c91a46b072c92e908d99cb1dcdf95c5218eeb6f3bf1efa991ee7a68cccf"
+checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
 dependencies = [
  "quote",
  "wasm-bindgen-macro-support",
@@ -3004,22 +3814,43 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-macro-support"
-version = "0.2.93"
+version = "0.2.100"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "afc340c74d9005395cf9dd098506f7f44e38f2b4a21c6aaacf9a105ea5e1e836"
+checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-shared"
-version = "0.2.93"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "weak-table"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "323f4da9523e9a669e1eaf9c6e763892769b1d38c623913647bfdc1532fe4549"
+
+[[package]]
+name = "which"
+version = "7.0.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c62a0a307cb4a311d3a07867860911ca130c3494e8c2719593806c08bc5d0484"
+checksum = "24d643ce3fd3e5b54854602a080f34fb10ab75e0b813ee32d00ca2b44fa74762"
+dependencies = [
+ "either",
+ "env_home",
+ "rustix 1.0.7",
+ "winsafe",
+]
 
 [[package]]
 name = "which"
@@ -3065,18 +3896,63 @@ checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
 name = "windows-core"
-version = "0.52.0"
+version = "0.61.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
+checksum = "c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3"
 dependencies = [
  "windows-targets 0.52.6",
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.103",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.103",
 ]
 
 [[package]]
 name = "windows-link"
-version = "0.1.0"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"
+
+[[package]]
+name = "windows-result"
+version = "0.3.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6dccfd733ce2b1753b03b6d3c65edf020262ea35e20ccdf3e288043e6dd620e3"
+checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
+dependencies = [
+ "windows-link",
+]
 
 [[package]]
 name = "windows-sys"
@@ -3237,7 +4113,13 @@ checksum = "271414315aff87387382ec3d271b52d7ae78726f5d44ac98b4f4030c91880486"
 name = "winnow"
 version = "0.7.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c06928c8748d81b05c9be96aad92e1b6ff01833332f281e8cfca3be4b35fc9ec"
+checksum = "271414315aff87387382ec3d271b52d7ae78726f5d44ac98b4f4030c91880486"
+
+[[package]]
+name = "winnow"
+version = "0.7.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "74c7b26e3480b707944fc872477815d29a8e429d2f93a1ce000f5fa84a15cbcd"
 dependencies = [
  "memchr",
 ]
@@ -3250,24 +4132,24 @@ checksum = "d135d17ab770252ad95e9a872d365cf3090e3be864a34ab46f48555993efc904"
 
 [[package]]
 name = "wit-bindgen-rt"
-version = "0.33.0"
+version = "0.39.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3268f3d866458b787f390cf61f4bbb563b922d091359f9608842999eaee3943c"
+checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
 dependencies = [
  "bitflags",
 ]
 
 [[package]]
-name = "write16"
-version = "1.0.0"
+name = "writeable"
+version = "0.6.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d1890f4022759daae28ed4fe62859b1236caebfc61ede2f63ed4e695f3f6d936"
+checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"
 
 [[package]]
-name = "writeable"
-version = "0.5.5"
+name = "xdg"
+version = "3.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1e9df38ee2d2c3c5948ea468a8406ff0db0b29ae1ffde1bcf20ef305bcc95c51"
+checksum = "2fb433233f2df9344722454bc7e96465c9d03bff9d77c248f9e7523fe79585b5"
 
 [[package]]
 name = "xtask"
@@ -3282,9 +4164,9 @@ dependencies = [
 
 [[package]]
 name = "yoke"
-version = "0.7.4"
+version = "0.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6c5b1314b079b0930c31e3af543d8ee1757b1951ae1e1565ec704403a7240ca5"
+checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
 dependencies = [
  "serde",
  "stable_deref_trait",
@@ -3294,13 +4176,13 @@ dependencies = [
 
 [[package]]
 name = "yoke-derive"
-version = "0.7.4"
+version = "0.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "28cc31741b18cb6f1d5ff12f5b7523e3d6eb0852bbbad19d73905511d9849b95"
+checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
  "synstructure",
 ]
 
@@ -3321,35 +4203,46 @@ checksum = "28a6e20d751156648aa063f3800b706ee209a32c0b4d9f24be3d980b01be55ef"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
 ]
 
 [[package]]
 name = "zerofrom"
-version = "0.1.4"
+version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "91ec111ce797d0e0784a1116d0ddcdbea84322cd79e5d5ad173daeba4f93ab55"
+checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
 dependencies = [
  "zerofrom-derive",
 ]
 
 [[package]]
 name = "zerofrom-derive"
-version = "0.1.4"
+version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0ea7b4a3637ea8669cedf0f1fd5c286a17f3de97b8dd5a70a6c167a1730e63a5"
+checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
  "synstructure",
 ]
 
+[[package]]
+name = "zerotrie"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
+dependencies = [
+ "displaydoc",
+ "yoke",
+ "zerofrom",
+]
+
 [[package]]
 name = "zerovec"
-version = "0.10.4"
+version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "aa2b893d79df23bfb12d5461018d408ea19dfafe76c2c7ef6d4eba614f8ff079"
+checksum = "4a05eb080e015ba39cc9e23bbe5e7fb04d5fb040350f99f34e338d5fdd294428"
 dependencies = [
  "yoke",
  "zerofrom",
@@ -3358,17 +4251,17 @@ dependencies = [
 
 [[package]]
 name = "zerovec-derive"
-version = "0.10.3"
+version = "0.11.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6eafa6dfb17584ea3e2bd6e76e0cc15ad7af12b09abdd1ca55961bed9b1063c6"
+checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.103",
 ]
 
 [[package]]
 name = "zlib-rs"
-version = "0.5.0"
+version = "0.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "868b928d7949e09af2f6086dfc1e01936064cc7a819253bce650d4e2a2d63ba8"
+checksum = "626bd9fa9734751fc50d6060752170984d7053f5a39061f524cda68023d4db8a"
diff --git a/Cargo.toml b/Cargo.toml
index ecb5c7e26..34a7bedb8 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -40,6 +40,9 @@ package.helix-term.opt-level = 2
 tree-house = { version = "0.3.0", default-features = false }
 nucleo = "0.5.0"
 slotmap = "1.0.7"
+# If working locally, use the local path dependency
+# steel-core = { path = "/home/matt/code/scratch/steel/crates/steel-core", version = "0.6.0", features = ["anyhow", "dylibs", "sync"] }
+steel-core = { git = "https://github.com/mattwparas/steel.git", version = "0.7.0", features = ["anyhow", "dylibs", "sync"] }
 thiserror = "2.0"
 tempfile = "3.20.0"
 bitflags = "2.9"
diff --git a/STEEL.md b/STEEL.md
new file mode 100644
index 000000000..153439146
--- /dev/null
+++ b/STEEL.md
@@ -0,0 +1,256 @@
+# Building
+
+You will need:
+
+* A clone of this fork, on the branch `steel-event-system`
+
+## Installing helix
+
+Just run
+
+`cargo xtask steel`
+
+To install the `hx` executable, with steel as a plugin language. This also includes:
+
+The `steel` executable, the steel language server, the steel dylib installer, and the steel package manager `forge`.
+
+## Setting up configurations for helix
+
+There are 2 important files you'll want, which should be auto generated during the installation process if they don't already exist:
+
+* `~/.config/helix/helix.scm`
+* `~/.config/helix/init.scm`
+
+Note - these both live inside the same directory that helix sets up for runtime configurations.
+
+### `helix.scm`
+
+The `helix.scm` module will be loaded first before anything else, the runtime will `require` this module, and any functions exported will now be available
+to be used as typed commands. For example:
+
+
+```scheme
+# helix.scm
+(require "helix/editor.scm")
+(require (prefix-in helix. "helix/commands.scm"))
+(require (prefix-in helix.static. "helix/static.scm"))
+
+(provide shell git-add open-helix-scm open-init-scm)
+
+;;@doc
+;; Specialized shell implementation, where % is a wildcard for the current file
+(define (shell cx . args)
+  ;; Replace the % with the current file
+  (define expanded (map (lambda (x) (if (equal? x "%") (current-path cx) x)) args))
+  (apply helix.run-shell-command expanded))
+
+;;@doc
+;; Adds the current file to git	
+(define (git-add cx)
+  (shell cx "git" "add" "%"))
+
+(define (current-path)
+  (let* ([focus (editor-focus)]
+         [focus-doc-id (editor->doc-id focus)])
+    (editor-document->path focus-doc-id)))
+
+;;@doc
+;; Open the helix.scm file
+(define (open-helix-scm)
+  (helix.open (helix.static.get-helix-scm-path)))
+
+;;@doc
+;; Opens the init.scm file
+(define (open-init-scm)
+  (helix.open (helix.static.get-init-scm-path)))
+  
+	
+```
+
+Now, if you'd like to add the current file you're editing to git, simply type `:git-add` - you'll see the doc pop up with it since we've annotated the function
+with the `@doc` symbol. Hitting enter will execute the command.
+
+You can also conveniently open the `helix.scm` file by using the typed command `:open-helix-scm`.
+
+
+### `init.scm`
+
+The `init.scm` file is run at the top level, immediately after the `helix.scm` module is `require`d. The helix context is available here, so you can interact with the editor.
+
+The helix context is bound to the top level variable `*helix.cx*`.
+
+For example, if we wanted to select a random theme at startup:
+
+```scheme
+# init.scm
+
+(require-builtin steel/random as rand::)
+(require (prefix-in helix. "helix/commands.scm"))
+(require (prefix-in helix.static. "helix/static.scm"))
+
+;; Picking one from the possible themes
+(define possible-themes '("ayu_mirage" "tokyonight_storm" "catppuccin_macchiato"))
+
+(define (select-random lst)
+  (let ([index (rand::rng->gen-range 0 (length lst))]) (list-ref lst index)))
+
+(define (randomly-pick-theme options)
+  ;; Randomly select the theme from the possible themes list
+  (helix.theme (select-random options)))
+
+(randomly-pick-theme possible-themes)
+
+```
+
+### Libraries for helix
+
+There are a handful of extra libraries in development for extending helix, and can be found here https://github.com/mattwparas/helix-config.
+
+If you'd like to use them, create a directory called `cogs` in your `.config/helix` directory, and copy the files in there.
+
+### options.scm
+
+If you'd like to override configurations from your toml config:
+
+
+```scheme
+# init.scm
+
+(require "helix/configuration.scm")
+
+(file-picker (fp-hidden #f))
+(cursorline #t)
+(soft-wrap (sw-enable #t))
+
+```
+
+
+### keymaps.scm
+
+Applying custom keybindings for certain file extensions:
+
+```scheme
+# init.scm
+
+(require "cogs/keymaps.scm")
+(require (only-in "cogs/file-tree.scm" FILE-TREE-KEYBINDINGS FILE-TREE))
+(require (only-in "cogs/recentf.scm" recentf-open-files get-recent-files recentf-snapshot))
+
+;; Set the global keybinding for now
+(add-global-keybinding (hash "normal" (hash "C-r" (hash "f" ":recentf-open-files"))))
+
+(define scm-keybindings (hash "insert" (hash "ret" ':scheme-indent "C-l" ':insert-lambda)))
+
+;; Grab whatever the existing keybinding map is
+(define standard-keybindings (deep-copy-global-keybindings))
+
+(define file-tree-base (deep-copy-global-keybindings))
+
+(merge-keybindings standard-keybindings scm-keybindings)
+(merge-keybindings file-tree-base FILE-TREE-KEYBINDINGS)
+
+(set-global-buffer-or-extension-keymap (hash "scm" standard-keybindings FILE-TREE file-tree-base))
+	
+```
+
+In insert mode, this overrides the `ret` keybinding to instead use a custom scheme indent function. Functions _must_ be available as typed commands, and are referred to
+as symbols. So in this case, the `scheme-indent` function was exported by my `helix.scm` module.
+
+
+## Writing a plugin
+
+### Getting setup
+
+Before you start, you should make sure that your configuration for the steel lsp is wired up correctly. This will give you
+access to the documentation that will help you as you write your plugin. To configure the LSP, you can add this to your
+`init.scm`:
+
+```scheme
+(require "helix/configuration.scm")
+(define-lsp "steel-language-server" (command "steel-language-server") (args '()))
+(define-language "scheme"
+                 (language-servers '("steel-language-server")))
+```
+
+This will give you an interactive setup that can help you run plugins as you go. I also like to evaluate commands
+via the buffer, by either typing them in to the command prompt or by loading the current buffer. To load the current
+buffer, you can type `:eval-buffer`, or to evaluate an individual command, you can run `:evalp` - note, in your init.scm, you
+may need to add:
+
+```scheme
+(require (only-in "helix/ext" evalp eval-buffer))
+```
+
+This brings those functions to the top level scope so that you can interact with them. You may also be keen to peruse all of the steel
+functions and modules available. Those can be found in `steel-docs.md`.
+
+
+### Command API
+
+There are two levels of the functionality exposed to plugins. The first is simply based around
+chaining builtin commands, as if you're a lightning fast human typing commands very quickly. The other level
+is a bit lower, and deals directly with the component API that helix uses to draw the text editor and various
+popups, like the file picker or buffer selection.
+
+To understand the first level, which is accessing typed commands and static commands, i.e. commands that you
+typically type via `:`, or static commands, commands which are bound to keybindings, you can look at the modules:
+
+* helix/commands.scm
+* helix/static.scm
+
+Every function here implicitly has access to a context, the helix context. This assumes that you're focused onto
+some buffer, and any actions are assumed to be done within that context. For example, calling `vsplit` will
+split the currently focused into a second, and move your focus to that window. Keeping track of that is important
+to understand where your focus is.
+
+In general, these functions do not return anything, given that they're purely for side effects. There are some functions
+that do, and they should be documented as such. The API will need to be improved to return useful things where relevant.
+
+### The UI
+
+A good rule of thumb is to not block the UI. During the execution of a steel function, the helix context is exclusively
+available to that executing function. As a result, you should not have long running functions there (note - if you end
+up having an infinite loop of some kind, `ctrl-c` should break you out).
+
+Luckily, there are a handful of ways we can accomplish more sophisticated plugins:
+
+* Futures
+* Threads
+
+There are a handful of primitives that accept a future + a callback, where the callback will get executed once the future
+is complete. The future will get scheduled on to the helix event loop, so the UI won't be blocked. (TODO: Document this more!)
+
+Another way we can accomplish this is with native threads. Steel supports native threads, which means we can spawn a function
+off on to another thread to run some code. Consider the following example which won't work:
+
+
+```scheme
+(spawn-native-thread (lambda () (sleep/ms 1000) (theme "focus_nova"))) ;; Note, this won't work!
+```
+
+This appears to spawn a thread, sleep for 1 second, and then change the theme. The issue here is that this thread does not
+have control over the helix context. So what we'll have to do instead, is schedule a function to be run on the main thread:
+
+
+```scheme
+(require "helix/ext.scm")
+(require-builtin steel/time)
+
+(spawn-native-thread
+  (lambda ()
+    (hx.block-on-task
+      (lambda ()
+        (sleep/ms 1000)
+        (theme "focus_nova")))))
+```
+
+`hx.block-on-task` will check if we're running on the main thread. If we are already, it doesn't do anything - but otherwise,
+it enqueues a callback that schedules itself onto the main thread, and waits till it can acquire the helix context. The function
+is then run, and the value returned back to this thread of control.
+
+
+There is also `hx.with-context` which does a similar thing, except it does _not_ block the current thread.
+
+### Components
+
+Coming soon!
diff --git a/helix-core/Cargo.toml b/helix-core/Cargo.toml
index 4e825364b..be153d143 100644
--- a/helix-core/Cargo.toml
+++ b/helix-core/Cargo.toml
@@ -14,6 +14,7 @@ homepage.workspace = true
 [features]
 unicode-lines = ["ropey/unicode_lines"]
 integration = []
+steel = ["dep:steel-core"]
 
 [dependencies]
 helix-stdx = { path = "../helix-stdx" }
@@ -53,6 +54,7 @@ chrono = { version = "0.4", default-features = false, features = ["alloc", "std"
 
 textwrap = "0.16.2"
 
+steel-core = { workspace = true, optional = true }
 nucleo.workspace = true
 parking_lot.workspace = true
 globset = "0.4.16"
diff --git a/helix-core/src/command_line.rs b/helix-core/src/command_line.rs
index 8e209d618..de377a920 100644
--- a/helix-core/src/command_line.rs
+++ b/helix-core/src/command_line.rs
@@ -766,6 +766,13 @@ pub fn new(signature: Signature, validate: bool) -> Self {
         }
     }
 
+    pub fn raw(positionals: Vec<Cow<'a, str>>) -> Self {
+        Self {
+            positionals,
+            ..Self::default()
+        }
+    }
+
     /// Reads the next token out of the given parser.
     ///
     /// If the command's signature sets a maximum number of positionals (via `raw_after`) then
@@ -1123,7 +1130,7 @@ fn tokenize_percent() {
         assert_incomplete_tokens(r#"echo %{hello {{} world}"#, &["echo", "hello {{} world}"]);
     }
 
-    fn parse_signature<'a>(
+    pub fn parse_signature<'a>(
         input: &'a str,
         signature: Signature,
     ) -> Result<Args<'a>, Box<dyn std::error::Error + 'a>> {
diff --git a/helix-core/src/extensions.rs b/helix-core/src/extensions.rs
new file mode 100644
index 000000000..6c8411574
--- /dev/null
+++ b/helix-core/src/extensions.rs
@@ -0,0 +1,490 @@
+#[cfg(feature = "steel")]
+pub mod steel_implementations {
+
+    use std::borrow::Cow;
+
+    use steel::{
+        gc::ShareableMut,
+        rvals::{as_underlying_type, AsRefSteelVal, Custom, SteelString},
+        steel_vm::{
+            builtin::{BuiltInModule, MarkdownDoc},
+            register_fn::RegisterFn,
+        },
+        SteelVal,
+    };
+
+    use helix_stdx::rope::RopeSliceExt;
+
+    use crate::syntax::config::{AutoPairConfig, SoftWrap};
+
+    impl steel::rvals::Custom for crate::Position {}
+    impl steel::rvals::Custom for crate::Selection {}
+    impl steel::rvals::Custom for AutoPairConfig {}
+    impl steel::rvals::Custom for SoftWrap {}
+
+    #[allow(unused)]
+    pub struct RopeyError(ropey::Error);
+
+    impl steel::rvals::Custom for RopeyError {}
+
+    impl From<ropey::Error> for RopeyError {
+        fn from(value: ropey::Error) -> Self {
+            Self(value)
+        }
+    }
+
+    #[derive(Clone, Copy, Debug, PartialEq, Eq)]
+    enum RangeKind {
+        Char,
+        Byte,
+    }
+
+    #[derive(Clone, PartialEq, Eq)]
+    pub struct SteelRopeSlice {
+        text: crate::Rope,
+        start: usize,
+        end: usize,
+        kind: RangeKind,
+    }
+
+    impl Custom for SteelRopeSlice {
+        // `equal?` on two ropes should return true if they are the same
+        fn equality_hint(&self, other: &dyn steel::rvals::CustomType) -> bool {
+            if let Some(other) = as_underlying_type::<SteelRopeSlice>(other) {
+                self == other
+            } else {
+                false
+            }
+        }
+
+        fn equality_hint_general(&self, other: &steel::SteelVal) -> bool {
+            match other {
+                SteelVal::StringV(s) => self.to_slice() == s.as_str(),
+                SteelVal::Custom(c) => Self::equality_hint(&self, c.read().as_ref()),
+
+                _ => false,
+            }
+        }
+
+        fn fmt(&self) -> Option<std::result::Result<String, std::fmt::Error>> {
+            Some(Ok(format!("#<Rope:\"{}\">", self.to_slice())))
+        }
+    }
+
+    impl SteelRopeSlice {
+        pub fn from_string(string: SteelString) -> Self {
+            Self {
+                text: crate::Rope::from_str(string.as_str()),
+                start: 0,
+                end: string.len(),
+                kind: RangeKind::Char,
+            }
+        }
+
+        pub fn new(rope: crate::Rope) -> Self {
+            let end = rope.len_chars();
+            Self {
+                text: rope,
+                start: 0,
+                end,
+                kind: RangeKind::Char,
+            }
+        }
+
+        fn to_slice(&self) -> crate::RopeSlice<'_> {
+            match self.kind {
+                RangeKind::Char => self.text.slice(self.start..self.end),
+                RangeKind::Byte => self.text.byte_slice(self.start..self.end),
+            }
+        }
+
+        pub fn insert_str(&self, char_idx: usize, text: SteelString) -> Result<Self, RopeyError> {
+            let slice = self.to_slice();
+            let mut rope = ropey::Rope::from(slice);
+            rope.try_insert(char_idx, &text)?;
+            Ok(Self::new(rope))
+        }
+
+        pub fn insert_char(&self, char_idx: usize, c: char) -> Result<Self, RopeyError> {
+            let slice = self.to_slice();
+            let mut rope = ropey::Rope::from(slice);
+            rope.try_insert_char(char_idx, c)?;
+            Ok(Self::new(rope))
+        }
+
+        pub fn try_line_to_char(&self, line: usize) -> Result<usize, RopeyError> {
+            self.to_slice().try_line_to_char(line).map_err(RopeyError)
+        }
+
+        pub fn try_line_to_byte(&self, line: usize) -> Result<usize, RopeyError> {
+            self.to_slice().try_line_to_byte(line).map_err(RopeyError)
+        }
+
+        pub fn try_char_to_line(&self, line: usize) -> Result<usize, RopeyError> {
+            self.to_slice().try_char_to_line(line).map_err(RopeyError)
+        }
+
+        pub fn try_byte_to_line(&self, line: usize) -> Result<usize, RopeyError> {
+            self.to_slice().try_byte_to_line(line).map_err(RopeyError)
+        }
+
+        pub fn line(mut self, cursor: usize) -> Result<Self, RopeyError> {
+            match self.kind {
+                RangeKind::Char => {
+                    let slice = self.text.get_slice(self.start..self.end).ok_or_else(|| {
+                        RopeyError(ropey::Error::CharIndexOutOfBounds(self.start, self.end))
+                    })?;
+
+                    // Move the start range, to wherever this lines up
+                    let index = slice.try_line_to_char(cursor)?;
+
+                    let line = slice.line(cursor);
+
+                    self.start += index;
+                    self.end = self.start + line.len_chars();
+
+                    Ok(self)
+                }
+                RangeKind::Byte => {
+                    let slice =
+                        self.text
+                            .get_byte_slice(self.start..self.end)
+                            .ok_or_else(|| {
+                                RopeyError(ropey::Error::ByteIndexOutOfBounds(self.start, self.end))
+                            })?;
+
+                    // Move the start range, to wherever this lines up
+                    let index = slice.try_line_to_byte(cursor)?;
+                    let line = slice.line(cursor);
+
+                    self.start += index;
+                    self.end = self.start + line.len_bytes();
+
+                    Ok(self)
+                }
+            }
+        }
+
+        pub fn slice(mut self, lower: usize, upper: usize) -> Result<Self, RopeyError> {
+            match self.kind {
+                RangeKind::Char => {
+                    self.end = self.start + upper;
+                    self.start += lower;
+
+                    // Just check that this is legal
+                    self.text.get_slice(self.start..self.end).ok_or_else(|| {
+                        RopeyError(ropey::Error::CharIndexOutOfBounds(self.start, self.end))
+                    })?;
+
+                    Ok(self)
+                }
+                RangeKind::Byte => {
+                    self.start = self.text.try_byte_to_char(self.start)? + lower;
+                    self.end = self.start + (upper - lower);
+
+                    self.text
+                        .get_byte_slice(self.start..self.end)
+                        .ok_or_else(|| {
+                            RopeyError(ropey::Error::ByteIndexOutOfBounds(self.start, self.end))
+                        })?;
+
+                    self.kind = RangeKind::Char;
+                    Ok(self)
+                }
+            }
+        }
+
+        pub fn byte_slice(mut self, lower: usize, upper: usize) -> Result<Self, RopeyError> {
+            match self.kind {
+                RangeKind::Char => {
+                    self.start = self.text.try_char_to_byte(self.start)? + lower;
+                    self.end = self.start + (upper - lower);
+                    self.kind = RangeKind::Byte;
+
+                    // Just check that this is legal
+                    self.text.get_slice(self.start..self.end).ok_or_else(|| {
+                        RopeyError(ropey::Error::CharIndexOutOfBounds(self.start, self.end))
+                    })?;
+
+                    Ok(self)
+                }
+                RangeKind::Byte => {
+                    self.start += lower;
+                    self.end = self.start + (upper - lower);
+
+                    self.text
+                        .get_byte_slice(self.start..self.end)
+                        .ok_or_else(|| {
+                            RopeyError(ropey::Error::ByteIndexOutOfBounds(self.start, self.end))
+                        })?;
+
+                    Ok(self)
+                }
+            }
+        }
+
+        pub fn char_to_byte(&self, pos: usize) -> Result<usize, RopeyError> {
+            Ok(self.to_slice().try_char_to_byte(pos)?)
+        }
+
+        pub fn byte_to_char(&self, pos: usize) -> Result<usize, RopeyError> {
+            Ok(self.to_slice().try_byte_to_char(pos)?)
+        }
+
+        pub fn to_string(&self) -> String {
+            self.to_slice().to_string()
+        }
+
+        pub fn len_chars(&self) -> usize {
+            self.to_slice().len_chars()
+        }
+
+        pub fn len_bytes(&self) -> usize {
+            self.to_slice().len_bytes()
+        }
+
+        pub fn get_char(&self, index: usize) -> Option<char> {
+            self.to_slice().get_char(index)
+        }
+
+        pub fn len_lines(&self) -> usize {
+            self.to_slice().len_lines()
+        }
+
+        pub fn trim_start(mut self) -> Self {
+            let slice = self.to_slice();
+
+            for (idx, c) in slice.chars().enumerate() {
+                if !c.is_whitespace() {
+                    match self.kind {
+                        RangeKind::Char => {
+                            self.start += idx;
+                        }
+                        RangeKind::Byte => {
+                            self.start += slice.char_to_byte(idx);
+                        }
+                    }
+
+                    break;
+                }
+            }
+
+            self
+        }
+
+        pub fn starts_with(&self, pat: SteelString) -> bool {
+            self.to_slice().starts_with(pat.as_str())
+        }
+
+        pub fn ends_with(&self, pat: SteelString) -> bool {
+            self.to_slice().ends_with(pat.as_str())
+        }
+    }
+
+    pub fn rope_module() -> BuiltInModule {
+        let mut module = BuiltInModule::new("helix/core/text");
+
+        macro_rules! register_value {
+            ($name:expr, $func:expr, $doc:expr) => {
+                module.register_fn($name, $func);
+                module.register_doc($name, MarkdownDoc(Cow::Borrowed($doc)));
+            };
+        }
+
+        register_value!(
+            "Rope?",
+            |value: SteelVal| SteelRopeSlice::as_ref(&value).is_ok(),
+            "Check if the given value is a rope"
+        );
+
+        register_value!(
+            "string->rope",
+            SteelRopeSlice::from_string,
+            r#"Converts a string into a rope.
+
+```scheme
+(string->rope value) -> Rope?
+```
+
+* value : string?
+            "#
+        );
+
+        register_value!(
+            "rope->slice",
+            SteelRopeSlice::slice,
+            r#"Take a slice from using character indices from the rope.
+Returns a new rope value.
+
+```scheme
+(rope->slice rope start end) -> Rope?
+```
+
+* rope : Rope?
+* start: (and positive? int?)
+* end: (and positive? int?)
+"#
+        );
+
+        register_value!(
+            "rope-char->byte",
+            SteelRopeSlice::char_to_byte,
+            r#"Convert the character offset into a byte offset for a given rope"#
+        );
+
+        register_value!(
+            "rope-char->byte",
+            SteelRopeSlice::byte_to_char,
+            r#"Convert the byte offset into a character offset for a given rope"#
+        );
+
+        register_value!(
+            "rope-line->char",
+            SteelRopeSlice::try_line_to_char,
+            r#"Convert the given line index to a character offset for a given rope
+
+```scheme
+(rope-line->char rope line-offset) -> int?
+```
+
+* rope : Rope?
+* line-offset: int?
+            "#
+        );
+
+        register_value!(
+            "rope-line->byte",
+            SteelRopeSlice::try_line_to_byte,
+            r#"Convert the given line index to a byte offset for a given rope
+
+```scheme
+(rope-line->byte rope line-offset) -> int?
+```
+
+* rope : Rope?
+* line-offset: int?
+            "#
+        );
+
+        register_value!(
+            "rope-char->line",
+            SteelRopeSlice::try_char_to_line,
+            r#"Convert the given character offset to a line offset for a given rope
+
+```scheme
+(rope-char->line rope char-index) -> int?
+```
+
+* rope : Rope?
+* char-index : int?
+
+            "#
+        );
+
+        register_value!(
+            "rope-byte->line",
+            SteelRopeSlice::try_byte_to_line,
+            r#"Convert the given byte offset to a line offset for a given rope
+
+```scheme
+(rope-byte->line rope byte-index) -> int?
+```
+
+* rope : Rope?
+* byte-index : int?
+
+            "#
+        );
+
+        register_value!(
+            "rope->byte-slice",
+            SteelRopeSlice::byte_slice,
+            r#"Take a slice of this rope using byte offsets
+
+```scheme
+(rope->byte-slice rope start end) -> Rope?
+```
+
+* rope: Rope?
+* start: (and positive? int?)
+* end: (and positive? int?)
+"#
+        );
+
+        register_value!(
+            "rope->line",
+            SteelRopeSlice::line,
+            r#"Get the line at the given line index. Returns a rope.
+
+```scheme
+(rope->line rope index) -> Rope?
+
+```
+
+* rope : Rope?
+* index : (and positive? int?)
+"#
+        );
+
+        register_value!(
+            "rope->string",
+            SteelRopeSlice::to_string,
+            "Convert the given rope to a string"
+        );
+
+        register_value!(
+            "rope-len-chars",
+            SteelRopeSlice::len_chars,
+            "Get the length of the rope in characters"
+        );
+        register_value!(
+            "rope-len-bytes",
+            SteelRopeSlice::len_chars,
+            "Get the length of the rope in bytes"
+        );
+
+        register_value!(
+            "rope-char-ref",
+            SteelRopeSlice::get_char,
+            "Get the character at the given index"
+        );
+
+        register_value!(
+            "rope-len-lines",
+            SteelRopeSlice::len_lines,
+            "Get the number of lines in the rope"
+        );
+
+        register_value!(
+            "rope-starts-with?",
+            SteelRopeSlice::starts_with,
+            "Check if the rope starts with a given pattern"
+        );
+
+        register_value!(
+            "rope-ends-with?",
+            SteelRopeSlice::ends_with,
+            "Check if the rope ends with a given pattern"
+        );
+
+        register_value!(
+            "rope-trim-start",
+            SteelRopeSlice::trim_start,
+            "Remove the leading whitespace from the given rope"
+        );
+
+        register_value!(
+            "rope-insert-string",
+            SteelRopeSlice::insert_str,
+            "Insert a string at the given index into the rope"
+        );
+
+        register_value!(
+            "rope-insert-char",
+            SteelRopeSlice::insert_char,
+            "Insert a character at the given index"
+        );
+
+        module
+    }
+}
diff --git a/helix-core/src/lib.rs b/helix-core/src/lib.rs
index 09865ca40..f35e8a03b 100644
--- a/helix-core/src/lib.rs
+++ b/helix-core/src/lib.rs
@@ -34,6 +34,8 @@
 pub mod uri;
 pub mod wrap;
 
+pub mod extensions;
+
 pub mod unicode {
     pub use unicode_general_category as category;
     pub use unicode_segmentation as segmentation;
diff --git a/helix-core/src/selection.rs b/helix-core/src/selection.rs
index 5bde08e31..e66a87008 100644
--- a/helix-core/src/selection.rs
+++ b/helix-core/src/selection.rs
@@ -16,6 +16,7 @@
 use helix_stdx::rope::{self, RopeSliceExt};
 use smallvec::{smallvec, SmallVec};
 use std::{borrow::Cow, iter, slice};
+use steel::rvals::Custom;
 
 /// A single selection range.
 ///
@@ -62,6 +63,8 @@ pub struct Range {
     pub old_visual_position: Option<(u32, u32)>,
 }
 
+impl Custom for Range {}
+
 impl Range {
     pub fn new(anchor: usize, head: usize) -> Self {
         Self {
diff --git a/helix-core/src/syntax.rs b/helix-core/src/syntax.rs
index 8fa185c6f..43ffd30be 100644
--- a/helix-core/src/syntax.rs
+++ b/helix-core/src/syntax.rs
@@ -39,6 +39,17 @@ pub struct LanguageData {
     textobject_query: OnceCell<Option<TextObjectQuery>>,
 }
 
+impl Clone for LanguageData {
+    fn clone(&self) -> Self {
+        Self {
+            config: self.config.clone(),
+            syntax: OnceCell::new(),
+            indent_query: OnceCell::new(),
+            textobject_query: OnceCell::new(),
+        }
+    }
+}
+
 impl LanguageData {
     fn new(config: LanguageConfiguration) -> Self {
         Self {
@@ -194,14 +205,14 @@ pub fn read_query(lang: &str, query_filename: &str) -> String {
     })
 }
 
-#[derive(Debug, Default)]
+#[derive(Debug, Default, Clone)]
 pub struct Loader {
     languages: Vec<LanguageData>,
     languages_by_extension: HashMap<String, Language>,
     languages_by_shebang: HashMap<String, Language>,
     languages_glob_matcher: FileTypeGlobMatcher,
     language_server_configs: HashMap<String, LanguageServerConfiguration>,
-    scopes: ArcSwap<Vec<String>>,
+    scopes: Arc<ArcSwap<Vec<String>>>,
 }
 
 pub type LoaderError = globset::Error;
@@ -240,7 +251,7 @@ pub fn new(config: Configuration) -> Result<Self, LoaderError> {
             languages_by_shebang,
             languages_glob_matcher: FileTypeGlobMatcher::new(file_type_globs)?,
             language_server_configs: config.language_server,
-            scopes: ArcSwap::from_pointee(Vec::new()),
+            scopes: Arc::new(ArcSwap::from_pointee(Vec::new())),
         })
     }
 
@@ -326,6 +337,20 @@ pub fn language_for_shebang(&self, text: RopeSlice) -> Option<Language> {
         self.language_for_shebang_marker(marker)
     }
 
+    pub fn language_configs_mut(
+        &mut self,
+    ) -> impl Iterator<Item = &mut Arc<LanguageConfiguration>> {
+        self.languages
+            .iter_mut()
+            .map(|language| &mut language.config)
+    }
+
+    pub fn language_server_configs_mut(
+        &mut self,
+    ) -> &mut HashMap<String, LanguageServerConfiguration> {
+        &mut self.language_server_configs
+    }
+
     fn language_for_shebang_marker(&self, marker: RopeSlice) -> Option<Language> {
         let shebang: Cow<str> = marker.into();
         self.languages_by_shebang.get(shebang.as_ref()).copied()
@@ -375,7 +400,7 @@ fn get_config(&self, lang: Language) -> Option<&SyntaxConfig> {
     }
 }
 
-#[derive(Debug)]
+#[derive(Debug, Clone)]
 struct FileTypeGlob {
     glob: globset::Glob,
     language: Language,
@@ -387,7 +412,7 @@ pub fn new(glob: globset::Glob, language: Language) -> Self {
     }
 }
 
-#[derive(Debug)]
+#[derive(Debug, Clone)]
 struct FileTypeGlobMatcher {
     matcher: globset::GlobSet,
     file_types: Vec<FileTypeGlob>,
diff --git a/helix-core/src/syntax/config.rs b/helix-core/src/syntax/config.rs
index ddff26f17..7f0c5e038 100644
--- a/helix-core/src/syntax/config.rs
+++ b/helix-core/src/syntax/config.rs
@@ -110,7 +110,7 @@ pub fn language(&self) -> Language {
     }
 }
 
-#[derive(Debug, PartialEq, Eq, Hash)]
+#[derive(Debug, PartialEq, Eq, Hash, Clone)]
 pub enum FileType {
     /// The extension of the file, either the `Path::extension` or the full
     /// filename if the file does not have an extension.
@@ -314,7 +314,7 @@ enum LanguageServerFeatureConfiguration {
     Simple(String),
 }
 
-#[derive(Debug, Default)]
+#[derive(Debug, Default, Clone)]
 pub struct LanguageServerFeatures {
     pub name: String,
     pub only: HashSet<LanguageServerFeature>,
@@ -393,7 +393,7 @@ fn deserialize_required_root_patterns<'de, D>(deserializer: D) -> Result<Option<
     builder.build().map(Some).map_err(serde::de::Error::custom)
 }
 
-#[derive(Debug, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
 #[serde(rename_all = "kebab-case")]
 pub struct LanguageServerConfiguration {
     pub command: String,
@@ -478,7 +478,7 @@ pub struct DebuggerQuirks {
     pub absolute_paths: bool,
 }
 
-#[derive(Debug, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
 #[serde(rename_all = "kebab-case")]
 pub struct IndentationConfiguration {
     #[serde(deserialize_with = "deserialize_tab_width")]
@@ -622,6 +622,37 @@ pub fn deserialize_auto_pairs<'de, D>(deserializer: D) -> Result<Option<AutoPair
     Ok(Option::<AutoPairConfig>::deserialize(deserializer)?.and_then(AutoPairConfig::into))
 }
 
-fn default_timeout() -> u64 {
+pub fn default_timeout() -> u64 {
     20
 }
+
+impl Clone for LanguageConfiguration {
+    fn clone(&self) -> Self {
+        LanguageConfiguration {
+            language: self.language.clone(),
+            language_id: self.language_id.clone(),
+            language_server_language_id: self.language_server_language_id.clone(),
+            scope: self.scope.clone(),
+            file_types: self.file_types.clone(),
+            shebangs: self.shebangs.clone(),
+            roots: self.roots.clone(),
+            comment_tokens: self.comment_tokens.clone(),
+            block_comment_tokens: self.block_comment_tokens.clone(),
+            text_width: self.text_width.clone(),
+            soft_wrap: self.soft_wrap.clone(),
+            auto_format: self.auto_format.clone(),
+            formatter: self.formatter.clone(),
+            diagnostic_severity: self.diagnostic_severity.clone(),
+            grammar: self.grammar.clone(),
+            injection_regex: self.injection_regex.clone(),
+            language_servers: self.language_servers.clone(),
+            indent: self.indent.clone(),
+            debugger: self.debugger.clone(),
+            auto_pairs: self.auto_pairs.clone(),
+            rulers: self.rulers.clone(),
+            workspace_lsp_roots: self.workspace_lsp_roots.clone(),
+            persistent_diagnostic_sources: self.persistent_diagnostic_sources.clone(),
+            path_completion: self.path_completion,
+        }
+    }
+}
diff --git a/helix-event/Cargo.toml b/helix-event/Cargo.toml
index 41f3b4836..6d86d165b 100644
--- a/helix-event/Cargo.toml
+++ b/helix-event/Cargo.toml
@@ -16,10 +16,10 @@ foldhash.workspace = true
 hashbrown = "0.15"
 tokio = { version = "1", features = ["rt", "rt-multi-thread", "time", "sync", "parking_lot", "macros"] }
 # the event registry is essentially read only but must be an rwlock so we can
-# setup new events on initialization, hardware-lock-elision hugely benefits this case
-# as it essentially makes the lock entirely free as long as there is no writes 
-parking_lot = { workspace = true, features = ["hardware-lock-elision"] }
+# setup new events on intalization, hardware-lock-elision hugnly benefits this case
+# as is essentially makes the lock entirely free as long as there is no writes
 once_cell = "1.21"
+parking_lot = { workspace = true, features = ["hardware-lock-elision"] }
 
 anyhow = "1"
 log = "0.4"
diff --git a/helix-lsp/src/client.rs b/helix-lsp/src/client.rs
index afb3b3a56..d10547a1b 100644
--- a/helix-lsp/src/client.rs
+++ b/helix-lsp/src/client.rs
@@ -1551,4 +1551,63 @@ pub fn did_change_watched_files(&self, changes: Vec<lsp::FileEvent>) {
             changes,
         })
     }
+
+    // Everything below is explicitly extensions used for handling non standard lsp commands
+    pub fn non_standard_extension(
+        &self,
+        method_name: String,
+        params: Option<Value>,
+    ) -> Option<impl Future<Output = Result<Value>>> {
+        Some(self.call_non_standard(DynamicLspRequest {
+            method_name,
+            params,
+        }))
+    }
+
+    fn call_non_standard(&self, request: DynamicLspRequest) -> impl Future<Output = Result<Value>> {
+        self.call_non_standard_with_timeout(request, self.req_timeout)
+    }
+
+    fn call_non_standard_with_timeout(
+        &self,
+        request: DynamicLspRequest,
+        timeout_secs: u64,
+    ) -> impl Future<Output = Result<Value>> {
+        let server_tx = self.server_tx.clone();
+        let id = self.next_request_id();
+
+        let params = serde_json::to_value(&request.params);
+        async move {
+            use std::time::Duration;
+            use tokio::time::timeout;
+
+            let request = jsonrpc::MethodCall {
+                jsonrpc: Some(jsonrpc::Version::V2),
+                id: id.clone(),
+                method: (&request.method_name).to_string(),
+                params: Self::value_into_params(params?),
+            };
+
+            let (tx, mut rx) = channel::<Result<Value>>(1);
+
+            server_tx
+                .send(Payload::Request {
+                    chan: tx,
+                    value: request,
+                })
+                .map_err(|e| Error::Other(e.into()))?;
+
+            // TODO: delay other calls until initialize success
+            timeout(Duration::from_secs(timeout_secs), rx.recv())
+                .await
+                .map_err(|_| Error::Timeout(id))? // return Timeout
+                .ok_or(Error::StreamClosed)?
+        }
+    }
+}
+
+#[derive(serde::Serialize, Deserialize)]
+pub struct DynamicLspRequest {
+    method_name: String,
+    params: Option<Value>,
 }
diff --git a/helix-lsp/src/lib.rs b/helix-lsp/src/lib.rs
index 567e8a702..c8a1691ab 100644
--- a/helix-lsp/src/lib.rs
+++ b/helix-lsp/src/lib.rs
@@ -512,6 +512,8 @@ pub enum Notification {
     ShowMessage(lsp::ShowMessageParams),
     LogMessage(lsp::LogMessageParams),
     ProgressMessage(lsp::ProgressParams),
+    // Other kind specifically for extensions
+    Other(String, jsonrpc::Params),
 }
 
 impl Notification {
@@ -538,9 +540,7 @@ pub fn parse(method: &str, params: jsonrpc::Params) -> Result<Notification> {
                 let params: lsp::ProgressParams = params.parse()?;
                 Self::ProgressMessage(params)
             }
-            _ => {
-                return Err(Error::Unhandled);
-            }
+            _ => Self::Other(method.to_owned(), params),
         };
 
         Ok(notification)
diff --git a/helix-term/Cargo.toml b/helix-term/Cargo.toml
index cf3c4b475..629f8a457 100644
--- a/helix-term/Cargo.toml
+++ b/helix-term/Cargo.toml
@@ -31,10 +31,11 @@ assets = [
 ]
 
 [features]
-default = ["git"]
+default = ["git", "steel"] # Remove steel if you don't want it
 unicode-lines = ["helix-core/unicode-lines", "helix-view/unicode-lines"]
 integration = ["helix-event/integration_test"]
 git = ["helix-vcs/git"]
+steel = ["dep:steel-core", "helix-core/steel", "helix-view/steel", "tui/steel"]
 
 [[bin]]
 name = "hx"
@@ -91,6 +92,13 @@ serde = { version = "1.0", features = ["derive"] }
 grep-regex = "0.1.13"
 grep-searcher = "0.1.14"
 
+# plugin support
+steel-core = { workspace = true, optional = true }
+steel-doc = { git = "https://github.com/mattwparas/steel.git", version = "0.7.0" }
+# steel-doc = { path = "/home/matt/code/scratch/steel/crates/steel-doc", version = "0.6.0" }
+
+globset = "0.4.16"
+
 [target.'cfg(not(windows))'.dependencies]  # https://github.com/vorner/signal-hook/issues/100
 signal-hook-tokio = { version = "0.3", features = ["futures-v0_3"] }
 libc = "0.2.174"
diff --git a/helix-term/src/application.rs b/helix-term/src/application.rs
index e725aa8ed..9755c6df7 100644
--- a/helix-term/src/application.rs
+++ b/helix-term/src/application.rs
@@ -21,6 +21,7 @@
 
 use crate::{
     args::Args,
+    commands::ScriptingEngine,
     compositor::{Compositor, Event},
     config::Config,
     handlers,
@@ -234,7 +235,7 @@ pub fn new(args: Args, config: Config, lang_loader: syntax::Loader) -> Result<Se
         ])
         .context("build signal handler")?;
 
-        let app = Self {
+        let mut app = Self {
             compositor,
             terminal,
             editor,
@@ -244,6 +245,26 @@ pub fn new(args: Args, config: Config, lang_loader: syntax::Loader) -> Result<Se
             lsp_progress: LspProgressMap::new(),
         };
 
+        {
+            // TODO: Revisit this!
+            let syn_loader = app.editor.syn_loader.clone();
+
+            let mut cx = crate::commands::Context {
+                register: None,
+                count: std::num::NonZeroUsize::new(1),
+                editor: &mut app.editor,
+                callback: Vec::new(),
+                on_next_key_callback: None,
+                jobs: &mut app.jobs,
+            };
+
+            crate::commands::ScriptingEngine::run_initialization_script(
+                &mut cx,
+                app.config.clone(),
+                syn_loader,
+            );
+        }
+
         Ok(app)
     }
 
@@ -334,6 +355,10 @@ pub async fn event_loop_until_idle<S>(&mut self, input_stream: &mut S) -> bool
                     self.jobs.handle_callback(&mut self.editor, &mut self.compositor, callback);
                     self.render().await;
                 }
+                Some(callback) = self.jobs.local_futures.next() => {
+                    self.jobs.handle_local_callback(&mut self.editor, &mut self.compositor, callback);
+                    self.render().await;
+                }
                 event = self.editor.wait_event() => {
                     let _idle_handled = self.handle_editor_event(event).await;
 
@@ -372,6 +397,7 @@ pub fn handle_config_events(&mut self, config_event: ConfigEvent) {
                 };
                 self.config.store(Arc::new(app_config));
             }
+            ConfigEvent::Change => {}
         }
 
         // Update all the relevant members in the editor after updating
@@ -866,6 +892,19 @@ macro_rules! language_server {
                         // Remove the language server from the registry.
                         self.editor.language_servers.remove_by_id(server_id);
                     }
+                    Notification::Other(event_name, params) => {
+                        let server_id = server_id;
+
+                        let mut cx = crate::compositor::Context {
+                            editor: &mut self.editor,
+                            scroll: None,
+                            jobs: &mut self.jobs,
+                        };
+
+                        ScriptingEngine::handle_lsp_notification(
+                            &mut cx, server_id, event_name, params,
+                        );
+                    }
                 }
             }
             Call::MethodCall(helix_lsp::jsonrpc::MethodCall {
diff --git a/helix-term/src/commands.rs b/helix-term/src/commands.rs
index d8658facf..5410af2a9 100644
--- a/helix-term/src/commands.rs
+++ b/helix-term/src/commands.rs
@@ -1,4 +1,5 @@
 pub(crate) mod dap;
+pub(crate) mod engine;
 pub(crate) mod lsp;
 pub(crate) mod typed;
 
@@ -11,6 +12,12 @@
 };
 use helix_vcs::{FileChange, Hunk};
 pub use lsp::*;
+
+pub use engine::ScriptingEngine;
+
+#[cfg(feature = "steel")]
+pub use engine::steel::{helix_module_file, steel_init_file};
+
 use tui::{
     text::{Span, Spans},
     widgets::Cell,
@@ -20,7 +27,8 @@
 use helix_core::{
     char_idx_at_visual_offset,
     chars::char_is_word,
-    command_line, comment,
+    command_line::{self},
+    comment,
     doc_formatter::TextFormat,
     encoding, find_workspace,
     graphemes::{self, next_grapheme_boundary},
@@ -245,6 +253,7 @@ impl MappableCommand {
     pub fn execute(&self, cx: &mut Context) {
         match &self {
             Self::Typable { name, args, doc: _ } => {
+                // TODO: Swap the order to allow overriding the existing commands?
                 if let Some(command) = typed::TYPABLE_COMMAND_MAP.get(name.as_str()) {
                     let mut cx = compositor::Context {
                         editor: cx.editor,
@@ -257,7 +266,11 @@ pub fn execute(&self, cx: &mut Context) {
                         cx.editor.set_error(format!("{}", e));
                     }
                 } else {
-                    cx.editor.set_error(format!("no such command: '{name}'"));
+                    // TODO: Update this
+                    let args = args.split_whitespace().map(Cow::from).collect();
+                    if !ScriptingEngine::call_function_by_name(cx, name, args) {
+                        cx.editor.set_error(format!("no such command: '{name}'"));
+                    }
                 }
             }
             Self::Static { fun, .. } => (fun)(cx),
@@ -297,6 +310,14 @@ pub fn doc(&self) -> &str {
         }
     }
 
+    pub(crate) fn doc_mut(&mut self) -> Option<&mut String> {
+        if let Self::Typable { doc, .. } = self {
+            Some(doc)
+        } else {
+            None
+        }
+    }
+
     #[rustfmt::skip]
     static_commands!(
         no_op, "Do nothing",
@@ -642,17 +663,17 @@ fn from_str(s: &str) -> Result<Self, Self::Err> {
             ensure!(!name.is_empty(), "Expected typable command name");
             typed::TYPABLE_COMMAND_MAP
                 .get(name)
-                .map(|cmd| {
-                    let doc = if args.is_empty() {
-                        cmd.doc.to_string()
-                    } else {
-                        format!(":{} {:?}", cmd.name, args)
-                    };
-                    MappableCommand::Typable {
-                        name: cmd.name.to_owned(),
-                        doc,
-                        args: args.to_string(),
-                    }
+                .map(|cmd| MappableCommand::Typable {
+                    name: cmd.name.to_owned(),
+                    doc: format!(":{} {:?}", cmd.name, args),
+                    args: args.to_owned(),
+                })
+                .or_else(|| {
+                    Some(MappableCommand::Typable {
+                        name: name.to_owned(),
+                        args: args.to_owned(),
+                        doc: "Undocumented plugin command".to_string(),
+                    })
                 })
                 .ok_or_else(|| anyhow!("No TypableCommand named '{}'", s))
         } else if let Some(suffix) = s.strip_prefix('@') {
@@ -3140,9 +3161,11 @@ fn file_explorer_in_current_directory(cx: &mut Context) {
 fn buffer_picker(cx: &mut Context) {
     let current = view!(cx.editor).doc;
 
+    #[allow(unused)]
     struct BufferMeta {
         id: DocumentId,
         path: Option<PathBuf>,
+        name: Option<String>,
         is_modified: bool,
         is_current: bool,
         focused_at: std::time::Instant,
@@ -3151,6 +3174,7 @@ struct BufferMeta {
     let new_meta = |doc: &Document| BufferMeta {
         id: doc.id(),
         path: doc.path().cloned(),
+        name: doc.name.clone(),
         is_modified: doc.is_modified(),
         is_current: doc.id() == current,
         focused_at: doc.focused_at,
@@ -4202,6 +4226,18 @@ pub fn insert_char(cx: &mut Context, c: char) {
         helix_event::dispatch(PostInsertChar { c, cx });
     }
 
+    pub fn insert_string(cx: &mut Context, string: String) {
+        let (view, doc) = current!(cx.editor);
+
+        let indent = Tendril::from(string);
+        let transaction = Transaction::insert(
+            doc.text(),
+            &doc.selection(view.id).clone().cursors(doc.text().slice(..)),
+            indent,
+        );
+        doc.apply(&transaction, view.id);
+    }
+
     pub fn smart_tab(cx: &mut Context) {
         let (view, doc) = current_ref!(cx.editor);
         let view_id = view.id;
diff --git a/helix-term/src/commands/engine.rs b/helix-term/src/commands/engine.rs
new file mode 100644
index 000000000..2bfb767b3
--- /dev/null
+++ b/helix-term/src/commands/engine.rs
@@ -0,0 +1,255 @@
+use arc_swap::{ArcSwap, ArcSwapAny};
+use helix_core::syntax;
+use helix_lsp::{jsonrpc, LanguageServerId};
+use helix_view::{document::Mode, input::KeyEvent};
+
+use std::{borrow::Cow, sync::Arc};
+
+use crate::{
+    compositor,
+    config::Config,
+    keymap::KeymapResult,
+    ui::{self, PromptEvent},
+};
+
+use super::{Context, MappableCommand, TYPABLE_COMMAND_LIST};
+
+#[cfg(feature = "steel")]
+mod components;
+
+#[cfg(feature = "steel")]
+pub mod steel;
+
+pub enum PluginSystemKind {
+    None,
+    #[cfg(feature = "steel")]
+    Steel,
+}
+
+pub enum PluginSystemTypes {
+    None(NoEngine),
+    #[cfg(feature = "steel")]
+    Steel(steel::SteelScriptingEngine),
+}
+
+// The order in which the plugins will be evaluated against - if we wanted to include, lets say `rhai`,
+// we would have to order the precedence for searching for exported commands, or somehow merge them?
+const PLUGIN_PRECEDENCE: &[PluginSystemTypes] = &[
+    #[cfg(feature = "steel")]
+    PluginSystemTypes::Steel(steel::SteelScriptingEngine),
+    PluginSystemTypes::None(NoEngine),
+];
+
+pub struct NoEngine;
+
+// This will be the boundary layer between the editor and the engine.
+pub struct ScriptingEngine;
+
+// Macro to automatically dispatch to hopefully get some inlining
+macro_rules! manual_dispatch {
+    ($kind:expr, $raw:tt ($($args:expr),* $(,)?) ) => {
+        match $kind {
+            PluginSystemTypes::None(n) => n.$raw($($args),*),
+            #[cfg(feature = "steel")]
+            PluginSystemTypes::Steel(s) => s.$raw($($args),*),
+        }
+    };
+}
+
+impl ScriptingEngine {
+    pub fn initialize() {
+        for kind in PLUGIN_PRECEDENCE {
+            manual_dispatch!(kind, initialize())
+        }
+    }
+
+    pub fn run_initialization_script(
+        cx: &mut Context,
+        configuration: Arc<ArcSwapAny<Arc<Config>>>,
+        language_configuration: Arc<ArcSwap<syntax::Loader>>,
+    ) {
+        for kind in PLUGIN_PRECEDENCE {
+            manual_dispatch!(
+                kind,
+                run_initialization_script(
+                    cx,
+                    configuration.clone(),
+                    language_configuration.clone()
+                )
+            )
+        }
+    }
+
+    pub fn handle_keymap_event(
+        editor: &mut ui::EditorView,
+        mode: Mode,
+        cxt: &mut Context,
+        event: KeyEvent,
+    ) -> Option<KeymapResult> {
+        for kind in PLUGIN_PRECEDENCE {
+            let res = manual_dispatch!(kind, handle_keymap_event(editor, mode, cxt, event));
+
+            if res.is_some() {
+                return res;
+            }
+        }
+
+        None
+    }
+
+    pub fn call_function_by_name(cx: &mut Context, name: &str, args: Vec<Cow<str>>) -> bool {
+        for kind in PLUGIN_PRECEDENCE {
+            if manual_dispatch!(kind, call_function_by_name(cx, name, &args)) {
+                return true;
+            }
+        }
+
+        false
+    }
+
+    pub fn call_typed_command<'a>(
+        cx: &mut compositor::Context,
+        command: &'a str,
+        parts: &'a [&'a str],
+        event: PromptEvent,
+    ) -> bool {
+        for kind in PLUGIN_PRECEDENCE {
+            if manual_dispatch!(kind, call_typed_command(cx, command, parts, event)) {
+                return true;
+            }
+        }
+
+        false
+    }
+
+    pub fn get_doc_for_identifier(ident: &str) -> Option<String> {
+        for kind in PLUGIN_PRECEDENCE {
+            let doc = manual_dispatch!(kind, get_doc_for_identifier(ident));
+
+            if doc.is_some() {
+                return doc;
+            }
+        }
+
+        None
+    }
+
+    pub fn available_commands<'a>() -> Vec<Cow<'a, str>> {
+        PLUGIN_PRECEDENCE
+            .iter()
+            .flat_map(|kind| manual_dispatch!(kind, available_commands()))
+            .collect()
+    }
+
+    pub fn handle_lsp_notification(
+        cx: &mut compositor::Context,
+        server_id: LanguageServerId,
+        event_name: String,
+        params: jsonrpc::Params,
+    ) {
+        for kind in PLUGIN_PRECEDENCE {
+            if manual_dispatch!(
+                kind,
+                // TODO: Get rid of these clones!
+                handle_lsp_notification(cx, server_id, event_name.clone(), params.clone())
+            ) {
+                return;
+            }
+        }
+    }
+
+    pub fn generate_sources() {
+        for kind in PLUGIN_PRECEDENCE {
+            manual_dispatch!(kind, generate_sources())
+        }
+    }
+}
+
+impl PluginSystem for NoEngine {
+    fn engine_name(&self) -> PluginSystemKind {
+        PluginSystemKind::None
+    }
+}
+
+/// These methods are the main entry point for interaction with the rest of
+/// the editor system.
+pub trait PluginSystem {
+    /// If any initialization needs to happen prior to the initialization script being run,
+    /// this is done here. This is run before the context is available.
+    fn initialize(&self) {}
+
+    #[allow(unused)]
+    fn engine_name(&self) -> PluginSystemKind;
+
+    /// Post initialization, once the context is available. This means you should be able to
+    /// run anything here that could modify the context before the main editor is available.
+    fn run_initialization_script(
+        &self,
+        _cx: &mut Context,
+        _configuration: Arc<ArcSwapAny<Arc<Config>>>,
+        _language_configuration: Arc<ArcSwap<syntax::Loader>>,
+    ) {
+    }
+
+    /// Allow the engine to directly handle a keymap event. This is some of the tightest integration
+    /// with the engine, directly intercepting any keymap events. By default, this just delegates to the
+    /// editors default keybindings.
+    #[inline(always)]
+    fn handle_keymap_event(
+        &self,
+        _editor: &mut ui::EditorView,
+        _mode: Mode,
+        _cxt: &mut Context,
+        _event: KeyEvent,
+    ) -> Option<KeymapResult> {
+        None
+    }
+
+    /// This attempts to call a function in the engine with the name `name` using the args `args`. The context
+    /// is available here. Returns a bool indicating whether the function exists or not.
+    #[inline(always)]
+    fn call_function_by_name(&self, _cx: &mut Context, _name: &str, _args: &[Cow<str>]) -> bool {
+        false
+    }
+
+    /// This is explicitly for calling a function via the typed command interface, e.g. `:vsplit`. The context here
+    /// that is available is more limited than the context available in `call_function_if_global_exists`. This also
+    /// gives the ability to handle in progress commands with `PromptEvent`.
+    #[inline(always)]
+    fn call_typed_command<'a>(
+        &self,
+        _cx: &mut compositor::Context,
+        _input: &'a str,
+        _parts: &'a [&'a str],
+        _event: PromptEvent,
+    ) -> bool {
+        false
+    }
+
+    /// Call into the scripting engine to handle an unhandled LSP notification, sent from the server
+    /// to the client.
+    #[inline(always)]
+    fn handle_lsp_notification(
+        &self,
+        _cx: &mut compositor::Context,
+        _server_id: LanguageServerId,
+        _event_name: String,
+        _params: jsonrpc::Params,
+    ) -> bool {
+        false
+    }
+
+    /// Given an identifier, extract the documentation from the engine.
+    #[inline(always)]
+    fn get_doc_for_identifier(&self, _ident: &str) -> Option<String> {
+        None
+    }
+
+    /// Fuzzy match the input against the fuzzy matcher, used for handling completions on typed commands
+    #[inline(always)]
+    fn available_commands<'a>(&self) -> Vec<Cow<'a, str>> {
+        Vec::new()
+    }
+
+    fn generate_sources(&self) {}
+}
diff --git a/helix-term/src/commands/engine/components.rs b/helix-term/src/commands/engine/components.rs
new file mode 100644
index 000000000..18161b2f1
--- /dev/null
+++ b/helix-term/src/commands/engine/components.rs
@@ -0,0 +1,2067 @@
+use std::{collections::HashMap, sync::Arc};
+
+use helix_core::Position;
+use helix_view::{
+    graphics::{Color, CursorKind, Rect, UnderlineStyle},
+    input::{Event, KeyEvent, MouseButton, MouseEvent},
+    keyboard::{KeyCode, KeyModifiers},
+    theme::{Modifier, Style},
+    Editor,
+};
+use steel::{
+    rvals::{
+        as_underlying_type, AsRefSteelVal, AsRefSteelValFromRef, Custom, FromSteelVal,
+        IntoSteelVal, SteelString,
+    },
+    steel_vm::{builtin::BuiltInModule, engine::Engine, register_fn::RegisterFn},
+    RootedSteelVal, SteelVal,
+};
+use tokio::sync::Mutex;
+use tui::{
+    buffer::Buffer,
+    text::Text,
+    widgets::{self, Block, BorderType, Borders, ListItem, Widget},
+};
+
+use crate::{
+    commands::{engine::steel::BoxDynComponent, Context},
+    compositor::{self, Component},
+    ui::overlay::overlaid,
+};
+
+use super::steel::{
+    enter_engine, format_docstring, present_error_inside_engine_context, WrappedDynComponent,
+};
+
+#[derive(Clone)]
+struct AsyncReader {
+    // Take that, and write it back to a terminal session that is
+    // getting rendered.
+    channel: Arc<Mutex<tokio::sync::mpsc::UnboundedReceiver<String>>>,
+}
+
+impl AsyncReader {
+    async fn read_line(self) -> Option<String> {
+        let mut buf = String::new();
+
+        let mut guard = self.channel.lock().await;
+
+        while let Ok(v) = guard.try_recv() {
+            buf.push_str(&v);
+        }
+
+        let fut = guard.recv();
+
+        // If we haven't found any characters, just wait until we have something.
+        // Otherwise, we give this a 2 ms buffer to check if more things are
+        // coming through the pipe.
+        if buf.is_empty() {
+            let next = fut.await;
+
+            match next {
+                Some(v) => {
+                    buf.push_str(&v);
+                    Some(buf)
+                }
+                None => None,
+            }
+        } else {
+            match tokio::time::timeout(std::time::Duration::from_millis(2), fut).await {
+                Ok(Some(v)) => {
+                    buf.push_str(&v);
+                    Some(buf)
+                }
+                Ok(None) => {
+                    if buf.is_empty() {
+                        None
+                    } else {
+                        Some(buf)
+                    }
+                }
+                Err(_) => Some(buf),
+            }
+        }
+    }
+}
+
+impl Custom for AsyncReader {}
+
+struct AsyncWriter {
+    channel: tokio::sync::mpsc::UnboundedSender<String>,
+}
+
+impl std::io::Write for AsyncWriter {
+    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
+        if let Err(_) = self.channel.send(String::from_utf8_lossy(buf).to_string()) {
+            Ok(0)
+        } else {
+            Ok(buf.len())
+        }
+    }
+
+    fn flush(&mut self) -> std::io::Result<()> {
+        Ok(())
+    }
+}
+
+pub fn helix_component_module(generate_sources: bool) -> BuiltInModule {
+    let mut module = BuiltInModule::new("helix/components");
+
+    let mut builtin_components_module = if generate_sources {
+        "(require-builtin helix/components as helix.components.)".to_string()
+    } else {
+        String::new()
+    };
+
+    macro_rules! register {
+        (value, $name:expr, $function:expr, $doc:expr) => {
+            module.register_value($name, $function);
+            {
+                let doc = format_docstring($doc);
+                builtin_components_module.push_str(&format!(
+                    r#"
+(provide {})
+;;@doc
+{}
+(define {} helix.components.{})
+                    "#,
+                    $name, doc, $name, $name
+                ));
+            }
+        };
+
+        (value, $name:expr, $function:expr) => {
+            module.register_value($name, $function);
+            {
+                builtin_components_module.push_str(&format!(
+                    r#"
+(provide {})
+(define {} helix.components.{})
+                    "#,
+                    $name, $name, $name
+                ));
+            }
+        };
+
+        ($name:expr, $function:expr, $doc:expr) => {
+            module.register_fn($name, $function);
+            {
+                let doc = format_docstring($doc);
+                builtin_components_module.push_str(&format!(
+                    r#"
+(provide {})
+;;@doc
+{}
+(define {} helix.components.{})
+                    "#,
+                    $name, doc, $name, $name
+                ));
+            }
+        };
+
+        ($name:expr, $function:expr) => {
+            module.register_fn($name, $function);
+            {
+                builtin_components_module.push_str(&format!(
+                    r#"
+(provide {})
+(define {} helix.components.{})
+                    "#,
+                    $name, $name, $name
+                ));
+            }
+        };
+
+        (ctx, $name:expr, $function:expr, $arity:expr, $doc:expr) => {
+            module.register_fn($name, $function);
+            let mut function_expr = Vec::with_capacity($arity);
+            for arg in 0..$arity {
+                function_expr.push(format!("arg{}", arg));
+            }
+
+            let formatted = function_expr.join(" ");
+
+            {
+                let doc = format_docstring($doc);
+                builtin_components_module.push_str(&format!(
+                    r#"
+(provide {})
+;;@doc
+{}
+(define ({} {}) (helix.components.{} *helix.cx* {}))
+                    "#,
+                    $name, doc, $name, &formatted, $name, &formatted
+                ));
+            }
+        };
+    }
+
+    register!("async-read-line", AsyncReader::read_line);
+    register!("make-async-reader-writer", || {
+        let (sender, receiver) = tokio::sync::mpsc::unbounded_channel();
+
+        let writer = AsyncWriter { channel: sender };
+        let reader = AsyncReader {
+            channel: Arc::new(Mutex::new(receiver)),
+        };
+
+        vec![
+            SteelVal::new_dyn_writer_port(writer),
+            reader.into_steelval().unwrap(),
+        ]
+    });
+    register!(
+        "theme->bg",
+        |ctx: &mut Context| { ctx.editor.theme.get("ui.background") },
+        "Gets the `Style` associated with the bg for the current theme"
+    );
+    register!(
+        "theme->fg",
+        |ctx: &mut Context| { ctx.editor.theme.get("ui.text") },
+        "Gets the `style` associated with the fg for the current theme"
+    );
+    register!(
+        ctx,
+        "theme-scope",
+        |ctx: &mut Context, scope: SteelString| { ctx.editor.theme.get(scope.as_str()) },
+        1,
+        "Get the `Style` associated with the given scope from the current theme"
+    );
+
+    register!(
+        "Position?",
+        |position: SteelVal| { Position::as_ref(&position).is_ok() },
+        r#"Check if the given value is a `Position`
+
+```scheme
+(Position? value) -> bool?
+```
+
+value : any?
+
+        "#
+    );
+
+    register!(
+        "Style?",
+        |style: SteelVal| Style::as_ref(&style).is_ok(),
+        r#"Check if the given valuie is `Style`
+
+```scheme
+(Style? value) -> bool?
+```
+
+value : any?
+"#
+    );
+
+    register!(
+        "Buffer?",
+        |value: SteelVal| { Buffer::as_ref_from_ref(&value).is_ok() },
+        r#"
+Checks if the given value is a `Buffer`
+
+```scheme
+(Buffer? value) -> bool?
+```
+
+value : any?
+        "#
+    );
+
+    register!(
+        "buffer-area",
+        |buffer: &mut Buffer| buffer.area,
+        r#"
+Get the `Rect` associated with the given `Buffer`
+
+```scheme
+(buffer-area buffer)
+```
+
+* buffer : Buffer?
+        "#
+    );
+
+    register!(
+        "frame-set-string!",
+        buffer_set_string,
+        r#"
+Set the string at the given `x` and `y` positions for the given `Buffer`, with a provided `Style`.
+
+```scheme
+(frame-set-string! buffer x y string style)
+```
+
+buffer : Buffer?,
+x : int?,
+y : int?,
+string: string?,
+style: Style?,
+        "#
+    );
+
+    // name: String,
+    // state: SteelVal,
+    // render: SteelVal,
+    // h: HashMap<String, SteelVal>,
+    // handle_event: h.get("handle_event").cloned(),
+    // _should_update: h.get("should_update").cloned(),
+    // cursor: h.get("cursor").cloned(),
+    // required_size: h.get("required_size").cloned(),
+
+    register!(
+        "SteelEventResult?",
+        |value: SteelVal| { SteelEventResult::as_ref(&value).is_ok() },
+        r#"
+Check whether the given value is a `SteelEventResult`.
+
+```scheme
+(SteelEventResult? value) -> bool?
+```
+
+value : any?
+
+        "#
+    );
+
+    register!(
+        "new-component!",
+        SteelDynamicComponent::new_dyn,
+        r#"
+Construct a new dynamic component. This is used for creating widgets or floating windows
+that exist outside of the buffer. This just constructs the component, it does not push the component
+on to the component stack. For that, you'll use `push-component!`.
+
+```scheme
+(new-component! name state render function-map)
+```
+
+name : string? - This is the name of the comoponent itself.
+state : any? - Typically this is a struct that holds the state of the component.
+render : (-> state? Rect? Buffer?)
+    This is a function that will get called with each frame. The first argument is the state object provided,
+    and the second is the `Rect?` to render against, ultimately against the `Buffer?`.
+
+function-map : (hashof string? function?)
+    This is a hashmap of strings -> function that contains a few important functions:
+
+    "handle_event" : (-> state? Event?) -> SteelEventResult?
+
+        This is called on every event with an event object. There are multiple options you can use
+        when returning from this function:
+
+        * event-result/consume
+        * event-result/consume-without-rerender
+        * event-result/ignore
+        * event-result/close
+
+        See the associated docs for those to understand the implications for each.
+        
+    "cursor" : (-> state? Rect?) -> Position?
+
+        This tells helix where to put the cursor.
+    
+    "required_size": (-> state? (pair? int?)) -> (pair? int?)
+
+        Seldom used: TODO
+    "#
+    );
+
+    register!(
+        "position",
+        Position::new,
+        r#"
+Construct a new `Position`.
+
+```scheme
+(position row col) -> Position?
+```
+
+row : int?
+col : int?
+        "#
+    );
+    register!(
+        "position-row",
+        |position: &Position| position.row,
+        r#"
+Get the row associated with the given `Position`.
+
+```scheme
+(position-row pos) -> int?
+```
+
+pos : `Position?`
+        "#
+    );
+    register!(
+        "position-col",
+        |position: &Position| position.col,
+        r#"
+Get the col associated with the given `Position`.
+
+```scheme
+(position-col pos) -> int?
+```
+
+pos : `Position?`
+"#
+    );
+
+    register!(
+        "set-position-row!",
+        |position: &mut Position, row: usize| {
+            position.row = row;
+        },
+        r#"Set the row for the given `Position`
+
+```scheme
+(set-position-row! pos row)
+```
+
+pos : Position?
+row : int?
+        "#
+    );
+    register!(
+        "set-position-col!",
+        |position: &mut Position, col: usize| {
+            position.col = col;
+        },
+        r#"Set the col for the given `Position`
+
+```scheme
+(set-position-col! pos col)
+```
+
+pos : Position?
+col : int?
+        "#
+    );
+
+    register!(
+        "Rect?",
+        |value: SteelVal| { Rect::as_ref(&value).is_ok() },
+        r#"Check if the given value is a `Rect`
+
+```scheme
+(Rect? value) -> bool?
+```
+
+value : any?
+
+        "#
+    );
+
+    register!(
+        "area",
+        helix_view::graphics::Rect::new,
+        r#"
+Constructs a new `Rect`.
+
+(area x y width height)
+
+* x : int?
+* y : int?
+* width: int?
+* height: int?
+
+# Examples
+
+```scheme
+(area 0 0 100 200)
+```
+"#
+    );
+    register!(
+        "area-x",
+        |area: &helix_view::graphics::Rect| area.x,
+        r#"Get the `x` value of the given `Rect`
+
+```scheme
+(area-x area) -> int?
+```
+
+area : Rect?
+        "#
+    );
+    register!(
+        "area-y",
+        |area: &helix_view::graphics::Rect| area.y,
+        r#"Get the `y` value of the given `Rect`
+
+```scheme
+(area-y area) -> int?
+```
+
+area : Rect?
+        "#
+    );
+    register!(
+        "area-width",
+        |area: &helix_view::graphics::Rect| area.width,
+        r#"Get the `width` value of the given `Rect`
+
+```scheme
+(area-width area) -> int?
+```
+
+area : Rect?
+        "#
+    );
+    register!(
+        "area-height",
+        |area: &helix_view::graphics::Rect| { area.height },
+        r#"Get the `height` value of the given `Rect`
+
+```scheme
+(area-height area) -> int?
+```
+
+area : Rect?
+        "#
+    );
+
+    register!("overlaid", |component: &mut WrappedDynComponent| {
+        let inner: Option<Box<dyn Component + Send + Sync + 'static>> =
+            component.inner.take().map(|x| {
+                Box::new(overlaid(BoxDynComponent::new(x)))
+                    as Box<dyn Component + Send + Sync + 'static>
+            });
+
+        component.inner = inner;
+    });
+
+    register!(
+        "Widget/list?",
+        |value: SteelVal| { widgets::List::as_ref(&value).is_ok() },
+        r#"Check whether the given value is a list widget.
+
+```scheme
+(Widget/list? value) -> bool?
+```
+
+value : any?
+        "#
+    );
+
+    register!(
+        "widget/list",
+        |items: Vec<String>| {
+            widgets::List::new(
+                items
+                    .into_iter()
+                    .map(|x| ListItem::new(Text::from(x)))
+                    .collect::<Vec<_>>(),
+            )
+        },
+        r#"Creates a new `List` widget with the given items.
+
+```scheme
+(widget/list lst) -> Widget?
+```
+
+* lst : (listof string?)
+        "#
+    );
+
+    register!(
+        "widget/list/render",
+        |buf: &mut Buffer, area: Rect, list: widgets::List| list.render(area, buf),
+        r#"
+
+Render the given `Widget/list` onto the provided `Rect` within the given `Buffer`.
+
+```scheme
+(widget/list/render buf area lst)
+```
+
+* buf : `Buffer?`
+* area : `Rect?`
+* lst : `Widget/list?`
+        "#
+    );
+
+    register!(
+        "block",
+        || {
+            Block::default()
+                .borders(Borders::ALL)
+                .border_style(Style::default().fg(Color::White))
+                .border_type(BorderType::Rounded)
+                .style(Style::default().bg(Color::Black))
+        },
+        r#"Creates a block with the following styling:
+
+```scheme
+(block)
+```
+
+* borders - all
+* border-style - default style + white fg
+* border-type - rounded
+* style - default + black bg
+        "#
+    );
+
+    register!(
+        "make-block",
+        |style: Style, border_style: Style, borders: SteelString, border_type: SteelString| {
+            let border_type = match border_type.as_str() {
+                "plain" => BorderType::Plain,
+                "rounded" => BorderType::Rounded,
+                "double" => BorderType::Double,
+                "thick" => BorderType::Thick,
+                _ => BorderType::Plain,
+            };
+
+            let borders = match borders.as_str() {
+                "top" => Borders::TOP,
+                "left" => Borders::LEFT,
+                "right" => Borders::RIGHT,
+                "bottom" => Borders::BOTTOM,
+                "all" => Borders::ALL,
+                _ => Borders::empty(),
+            };
+
+            Block::default()
+                .borders(borders)
+                .border_style(border_style)
+                .border_type(border_type)
+                .style(style)
+        },
+        r#"
+Create a `Block` with the provided styling, borders, and border type.
+
+
+```scheme
+(make-block style border-style borders border_type)
+```
+
+* style : Style?
+* border-style : Style?
+* borders : string?
+* border-type: String?
+
+Valid border-types include:
+* "plain"
+* "rounded"
+* "double"
+* "thick"
+
+Valid borders include:
+* "top"
+* "left"
+* "right"
+* "bottom"
+* "all"
+        "#
+    );
+
+    register!(
+        "block/render",
+        |buf: &mut Buffer, area: Rect, block: Block| block.render(area, buf),
+        r#"
+Render the given `Block` over the given `Rect` onto the provided `Buffer`.
+
+```scheme
+(block/render buf area block)
+```
+
+buf : Buffer?
+area: Rect?
+block: Block?
+            
+        "#
+    );
+
+    register!(
+        "buffer/clear",
+        Buffer::clear,
+        r#"Clear a `Rect` in the `Buffer`
+
+```scheme
+(buffer/clear area)
+```
+
+area : Rect?
+        "#
+    );
+
+    register!(
+        "buffer/clear-with",
+        Buffer::clear_with,
+        r#"Clear a `Rect` in the `Buffer` with a default `Style`
+
+```scheme
+(buffer/clear-with area style)
+```
+
+area : Rect?
+style : Style?
+        "#
+    );
+
+    // Mutate a color in place, to save some headache.
+    register!(
+        "set-color-rgb!",
+        |color: &mut Color, r: u8, g: u8, b: u8| {
+            *color = Color::Rgb(r, g, b);
+        },
+        r#"
+Mutate the r/g/b of a color in place, to avoid allocation.
+
+```scheme
+(set-color-rgb! color r g b)
+```
+
+color : Color?
+r : int?
+g : int?
+b : int?
+"#
+    );
+
+    register!(
+        "set-color-indexed!",
+        |color: &mut Color, index: u8| {
+            *color = Color::Indexed(index);
+        },
+        r#"
+Mutate this color to be an indexed color.
+
+```scheme
+(set-color-indexed! color index)
+```
+
+color : Color?
+index: int?
+    
+"#
+    );
+
+    register!(
+        "Color?",
+        |color: SteelVal| { Color::as_ref(&color).is_ok() },
+        r#"Check if the given value is a `Color`.
+
+```scheme
+(Color? value) -> bool?
+```
+
+value : any?
+
+        "#
+    );
+
+    register!(
+        value,
+        "Color/Reset",
+        Color::Reset.into_steelval().unwrap(),
+        r#"
+Singleton for the reset color.
+        "#
+    );
+    register!(
+        value,
+        "Color/Black",
+        Color::Black.into_steelval().unwrap(),
+        r#"
+Singleton for the color black.
+        "#
+    );
+    register!(
+        value,
+        "Color/Red",
+        Color::Red.into_steelval().unwrap(),
+        r#"
+Singleton for the color red.
+        "#
+    );
+    register!(
+        value,
+        "Color/White",
+        Color::White.into_steelval().unwrap(),
+        r#"
+Singleton for the color white.
+        "#
+    );
+    register!(
+        value,
+        "Color/Green",
+        Color::Green.into_steelval().unwrap(),
+        r#"
+Singleton for the color green.
+        "#
+    );
+    register!(
+        value,
+        "Color/Yellow",
+        Color::Yellow.into_steelval().unwrap(),
+        r#"
+Singleton for the color yellow.
+        "#
+    );
+    register!(
+        value,
+        "Color/Blue",
+        Color::Blue.into_steelval().unwrap(),
+        r#"
+Singleton for the color blue.
+        "#
+    );
+    register!(
+        value,
+        "Color/Magenta",
+        Color::Magenta.into_steelval().unwrap(),
+        r#"
+Singleton for the color magenta.
+        "#
+    );
+    register!(
+        value,
+        "Color/Cyan",
+        Color::Cyan.into_steelval().unwrap(),
+        r#"
+Singleton for the color cyan.
+        "#
+    );
+    register!(
+        value,
+        "Color/Gray",
+        Color::Gray.into_steelval().unwrap(),
+        r#"
+Singleton for the color gray.
+        "#
+    );
+    register!(
+        value,
+        "Color/LightRed",
+        Color::LightRed.into_steelval().unwrap(),
+        r#"
+Singleton for the color light read.
+        "#
+    );
+    register!(
+        value,
+        "Color/LightGreen",
+        Color::LightGreen.into_steelval().unwrap(),
+        r#"
+Singleton for the color light green.
+        "#
+    );
+    register!(
+        value,
+        "Color/LightYellow",
+        Color::LightYellow.into_steelval().unwrap(),
+        r#"
+Singleton for the color light yellow.
+        "#
+    );
+    register!(
+        value,
+        "Color/LightBlue",
+        Color::LightBlue.into_steelval().unwrap(),
+        r#"
+Singleton for the color light blue.
+        "#
+    );
+    register!(
+        value,
+        "Color/LightMagenta",
+        Color::LightMagenta.into_steelval().unwrap(),
+        r#"
+Singleton for the color light magenta.
+        "#
+    );
+    register!(
+        value,
+        "Color/LightCyan",
+        Color::LightCyan.into_steelval().unwrap(),
+        r#"
+Singleton for the color light cyan.
+        "#
+    );
+    register!(
+        value,
+        "Color/LightGray",
+        Color::LightGray.into_steelval().unwrap(),
+        r#"
+Singleton for the color light gray.
+        "#
+    );
+
+    register!(
+        "Color/rgb",
+        Color::Rgb,
+        r#"
+Construct a new color via rgb.
+
+```scheme
+(Color/rgb r g b) -> Color?
+```
+
+r : int?
+g : int?
+b : int?
+        "#
+    );
+    register!(
+        "Color-red",
+        Color::red,
+        r#"
+Get the red component of the `Color?`.
+
+```scheme
+(Color-red color) -> int?
+```
+
+color * Color?
+        "#
+    );
+    register!(
+        "Color-green",
+        Color::green,
+        r#"
+Get the green component of the `Color?`.
+
+```scheme
+(Color-green color) -> int?
+```
+
+color * Color?
+"#
+    );
+    register!(
+        "Color-blue",
+        Color::blue,
+        r#"
+Get the blue component of the `Color?`.
+
+```scheme
+(Color-blue color) -> int?
+```
+
+color * Color?
+"#
+    );
+    register!(
+        "Color/Indexed",
+        Color::Indexed,
+        r#"
+
+Construct a new indexed color.
+
+```scheme
+(Color/Indexed index) -> Color?
+```
+
+* index : int?
+        "#
+    );
+
+    register!(
+        "set-style-fg!",
+        |style: &mut Style, color: Color| {
+            style.fg = Some(color);
+        },
+        r#"
+
+Mutates the given `Style` to have the fg with the provided color.
+
+```scheme
+(set-style-fg! style color)
+```
+
+style : `Style?`
+color : `Color?`
+        "#
+    );
+
+    register!(
+        "style-fg",
+        Style::fg,
+        r#"
+
+Constructs a new `Style` with the provided `Color` for the fg.
+
+```scheme
+(style-fg style color) -> Style
+```
+
+style : Style?
+color: Color?
+        "#
+    );
+    register!(
+        "style-bg",
+        Style::bg,
+        r#"
+
+Constructs a new `Style` with the provided `Color` for the bg.
+
+```scheme
+(style-bg style color) -> Style
+```
+
+style : Style?
+color: Color?
+        "#
+    );
+    register!(
+        "style-with-italics",
+        |style: &Style| {
+            let patch = Style::default().add_modifier(Modifier::ITALIC);
+            style.patch(patch)
+        },
+        r#"
+
+Constructs a new `Style` with italcs.
+
+```scheme
+(style-with-italics style) -> Style
+```
+
+style : Style?
+        "#
+    );
+    register!(
+        "style-with-bold",
+        |style: Style| {
+            let patch = Style::default().add_modifier(Modifier::BOLD);
+            style.patch(patch)
+        },
+        r#"
+
+Constructs a new `Style` with bold styling.
+
+```scheme
+(style-with-bold style) -> Style
+```
+
+style : Style?
+        "#
+    );
+    register!(
+        "style-with-dim",
+        |style: &Style| {
+            let patch = Style::default().add_modifier(Modifier::DIM);
+            style.patch(patch)
+        },
+        r#"
+
+Constructs a new `Style` with dim styling.
+
+```scheme
+(style-with-dim style) -> Style
+```
+
+style : Style?
+        "#
+    );
+    register!(
+        "style-with-slow-blink",
+        |style: Style| {
+            let patch = Style::default().add_modifier(Modifier::SLOW_BLINK);
+            style.patch(patch)
+        },
+        r#"
+
+Constructs a new `Style` with slow blink.
+
+```scheme
+(style-with-slow-blink style) -> Style
+```
+
+style : Style?
+        "#
+    );
+    register!(
+        "style-with-rapid-blink",
+        |style: Style| {
+            let patch = Style::default().add_modifier(Modifier::RAPID_BLINK);
+            style.patch(patch)
+        },
+        r#"
+
+Constructs a new `Style` with rapid blink.
+
+```scheme
+(style-with-rapid-blink style) -> Style
+```
+
+style : Style?
+        "#
+    );
+    register!(
+        "style-with-reversed",
+        |style: Style| {
+            let patch = Style::default().add_modifier(Modifier::REVERSED);
+            style.patch(patch)
+        },
+        r#"
+
+Constructs a new `Style` with revered styling.
+
+```scheme
+(style-with-reversed style) -> Style
+```
+
+style : Style?
+        "#
+    );
+    register!(
+        "style-with-hidden",
+        |style: Style| {
+            let patch = Style::default().add_modifier(Modifier::HIDDEN);
+            style.patch(patch)
+        },
+        r#"
+Constructs a new `Style` with hidden styling.
+
+```scheme
+(style-with-hidden style) -> Style
+```
+
+style : Style?
+        "#
+    );
+    register!(
+        "style-with-crossed-out",
+        |style: Style| {
+            let patch = Style::default().add_modifier(Modifier::CROSSED_OUT);
+            style.patch(patch)
+        },
+        r#"
+
+Constructs a new `Style` with crossed out styling.
+
+```scheme
+(style-with-crossed-out style) -> Style
+```
+
+style : Style?
+        "#
+    );
+    register!(
+        "style->fg",
+        |style: &Style| style.fg,
+        r#"
+
+Return the color on the style, or #false if not present.
+
+```scheme
+(style->fg style) -> (or Color? #false)
+```
+
+style : Style?
+            
+        "#
+    );
+    register!(
+        "style->bg",
+        |style: &Style| style.bg,
+        r#"
+
+Return the color on the style, or #false if not present.
+
+```scheme
+(style->bg style) -> (or Color? #false)
+```
+
+style : Style?
+            
+        "#
+    );
+    register!(
+        "set-style-bg!",
+        |style: &mut Style, color: Color| {
+            style.bg = Some(color);
+        },
+        r#"
+
+Mutate the background style on the given style to a given color.
+
+```scheme
+(set-style-bg! style color)
+```
+
+style : Style?
+color : Color?
+            
+        "#
+    );
+
+    register!(
+        "style-underline-color",
+        Style::underline_color,
+        r#"
+
+Return a new style with the provided underline color.
+
+```scheme
+(style-underline-color style color) -> Style?
+
+```
+style : Style?
+color : Color?
+            
+        "#
+    );
+    register!(
+        "style-underline-style",
+        Style::underline_style,
+        r#"
+Return a new style with the provided underline style.
+
+```scheme
+(style-underline-style style underline-style) -> Style?
+
+```
+
+style : Style?
+underline-style : UnderlineStyle?
+
+"#
+    );
+
+    register!(
+        "UnderlineStyle?",
+        |value: SteelVal| { UnderlineStyle::as_ref(&value).is_ok() },
+        r#"
+Check if the provided value is an `UnderlineStyle`.
+
+```scheme
+(UnderlineStyle? value) -> bool?
+
+```
+value : any?"#
+    );
+
+    register!(
+        value,
+        "Underline/Reset",
+        UnderlineStyle::Reset.into_steelval().unwrap(),
+        r#"
+Singleton for resetting the underling style.
+        "#
+    );
+    register!(
+        value,
+        "Underline/Line",
+        UnderlineStyle::Line.into_steelval().unwrap(),
+        r#"
+Singleton for the line underline style.
+        "#
+    );
+    register!(
+        value,
+        "Underline/Curl",
+        UnderlineStyle::Curl.into_steelval().unwrap(),
+        r#"
+Singleton for the curl underline style.
+        "#
+    );
+    register!(
+        value,
+        "Underline/Dotted",
+        UnderlineStyle::Dotted.into_steelval().unwrap(),
+        r#"
+Singleton for the dotted underline style.
+        "#
+    );
+    register!(
+        value,
+        "Underline/Dashed",
+        UnderlineStyle::Dashed.into_steelval().unwrap(),
+        r#"
+Singleton for the dashed underline style.
+        "#
+    );
+    register!(
+        value,
+        "Underline/DoubleLine",
+        UnderlineStyle::DoubleLine.into_steelval().unwrap(),
+        r#"
+Singleton for the double line underline style.
+        "#
+    );
+    register!(
+        value,
+        "event-result/consume",
+        SteelEventResult::Consumed.into_steelval().unwrap(),
+        r#"
+Singleton for consuming an event. If this is returned from an event handler, the event
+will not continue to be propagated down the component stack. This also will trigger a
+re-render.
+        "#
+    );
+    register!(
+        value,
+        "event-result/consume-without-rerender",
+        SteelEventResult::ConsumedWithoutRerender
+            .into_steelval()
+            .unwrap(),
+        r#"
+Singleton for consuming an event. If this is returned from an event handler, the event
+will not continue to be propagated down the component stack. This will _not_ trigger
+a re-render.
+        "#
+    );
+    register!(
+        value,
+        "event-result/ignore",
+        SteelEventResult::Ignored.into_steelval().unwrap(),
+        r#"
+Singleton for ignoring an event. If this is returned from an event handler, the event
+will not continue to be propagated down the component stack. This will _not_ trigger
+a re-render.
+        "#
+    );
+
+    register!(
+        value,
+        "event-result/ignore-and-close",
+        SteelEventResult::IgnoreAndClose.into_steelval().unwrap(),
+        r#"
+Singleton for ignoring an event. If this is returned from an event handler, the event
+will continue to be propagated down the component stack, and the component will be
+popped off of the stack and removed.
+        "#
+    );
+
+    register!(
+        value,
+        "event-result/close",
+        SteelEventResult::Close.into_steelval().unwrap(),
+        r#"
+Singleton for consuming an event. If this is returned from an event handler, the event
+will not continue to be propagated down the component stack, and the component will
+be popped off of the stack and removed.
+        "#
+    );
+
+    register!(
+        "style",
+        || Style::default(),
+        r#"
+Constructs a new default style.
+
+```scheme
+(style) -> Style?
+```
+        "#
+    );
+
+    register!(
+        "Event?",
+        |value: SteelVal| { Event::as_ref(&value).is_ok() },
+        r#"Check if this value is an `Event`
+
+```scheme
+(Event? value) -> bool?
+```
+value : any?
+        "#
+    );
+
+    // TODO: Register this differently so it doesn't clone the pasted text unnecessarily
+    register!(
+        "paste-event?",
+        |event: Event| { matches!(event, Event::Paste(_)) },
+        r#"Checks if the given event is a paste event.
+
+```scheme
+(paste-event? event) -> bool?
+```
+
+* event : Event?
+            
+        "#
+    );
+
+    register!(
+        "paste-event-string",
+        |event: Event| {
+            if let Event::Paste(p) = event {
+                Some(p)
+            } else {
+                None
+            }
+        },
+        r#"Get the string from the paste event, if it is a paste event.
+
+```scheme
+(paste-event-string event) -> (or string? #false)
+```
+
+* event : Event?
+
+        "#
+    );
+
+    register!(
+        "key-event?",
+        |event: Event| { matches!(event, Event::Key(_)) },
+        r#"Checks if the given event is a key event.
+
+```scheme
+(key-event? event) -> bool?
+```
+
+* event : Event?
+        "#
+    );
+
+    register!(
+        "key-event-char",
+        |event: Event| {
+            if let Event::Key(event) = event {
+                event.char()
+            } else {
+                None
+            }
+        },
+        r#"Get the character off of the event, if there is one.
+
+```scheme
+(key-event-char event) -> (or char? #false)
+```
+event : Event?
+        "#
+    );
+
+    register!(
+        "key-event-modifier",
+        |event: Event| {
+            if let Event::Key(KeyEvent { modifiers, .. }) = event {
+                Some(modifiers.bits())
+            } else {
+                None
+            }
+        },
+        r#"
+Get the key event modifier off of the event, if there is one.
+
+```scheme
+(key-event-modifier event) -> (or int? #false)
+```
+event : Event?
+        "#
+    );
+
+    register!(
+        value,
+        "key-modifier-ctrl",
+        SteelVal::IntV(KeyModifiers::CONTROL.bits() as isize),
+        r#"
+The key modifier bits associated with the ctrl key modifier.
+        "#
+    );
+    register!(
+        value,
+        "key-modifier-shift",
+        SteelVal::IntV(KeyModifiers::SHIFT.bits() as isize),
+        r#"
+The key modifier bits associated with the shift key modifier.
+        "#
+    );
+    register!(
+        value,
+        "key-modifier-alt",
+        SteelVal::IntV(KeyModifiers::ALT.bits() as isize),
+        r#"
+The key modifier bits associated with the alt key modifier.
+        "#
+    );
+
+    register!(
+        "key-event-F?",
+        |event: Event, number: u8| match event {
+            Event::Key(KeyEvent {
+                code: KeyCode::F(x),
+                ..
+            }) if number == x => true,
+            _ => false,
+        },
+        r#"Check if this key event is associated with an `F<x>` key, e.g. F1, F2, etc.
+
+```scheme
+(key-event-F? event number) -> bool?
+```
+event : Event?
+number : int?
+        "#
+    );
+
+    register!(
+        "mouse-event?",
+        |event: Event| { matches!(event, Event::Mouse(_)) },
+        r#"
+Check if this event is a mouse event.
+
+```scheme
+(mouse-event event) -> bool?
+```
+event : Event?
+"#
+    );
+
+    register!(
+        "event-mouse-kind",
+        |event: Event| {
+            if let Event::Mouse(MouseEvent { kind, .. }) = event {
+                match kind {
+                    helix_view::input::MouseEventKind::Down(MouseButton::Left) => 0,
+                    helix_view::input::MouseEventKind::Down(MouseButton::Right) => 1,
+                    helix_view::input::MouseEventKind::Down(MouseButton::Middle) => 2,
+                    helix_view::input::MouseEventKind::Up(MouseButton::Left) => 3,
+                    helix_view::input::MouseEventKind::Up(MouseButton::Right) => 4,
+                    helix_view::input::MouseEventKind::Up(MouseButton::Middle) => 5,
+                    helix_view::input::MouseEventKind::Drag(MouseButton::Left) => 6,
+                    helix_view::input::MouseEventKind::Drag(MouseButton::Right) => 7,
+                    helix_view::input::MouseEventKind::Drag(MouseButton::Middle) => 8,
+                    helix_view::input::MouseEventKind::Moved => 9,
+                    helix_view::input::MouseEventKind::ScrollDown => 10,
+                    helix_view::input::MouseEventKind::ScrollUp => 11,
+                    helix_view::input::MouseEventKind::ScrollLeft => 12,
+                    helix_view::input::MouseEventKind::ScrollRight => 13,
+                }
+                .into_steelval()
+            } else {
+                false.into_steelval()
+            }
+        },
+        r#"Convert the mouse event kind into an integer representing the state.
+
+```scheme
+(event-mouse-kind event) -> (or int? #false)
+```
+
+event : Event?
+
+This is the current mapping today:
+
+```rust
+match kind {
+    helix_view::input::MouseEventKind::Down(MouseButton::Left) => 0,
+    helix_view::input::MouseEventKind::Down(MouseButton::Right) => 1,
+    helix_view::input::MouseEventKind::Down(MouseButton::Middle) => 2,
+    helix_view::input::MouseEventKind::Up(MouseButton::Left) => 3,
+    helix_view::input::MouseEventKind::Up(MouseButton::Right) => 4,
+    helix_view::input::MouseEventKind::Up(MouseButton::Middle) => 5,
+    helix_view::input::MouseEventKind::Drag(MouseButton::Left) => 6,
+    helix_view::input::MouseEventKind::Drag(MouseButton::Right) => 7,
+    helix_view::input::MouseEventKind::Drag(MouseButton::Middle) => 8,
+    helix_view::input::MouseEventKind::Moved => 9,
+    helix_view::input::MouseEventKind::ScrollDown => 10,
+    helix_view::input::MouseEventKind::ScrollUp => 11,
+    helix_view::input::MouseEventKind::ScrollLeft => 12,
+    helix_view::input::MouseEventKind::ScrollRight => 13,
+}
+```
+
+Any unhandled event that does not match this will return `#false`.
+"#
+    );
+
+    register!(
+        "event-mouse-row",
+        |event: Event| {
+            if let Event::Mouse(MouseEvent { row, .. }) = event {
+                row.into_steelval()
+            } else {
+                false.into_steelval()
+            }
+        },
+        r#"
+
+Get the row from the mouse event, of #false if it isn't a mouse event.
+
+```scheme
+(event-mouse-row event) -> (or int? #false)
+```
+
+event : Event?
+            
+        "#
+    );
+    register!(
+        "event-mouse-col",
+        |event: Event| {
+            if let Event::Mouse(MouseEvent { column, .. }) = event {
+                column.into_steelval()
+            } else {
+                false.into_steelval()
+            }
+        },
+        r#"
+
+Get the col from the mouse event, of #false if it isn't a mouse event.
+
+```scheme
+(event-mouse-row event) -> (or int? #false)
+```
+
+event : Event?
+        "#
+    );
+    // Is this mouse event within the area provided
+    register!(
+        "mouse-event-within-area?",
+        |event: Event, area: Rect| {
+            if let Event::Mouse(MouseEvent { row, column, .. }) = event {
+                column > area.x
+                    && column < area.x + area.width
+                    && row > area.y
+                    && row < area.y + area.height
+            } else {
+                false
+            }
+        },
+        r#"Check whether the given mouse event occurred within a given `Rect`.
+
+```scheme
+(mouse-event-within-area? event area) -> bool?
+```
+
+event : Event?
+area : Rect?
+        "#
+    );
+
+    macro_rules! register_key_events {
+        ($ ( $name:expr => $key:tt ) , *, ) => {
+            $(
+              register!(concat!("key-event-", $name, "?"), |event: Event| {
+                  matches!(
+                      event,
+                      Event::Key(
+                          KeyEvent {
+                              code: KeyCode::$key,
+                              ..
+                          }
+                      ))
+                  },
+                &format!(r#"
+Check whether the given event is the key: {}
+
+```scheme
+(key-event-{}? event)
+```
+event: Event?"#, $name, $name));
+            )*
+        };
+    }
+
+    // Key events for individual key codes
+    register_key_events!(
+        "escape" => Esc,
+        "backspace" => Backspace,
+        "enter" => Enter,
+        "left" => Left,
+        "right" => Right,
+        "up" => Up,
+        "down" => Down,
+        "home" => Home,
+        "page-up" => PageUp,
+        "page-down" => PageDown,
+        "tab" => Tab,
+        "delete" => Delete,
+        "insert" => Insert,
+        "null" => Null,
+        "caps-lock" => CapsLock,
+        "scroll-lock" => ScrollLock,
+        "num-lock" => NumLock,
+        "print-screen" => PrintScreen,
+        "pause" => Pause,
+        "menu" => Menu,
+        "keypad-begin" => KeypadBegin,
+    );
+
+    if generate_sources {
+        if let Some(mut target_directory) =
+            crate::commands::engine::steel::alternative_runtime_search_path()
+        {
+            if !target_directory.exists() {
+                std::fs::create_dir_all(&target_directory).unwrap();
+            }
+            target_directory.push("components.scm");
+            std::fs::write(target_directory, &builtin_components_module).unwrap();
+        }
+    }
+
+    module
+}
+
+fn buffer_set_string(
+    buffer: &mut tui::buffer::Buffer,
+    x: u16,
+    y: u16,
+    string: SteelVal,
+    style: Style,
+) -> steel::rvals::Result<()> {
+    match string {
+        SteelVal::StringV(string) => {
+            buffer.set_string(x, y, string.as_str(), style);
+            Ok(())
+        }
+        SteelVal::Custom(c) => {
+            if let Some(string) =
+                as_underlying_type::<steel::steel_vm::ffi::MutableString>(c.read().as_ref())
+            {
+                buffer.set_string(x, y, string.string.as_str(), style);
+                Ok(())
+            } else {
+                steel::stop!(TypeMismatch => "buffer-set-string! expected a string")
+            }
+        }
+        _ => {
+            steel::stop!(TypeMismatch => "buffer-set-string! expected a string")
+        }
+    }
+
+    // buffer.set_string(x, y, string.as_str(), style)
+}
+
+/// A dynamic component, used for rendering
+// #[derive(Clone)]
+pub struct SteelDynamicComponent {
+    // TODO: currently the component id requires using a &'static str,
+    // however in a world with dynamic components that might not be
+    // the case anymore
+    name: String,
+    // This _should_ be a struct, but in theory can be whatever you want. It will be the first argument
+    // passed to the functions in the remainder of the struct.
+    state: SteelVal,
+    handle_event: Option<SteelVal>,
+    _should_update: Option<SteelVal>,
+    render: SteelVal,
+    cursor: Option<SteelVal>,
+    required_size: Option<SteelVal>,
+
+    // Cached key event; we keep this around so that when sending
+    // events to the event handler, we can reuse the heap allocation
+    // instead of re-allocating for every event (which might be a lot)
+    key_event: Option<SteelVal>,
+
+    // Just root all of the inputs so that we don't have any issues with
+    // things dropping
+    _roots: Vec<RootedSteelVal>,
+}
+
+impl SteelDynamicComponent {
+    pub fn new(
+        name: String,
+        state: SteelVal,
+        render: SteelVal,
+        h: HashMap<String, SteelVal>,
+    ) -> Self {
+        let mut roots = vec![state.clone().as_rooted(), render.clone().as_rooted()];
+
+        for value in h.values() {
+            roots.push(value.clone().as_rooted());
+        }
+
+        // Keep root tokens around? Otherwise we're not going to be
+        // able to reach these values from the runtime.
+        Self {
+            name,
+            state,
+            render,
+            handle_event: h.get("handle_event").cloned(),
+            _should_update: h.get("should_update").cloned(),
+            cursor: h.get("cursor").cloned(),
+            required_size: h.get("required_size").cloned(),
+            key_event: None,
+            _roots: roots,
+        }
+    }
+
+    pub fn new_dyn(
+        name: String,
+        state: SteelVal,
+        render: SteelVal,
+        h: HashMap<String, SteelVal>,
+    ) -> WrappedDynComponent {
+        let s = Self::new(name, state, render, h);
+
+        // TODO: Add guards here for the
+        WrappedDynComponent {
+            inner: Some(Box::new(s)),
+        }
+    }
+}
+
+impl Custom for SteelDynamicComponent {}
+
+impl Custom for Box<dyn Component> {}
+
+#[derive(Clone)]
+enum SteelEventResult {
+    Consumed,
+    Ignored,
+    IgnoreAndClose,
+    Close,
+    ConsumedWithoutRerender,
+}
+
+impl Custom for SteelEventResult {}
+
+impl Component for SteelDynamicComponent {
+    fn name(&self) -> Option<&str> {
+        Some(&self.name)
+    }
+
+    fn render(
+        &mut self,
+        area: helix_view::graphics::Rect,
+        frame: &mut tui::buffer::Buffer,
+        ctx: &mut compositor::Context,
+    ) {
+        // Skip rendering if the function is actually false
+        if let SteelVal::BoolV(false) = self.render {
+            return;
+        }
+
+        let mut ctx = Context {
+            register: None,
+            count: None,
+            editor: ctx.editor,
+            callback: Vec::new(),
+            on_next_key_callback: None,
+            jobs: ctx.jobs,
+        };
+
+        // Pass the `state` object through - this can be used for storing the state of whatever plugin thing we're
+        // attempting to render
+        let thunk = |engine: &mut Engine, f| {
+            engine.call_function_with_args_from_mut_slice(
+                self.render.clone(),
+                &mut [self.state.clone(), area.into_steelval().unwrap(), f],
+            )
+        };
+
+        enter_engine(|guard| {
+            if let Err(e) = guard
+                .with_mut_reference::<tui::buffer::Buffer, tui::buffer::Buffer>(frame)
+                .with_mut_reference::<Context, Context>(&mut ctx)
+                .consume(|engine, args| {
+                    let mut arg_iter = args.into_iter();
+
+                    let buffer = arg_iter.next().unwrap();
+                    let context = arg_iter.next().unwrap();
+
+                    engine.update_value("*helix.cx*", context);
+
+                    (thunk)(engine, buffer)
+                })
+            {
+                let name = self.name.clone();
+                super::steel::present_error_inside_engine_context_with_callback(
+                    &mut ctx,
+                    guard,
+                    e,
+                    move |compositor| {
+                        compositor.remove_by_dynamic_name(&name);
+                    },
+                );
+            }
+        })
+    }
+
+    // TODO: Pass in event as well? Need to have immutable reference type
+    // Otherwise, we're gonna be in a bad spot. For now - just clone the object and pass it through.
+    // Clong is _not_ ideal, but it might be all we can do for now.
+    fn handle_event(
+        &mut self,
+        event: &Event,
+        ctx: &mut compositor::Context,
+    ) -> compositor::EventResult {
+        if let Some(handle_event) = &mut self.handle_event {
+            let mut ctx = Context {
+                register: None,
+                count: None,
+                editor: ctx.editor,
+                callback: Vec::new(),
+                on_next_key_callback: None,
+                jobs: ctx.jobs,
+            };
+
+            match self.key_event.as_mut() {
+                Some(SteelVal::Custom(key_event)) => {
+                    // Save the headache, reuse the allocation
+                    if let Some(inner) =
+                        steel::rvals::as_underlying_type_mut::<Event>(key_event.write().as_mut())
+                    {
+                        *inner = event.clone();
+                    }
+                }
+
+                None => {
+                    self.key_event = Some(event.clone().into_steelval().unwrap());
+                }
+                _ => {
+                    panic!("This event needs to stay as a steelval");
+                }
+            }
+
+            // Pass the `state` object through - this can be used for storing the state of whatever plugin thing we're
+            // attempting to render
+            let thunk = |engine: &mut Engine| {
+                engine.call_function_with_args_from_mut_slice(
+                    handle_event.clone(),
+                    &mut [self.state.clone(), self.key_event.clone().unwrap()],
+                )
+            };
+
+            // let event = match event {
+            //     Event::Key(event) => *event,
+            //     _ => return compositor::EventResult::Ignored(None),
+            // };
+
+            match enter_engine(|guard| {
+                guard
+                    .with_mut_reference::<Context, Context>(&mut ctx)
+                    .consume(move |engine, arguments| {
+                        let context = arguments[0].clone();
+                        engine.update_value("*helix.cx*", context);
+
+                        thunk(engine)
+                    })
+            }) {
+                Ok(v) => {
+                    let value = SteelEventResult::from_steelval(&v);
+
+                    match value {
+                        Ok(SteelEventResult::Close) => compositor::EventResult::Consumed(Some(
+                            Box::new(|compositor: &mut compositor::Compositor, _| {
+                                // remove the layer
+                                compositor.pop();
+                            }),
+                        )),
+                        Ok(SteelEventResult::Consumed) => compositor::EventResult::Consumed(None),
+                        Ok(SteelEventResult::ConsumedWithoutRerender) => {
+                            compositor::EventResult::ConsumedWithoutRerender
+                        }
+                        Ok(SteelEventResult::Ignored) => compositor::EventResult::Ignored(None),
+                        Ok(SteelEventResult::IgnoreAndClose) => compositor::EventResult::Ignored(
+                            Some(Box::new(|compositor: &mut compositor::Compositor, _| {
+                                // remove the layer
+                                compositor.pop();
+                            })),
+                        ),
+                        _ => match event {
+                            // ctrl!('c') | key!(Esc) => close_fn,
+                            _ => compositor::EventResult::Ignored(None),
+                        },
+                    }
+                }
+                Err(e) => {
+                    // Present the error
+                    enter_engine(|x| present_error_inside_engine_context(&mut ctx, x, e));
+
+                    compositor::EventResult::Ignored(None)
+                }
+            }
+        } else {
+            compositor::EventResult::Ignored(None)
+        }
+    }
+
+    fn should_update(&self) -> bool {
+        true
+
+        // if let Some(should_update) = &self.should_update {
+        //     match ENGINE.with(|x| {
+        //         let res = x
+        //             .borrow_mut()
+        //             .call_function_with_args(should_update.clone(), vec![self.state.clone()]);
+
+        //         res
+        //     }) {
+        //         Ok(v) => bool::from_steelval(&v).unwrap_or(true),
+        //         Err(_) => true,
+        //     }
+        // } else {
+        //     true
+        // }
+    }
+
+    // TODO: Implement immutable references. Right now I'm only supporting mutable references.
+    fn cursor(
+        &self,
+        area: helix_view::graphics::Rect,
+        _ctx: &Editor,
+    ) -> (
+        Option<helix_core::Position>,
+        helix_view::graphics::CursorKind,
+    ) {
+        if let Some(cursor) = &self.cursor {
+            // Pass the `state` object through - this can be used for storing the state of whatever plugin thing we're
+            // attempting to render
+            let thunk = |engine: &mut Engine| {
+                engine.call_function_with_args_from_mut_slice(
+                    cursor.clone(),
+                    &mut [self.state.clone(), area.into_steelval().unwrap()],
+                )
+            };
+
+            let result =
+                Option::<helix_core::Position>::from_steelval(&enter_engine(|x| thunk(x).unwrap()));
+
+            match result {
+                Ok(v) => (v, CursorKind::Block),
+                // TODO: Figure out how to pop up an error message
+                Err(_e) => {
+                    log::info!("Error: {:?}", _e);
+                    (None, CursorKind::Block)
+                }
+            }
+        } else {
+            (None, helix_view::graphics::CursorKind::Hidden)
+        }
+    }
+
+    fn required_size(&mut self, viewport: (u16, u16)) -> Option<(u16, u16)> {
+        // let name = self.type_name();
+
+        if let Some(required_size) = &mut self.required_size {
+            // log::info!("Calling required-size inside: {}", name);
+
+            // TODO: Create some token that we can grab to enqueue function calls internally. Referencing
+            // the external API would cause problems - we just need to include a handle to the interpreter
+            // instance. Something like:
+            // ENGINE.call_function_or_enqueue? OR - this is the externally facing render function. Internal
+            // render calls do _not_ go through this interface. Instead, they are just called directly.
+            //
+            // If we go through this interface, we're going to get an already borrowed mut error, since it is
+            // re-entrant attempting to grab the ENGINE instead mutably, since we have to break the recursion
+            // somehow. By putting it at the edge, we then say - hey for these functions on this interface,
+            // call the engine instance. Otherwise, all computation happens inside the engine.
+            match enter_engine(|x| {
+                x.call_function_with_args_from_mut_slice(
+                    required_size.clone(),
+                    &mut [self.state.clone(), viewport.into_steelval().unwrap()],
+                )
+            })
+            .and_then(|x| Option::<(u16, u16)>::from_steelval(&x))
+            {
+                Ok(v) => v,
+                // TODO: Figure out how to present an error
+                Err(_e) => None,
+            }
+        } else {
+            None
+        }
+    }
+
+    fn type_name(&self) -> &'static str {
+        std::any::type_name::<Self>()
+    }
+
+    fn id(&self) -> Option<&'static str> {
+        None
+    }
+}
diff --git a/helix-term/src/commands/engine/steel.rs b/helix-term/src/commands/engine/steel.rs
new file mode 100644
index 000000000..1d4ee6a02
--- /dev/null
+++ b/helix-term/src/commands/engine/steel.rs
@@ -0,0 +1,5264 @@
+use arc_swap::{ArcSwap, ArcSwapAny};
+use crossterm::event::{Event, KeyCode, KeyModifiers};
+use helix_core::{
+    command_line::Args,
+    diagnostic::Severity,
+    extensions::steel_implementations::{rope_module, SteelRopeSlice},
+    find_workspace, graphemes,
+    syntax::config::{
+        default_timeout, AutoPairConfig, LanguageConfiguration, LanguageServerConfiguration,
+        SoftWrap,
+    },
+    syntax::{self},
+    text_annotations::InlineAnnotation,
+    Range, Selection, Tendril,
+};
+use helix_event::register_hook;
+use helix_view::{
+    annotations::diagnostics::DiagnosticFilter,
+    document::{DocumentInlayHints, DocumentInlayHintsId, Mode},
+    editor::{
+        Action, AutoSave, BufferLine, ConfigEvent, CursorShapeConfig, FilePickerConfig,
+        GutterConfig, IndentGuidesConfig, LineEndingConfig, LineNumber, LspConfig, SearchConfig,
+        SmartTabConfig, StatusLineConfig, TerminalConfig, WhitespaceConfig,
+    },
+    events::{DocumentDidOpen, DocumentFocusLost, DocumentSaved, SelectionDidChange},
+    extension::document_id_to_usize,
+    graphics::CursorKind,
+    input::KeyEvent,
+    theme::Color,
+    DocumentId, Editor, Theme, ViewId,
+};
+use once_cell::sync::{Lazy, OnceCell};
+use steel::{
+    compiler::modules::steel_home,
+    gc::{unsafe_erased_pointers::CustomReference, ShareableMut},
+    rerrs::ErrorKind,
+    rvals::{as_underlying_type, AsRefMutSteelVal, FromSteelVal, IntoSteelVal, SteelString},
+    steel_vm::{
+        engine::Engine, mutex_lock, mutex_unlock, register_fn::RegisterFn, ThreadStateController,
+    },
+    steelerr, RootedSteelVal, SteelErr, SteelVal,
+};
+
+use std::{
+    borrow::Cow,
+    collections::HashMap,
+    error::Error,
+    io::Write,
+    path::PathBuf,
+    sync::{atomic::AtomicBool, Mutex, MutexGuard, RwLock, RwLockReadGuard},
+    time::{Duration, SystemTime},
+};
+use std::{str::FromStr as _, sync::Arc};
+
+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};
+
+use crate::{
+    // args::Args,
+    commands::insert,
+    compositor::{self, Component, Compositor},
+    config::Config,
+    events::{OnModeSwitch, PostCommand, PostInsertChar},
+    job::{self, Callback},
+    keymap::{self, merge_keys, KeyTrie, KeymapResult},
+    ui::{self, picker::PathOrId, PickerColumn, Popup, Prompt, PromptEvent},
+};
+
+use components::SteelDynamicComponent;
+
+use super::{
+    components::{self, helix_component_module},
+    Context, MappableCommand, TYPABLE_COMMAND_LIST,
+};
+use insert::{insert_char, insert_string};
+
+pub static INTERRUPT_HANDLER: OnceCell<InterruptHandler> = OnceCell::new();
+
+// TODO: Use this for the available commands.
+// We just have to look at functions that have been defined at
+// the top level, _after_ they
+pub static GLOBAL_OFFSET: OnceCell<usize> = OnceCell::new();
+
+fn setup() -> Engine {
+    let engine = steel::steel_vm::engine::Engine::new();
+
+    // Any function after this point can be used for looking at "new" functions
+    // GLOBAL_OFFSET.set(engine.readable_globals(0).len()).unwrap();
+
+    let controller = engine.get_thread_state_controller();
+    let running = Arc::new(AtomicBool::new(false));
+
+    fn is_event_available() -> std::io::Result<bool> {
+        crossterm::event::poll(Duration::from_millis(10))
+    }
+
+    let controller_clone = controller.clone();
+    let running_clone = running.clone();
+
+    // TODO: Only allow interrupt after a certain amount of time...
+    // perhaps something like, 500 ms? That way interleaving calls to
+    // steel functions don't accidentally cause an interrupt.
+    let thread_handle = std::thread::spawn(move || {
+        let controller = controller_clone;
+        let running = running_clone;
+
+        loop {
+            std::thread::park();
+
+            while running.load(std::sync::atomic::Ordering::Relaxed) {
+                if is_event_available().unwrap_or(false) {
+                    let event = crossterm::event::read();
+
+                    if let Ok(Event::Key(crossterm::event::KeyEvent {
+                        code: KeyCode::Char('c'),
+                        modifiers: KeyModifiers::CONTROL,
+                        ..
+                    })) = event
+                    {
+                        controller.interrupt();
+                        break;
+                    }
+                }
+            }
+        }
+    });
+
+    INTERRUPT_HANDLER
+        .set(InterruptHandler {
+            controller: controller.clone(),
+            running: running.clone(),
+            handle: thread_handle,
+        })
+        .ok();
+
+    configure_engine_impl(engine)
+}
+
+// The Steel scripting engine instance. This is what drives the whole integration.
+pub static GLOBAL_ENGINE: Lazy<Mutex<steel::steel_vm::engine::Engine>> =
+    Lazy::new(|| Mutex::new(setup()));
+
+fn acquire_engine_lock() -> MutexGuard<'static, Engine> {
+    GLOBAL_ENGINE.lock().unwrap()
+}
+
+/// Run a function with exclusive access to the engine. This only
+/// locks the engine that is running on the main thread.
+pub fn enter_engine<F, R>(f: F) -> R
+where
+    F: FnOnce(&mut Engine) -> R,
+{
+    (f)(&mut acquire_engine_lock())
+}
+
+pub fn try_enter_engine<F, R>(f: F) -> Option<R>
+where
+    F: FnOnce(&mut Engine) -> R,
+{
+    match GLOBAL_ENGINE.try_lock() {
+        Ok(mut v) => Some((f)(&mut v)),
+        Err(_) => None,
+    }
+}
+
+pub struct InterruptHandler {
+    controller: ThreadStateController,
+    running: Arc<AtomicBool>,
+    handle: std::thread::JoinHandle<()>,
+}
+
+pub fn with_interrupt_handler<F, R>(f: F) -> R
+where
+    F: FnOnce() -> R,
+{
+    let handler = INTERRUPT_HANDLER.get().unwrap();
+    handler
+        .running
+        .store(true, std::sync::atomic::Ordering::Relaxed);
+
+    handler.handle.thread().unpark();
+
+    let res = (f)();
+
+    handler.controller.resume();
+    handler
+        .running
+        .store(false, std::sync::atomic::Ordering::Relaxed);
+
+    res
+}
+
+static BUFFER_EXTENSION_KEYMAP: Lazy<RwLock<BufferExtensionKeyMap>> = Lazy::new(|| {
+    RwLock::new(BufferExtensionKeyMap {
+        map: HashMap::new(),
+        reverse: HashMap::new(),
+    })
+});
+
+pub static LSP_NOTIFICATION_REGISTRY: Lazy<RwLock<HashMap<(String, String), RootedSteelVal>>> =
+    Lazy::new(|| RwLock::new(HashMap::new()));
+
+fn register_lsp_notification_callback(lsp: String, kind: String, function: SteelVal) {
+    let rooted = function.as_rooted();
+
+    LSP_NOTIFICATION_REGISTRY
+        .write()
+        .unwrap()
+        .insert((lsp, kind), rooted);
+}
+
+pub struct BufferExtensionKeyMap {
+    map: HashMap<String, EmbeddedKeyMap>,
+    reverse: HashMap<usize, String>,
+}
+
+impl BufferExtensionKeyMap {
+    fn get_extension(&self, extension: &str) -> Option<&EmbeddedKeyMap> {
+        self.map.get(extension)
+    }
+
+    fn get_doc_id(&self, id: usize) -> Option<&EmbeddedKeyMap> {
+        self.reverse.get(&id).and_then(|x| self.map.get(x))
+    }
+}
+
+pub fn get_extension_keymap() -> RwLockReadGuard<'static, BufferExtensionKeyMap> {
+    BUFFER_EXTENSION_KEYMAP.read().unwrap()
+}
+
+fn add_extension_or_labeled_keymap(label: String, keymap: EmbeddedKeyMap) {
+    BUFFER_EXTENSION_KEYMAP
+        .write()
+        .unwrap()
+        .map
+        .insert(label, keymap);
+}
+
+fn add_reverse_mapping(key: usize, label: String) {
+    BUFFER_EXTENSION_KEYMAP
+        .write()
+        .unwrap()
+        .reverse
+        .insert(key, label);
+}
+
+fn load_component_api(engine: &mut Engine, generate_sources: bool) {
+    let module = helix_component_module(generate_sources);
+
+    if generate_sources {
+        configure_lsp_builtins("component", &module);
+    }
+
+    engine.register_module(module);
+}
+
+fn load_keymap_api(engine: &mut Engine, generate_sources: bool) {
+    let mut module = BuiltInModule::new("helix/core/keymaps");
+
+    module.register_fn("helix-empty-keymap", empty_keymap);
+    module.register_fn("helix-default-keymap", default_keymap);
+    module.register_fn("helix-merge-keybindings", merge_keybindings);
+    module.register_fn("helix-string->keymap", string_to_embedded_keymap);
+    module.register_fn("keymap?", is_keymap);
+    module.register_fn("helix-deep-copy-keymap", deep_copy_keymap);
+
+    module.register_fn(
+        "#%add-extension-or-labeled-keymap",
+        add_extension_or_labeled_keymap,
+    );
+
+    module.register_fn("#%add-reverse-mapping", add_reverse_mapping);
+
+    // This should be associated with a corresponding scheme module to wrap this up
+    module.register_fn("keymap-update-documentation!", update_documentation);
+
+    if generate_sources {
+        configure_lsp_builtins("keymap", &module)
+    }
+
+    engine.register_module(module);
+}
+
+pub fn format_docstring(doc: &str) -> String {
+    let mut docstring = doc
+        .lines()
+        .map(|x| {
+            let mut line = ";;".to_string();
+            line.push_str(x);
+            line.push_str("\n");
+            line
+        })
+        .collect::<String>();
+
+    docstring.pop();
+
+    docstring
+}
+
+fn load_static_commands(engine: &mut Engine, generate_sources: bool) {
+    let mut module = BuiltInModule::new("helix/core/static");
+
+    let mut builtin_static_command_module = if generate_sources {
+        "(require-builtin helix/core/static as helix.static.)".to_string()
+    } else {
+        "".to_string()
+    };
+
+    for command in TYPABLE_COMMAND_LIST {
+        let func = |cx: &mut Context| {
+            let mut cx = compositor::Context {
+                editor: cx.editor,
+                scroll: None,
+                jobs: cx.jobs,
+            };
+
+            (command.fun)(&mut cx, Args::default(), PromptEvent::Validate)
+        };
+
+        module.register_fn(command.name, func);
+    }
+
+    // Register everything in the static command list as well
+    // These just accept the context, no arguments
+    for command in MappableCommand::STATIC_COMMAND_LIST {
+        if let MappableCommand::Static { name, fun, doc } = command {
+            module.register_fn(name, fun);
+
+            if generate_sources {
+                let docstring = format_docstring(doc);
+
+                builtin_static_command_module.push_str(&format!(
+                    r#"
+(provide {})
+;;@doc
+{}
+(define ({})
+    (helix.static.{} *helix.cx*))
+"#,
+                    name, docstring, name, name
+                ));
+            }
+        }
+    }
+
+    let mut template_function_arity_1 = |name: &str, doc: &str| {
+        if generate_sources {
+            let docstring = format_docstring(doc);
+
+            builtin_static_command_module.push_str(&format!(
+                r#"
+(provide {})
+;;@doc
+{}
+(define ({} arg)
+    (helix.static.{} *helix.cx* arg))
+"#,
+                name, docstring, name, name
+            ));
+        }
+    };
+
+    macro_rules! function1 {
+        ($name:expr, $function:expr, $doc:expr) => {{
+            module.register_fn($name, $function);
+            template_function_arity_1($name, $doc);
+        }};
+    }
+
+    // Adhoc static commands that probably needs evaluating
+    // Arity 1
+    function1!(
+        "insert_char",
+        insert_char,
+        "Insert a given character at the cursor cursor position"
+    );
+    function1!(
+        "insert_string",
+        insert_string,
+        "Insert a given string at the current cursor position"
+    );
+
+    function1!(
+        "set-current-selection-object!",
+        set_selection,
+        "Update the selection object to the current selection within the editor"
+    );
+
+    function1!(
+        "regex-selection",
+        regex_selection,
+        "Run the given regex within the existing buffer"
+    );
+
+    function1!(
+        "replace-selection-with",
+        replace_selection,
+        "Replace the existing selection with the given string"
+    );
+
+    function1!(
+        "cx->current-file",
+        current_path,
+        "Get the currently focused file path"
+    );
+
+    function1!(
+        "enqueue-expression-in-engine",
+        run_expression_in_engine,
+        "Enqueue an expression to run at the top level context, 
+        after the existing function context has exited."
+    );
+
+    let mut template_function_arity_0 = |name: &str, doc: &str| {
+        if generate_sources {
+            let docstring = format_docstring(doc);
+
+            builtin_static_command_module.push_str(&format!(
+                r#"
+(provide {})
+;;@doc
+{}
+(define ({})
+    (helix.static.{} *helix.cx*))
+"#,
+                name, docstring, name, name
+            ));
+        }
+    };
+
+    macro_rules! function0 {
+        ($name:expr, $function:expr, $doc:expr) => {{
+            module.register_fn($name, $function);
+            template_function_arity_0($name, $doc);
+        }};
+    }
+
+    function0!(
+        "current_selection",
+        get_selection,
+        "Returns the current selection as a string"
+    );
+    function0!("load-buffer!", load_buffer, "Evaluates the current buffer");
+    function0!(
+        "current-highlighted-text!",
+        get_highlighted_text,
+        "Returns the currently highlighted text as a string"
+    );
+    function0!(
+        "get-current-line-number",
+        current_line_number,
+        "Returns the current line number"
+    );
+    function0!(
+        "current-selection-object",
+        current_selection,
+        "Returns the current selection object"
+    );
+    function0!(
+        "get-helix-cwd",
+        get_helix_cwd,
+        "Returns the current working directly that helix is using"
+    );
+    function0!(
+        "move-window-far-left",
+        move_window_to_the_left,
+        "Moves the current window to the far left"
+    );
+    function0!(
+        "move-window-far-right",
+        move_window_to_the_right,
+        "Moves the current window to the far right"
+    );
+
+    let mut template_function_no_context = |name: &str, doc: &str| {
+        if generate_sources {
+            let docstring = format_docstring(doc);
+
+            builtin_static_command_module.push_str(&format!(
+                r#"
+(provide {})
+;;@doc
+{}
+(define {} helix.static.{})                
+            "#,
+                name, docstring, name, name
+            ))
+        }
+    };
+
+    macro_rules! no_context {
+        ($name:expr, $function:expr, $doc:expr) => {{
+            module.register_fn($name, $function);
+            template_function_no_context($name, $doc);
+        }};
+    }
+
+    no_context!(
+        "selection->primary-index",
+        |sel: Selection| sel.primary_index(),
+        "Returns index of the primary selection"
+    );
+    no_context!(
+        "selection->primary-range",
+        |sel: Selection| sel.primary(),
+        "Returns the range for primary selection"
+    );
+    no_context!(
+        "selection->ranges",
+        |sel: Selection| sel.ranges().to_vec(),
+        "Returns all ranges of the selection"
+    );
+    no_context!(
+        "range-anchor",
+        |range: Range| range.anchor,
+        "Get the anchor of the range: the side that doesn't move when extending."
+    );
+    no_context!(
+        "range->from",
+        |range: Range| range.from(),
+        "Get the start of the range"
+    );
+    no_context!(
+        "range-head",
+        |range: Range| range.head,
+        "Get the head of the range, moved when extending."
+    );
+    no_context!(
+        "range->to",
+        |range: Range| range.to(),
+        "Get the end of the range"
+    );
+    no_context!(
+        "range->span",
+        |range: Range| (range.from(), range.to()),
+        "Get the span of the range (from, to)"
+    );
+
+    no_context!(
+        "range",
+        Range::new,
+        r#"Construct a new range object
+
+```scheme
+(range anchor head) -> Range?
+```
+        "#
+    );
+    no_context!(
+        "range->selection",
+        |range: Range| Selection::from(range),
+        "Convert a range into a selection"
+    );
+
+    module.register_fn("get-helix-scm-path", get_helix_scm_path);
+    module.register_fn("get-init-scm-path", get_init_scm_path);
+
+    template_function_no_context(
+        "get-helix-scm-path",
+        "Returns the path to the helix.scm file as a string",
+    );
+    template_function_no_context(
+        "get-init-scm-path",
+        "Returns the path to the init.scm file as a string",
+    );
+
+    if generate_sources {
+        if let Some(mut target_directory) = alternative_runtime_search_path() {
+            if !target_directory.exists() {
+                std::fs::create_dir_all(&target_directory).unwrap();
+            }
+
+            target_directory.push("static.scm");
+
+            std::fs::write(target_directory, &builtin_static_command_module).unwrap();
+        }
+
+        engine.register_steel_module(
+            "helix/static.scm".to_string(),
+            builtin_static_command_module,
+        );
+    }
+
+    if generate_sources {
+        configure_lsp_builtins("static", &module);
+    }
+
+    engine.register_module(module);
+}
+
+fn load_typed_commands(engine: &mut Engine, generate_sources: bool) {
+    let mut module = BuiltInModule::new("helix/core/typable".to_string());
+
+    let mut builtin_typable_command_module = if generate_sources {
+        "(require-builtin helix/core/typable as helix.)".to_string()
+    } else {
+        "".to_string()
+    };
+
+    // Register everything in the typable command list. Now these are all available
+    for command in TYPABLE_COMMAND_LIST {
+        // TODO: This needs to get updated
+        let func = |cx: &mut Context, args: &[Cow<str>]| {
+            let mut cx = compositor::Context {
+                editor: cx.editor,
+                scroll: None,
+                jobs: cx.jobs,
+            };
+
+            (command.fun)(&mut cx, Args::raw(args.to_vec()), PromptEvent::Validate)
+        };
+
+        module.register_fn(command.name, func);
+
+        if generate_sources {
+            // Create an ephemeral builtin module to reference until I figure out how
+            // to wrap the functions with a reference to the engine context better.
+            builtin_typable_command_module.push_str(&format!(
+                r#"
+(provide {})
+
+;;@doc
+{}
+(define ({} . args)
+    (helix.{} *helix.cx* args))
+"#,
+                command.name,
+                format_docstring(command.doc),
+                command.name,
+                command.name
+            ));
+        }
+    }
+
+    if generate_sources {
+        if let Some(mut target_directory) = alternative_runtime_search_path() {
+            if !target_directory.exists() {
+                std::fs::create_dir_all(&target_directory).unwrap();
+            }
+
+            target_directory.push("commands.scm");
+
+            std::fs::write(target_directory, &builtin_typable_command_module).unwrap();
+        }
+
+        engine.register_steel_module(
+            "helix/commands.scm".to_string(),
+            builtin_typable_command_module,
+        );
+    }
+
+    if generate_sources {
+        configure_lsp_builtins("typed", &module);
+    }
+
+    engine.register_module(module);
+}
+
+fn get_option_value(cx: &mut Context, option: String) -> anyhow::Result<SteelVal> {
+    let key_error = || anyhow::anyhow!("Unknown key `{}`", option);
+
+    let config = serde_json::json!(std::ops::Deref::deref(&cx.editor.config()));
+    let pointer = format!("/{}", option.replace('.', "/"));
+    let value = config.pointer(&pointer).ok_or_else(key_error)?;
+    Ok(value.to_owned().into_steelval().unwrap())
+}
+
+// File picker configurations
+fn fp_hidden(config: &mut FilePickerConfig, option: bool) {
+    config.hidden = option;
+}
+
+fn fp_follow_symlinks(config: &mut FilePickerConfig, option: bool) {
+    config.follow_symlinks = option;
+}
+
+fn fp_deduplicate_links(config: &mut FilePickerConfig, option: bool) {
+    config.deduplicate_links = option;
+}
+
+fn fp_parents(config: &mut FilePickerConfig, option: bool) {
+    config.parents = option;
+}
+
+fn fp_ignore(config: &mut FilePickerConfig, option: bool) {
+    config.ignore = option;
+}
+
+fn fp_git_ignore(config: &mut FilePickerConfig, option: bool) {
+    config.git_ignore = option;
+}
+
+fn fp_git_global(config: &mut FilePickerConfig, option: bool) {
+    config.git_global = option;
+}
+
+fn fp_git_exclude(config: &mut FilePickerConfig, option: bool) {
+    config.git_exclude = option;
+}
+
+fn fp_max_depth(config: &mut FilePickerConfig, option: Option<usize>) {
+    config.max_depth = option;
+}
+
+// Soft wrap configurations
+fn sw_enable(config: &mut SoftWrap, option: Option<bool>) {
+    config.enable = option;
+}
+
+fn sw_max_wrap(config: &mut SoftWrap, option: Option<u16>) {
+    config.max_wrap = option;
+}
+
+fn sw_max_indent_retain(config: &mut SoftWrap, option: Option<u16>) {
+    config.max_indent_retain = option;
+}
+
+fn sw_wrap_indicator(config: &mut SoftWrap, option: Option<String>) {
+    config.wrap_indicator = option;
+}
+
+fn wrap_at_text_width(config: &mut SoftWrap, option: Option<bool>) {
+    config.wrap_at_text_width = option;
+}
+
+// Attempt to fuss with the configuration?
+fn dynamic_set_option(
+    configuration: &HelixConfiguration,
+    key: String,
+    value: SteelVal,
+) -> anyhow::Result<()> {
+    let key = key.to_lowercase();
+
+    let key_error = || anyhow::anyhow!("Unknown key `{}`", key);
+
+    // let mut config = serde_json::json!(&cx.editor.config().deref());
+    let mut config = serde_json::json!(configuration.load_config().editor);
+    let pointer = format!("/{}", key.replace('.', "/"));
+    let jvalue = config.pointer_mut(&pointer).ok_or_else(key_error)?;
+
+    let cloned = value.clone();
+    let field_error = move |_| anyhow::anyhow!("Could not parse field `{}`", cloned);
+    *jvalue = serde_json::Value::try_from(value)?;
+
+    let config = serde_json::from_value(config).map_err(field_error)?;
+
+    let mut new_config = configuration.load_config();
+    new_config.editor = config;
+
+    configuration.store_config(new_config);
+
+    Ok(())
+}
+
+fn load_configuration_api(engine: &mut Engine, generate_sources: bool) {
+    let mut module = BuiltInModule::new("helix/core/configuration");
+
+    module.register_fn(
+        "register-lsp-notification-handler",
+        register_lsp_notification_callback,
+    );
+
+    module.register_fn("update-configuration!", |ctx: &mut Context| {
+        ctx.editor
+            .config_events
+            .0
+            .send(ConfigEvent::Change)
+            .unwrap();
+    });
+
+    module.register_fn("get-config-option-value", get_option_value);
+
+    module.register_fn("set-configuration-for-file!", set_configuration_for_file);
+
+    module
+        .register_fn(
+            "get-language-config",
+            HelixConfiguration::get_language_config,
+        )
+        // .register_fn(
+        //     "get-language-config-by-filename",
+        //     HelixConfiguration::get_individual_language_config_for_filename,
+        // )
+        .register_fn(
+            "set-language-config!",
+            HelixConfiguration::update_individual_language_config,
+        );
+
+    module.register_fn(
+        "set-lsp-config!",
+        HelixConfiguration::update_language_server_config,
+    );
+
+    module.register_fn(
+        "update-language-config!",
+        HelixConfiguration::update_language_config,
+    );
+
+    module.register_fn(
+        "refresh-all-language-configs!",
+        update_configuration_for_all_open_documents,
+    );
+
+    module
+        .register_fn("raw-cursor-shape", || CursorShapeConfig::default())
+        .register_fn(
+            "raw-cursor-shape-set!",
+            |value: SteelVal, mode: String, shape: String| -> anyhow::Result<SteelVal> {
+                let mut config = CursorShapeConfig::as_mut_ref(&value)?;
+
+                let mode = match mode.as_str() {
+                    "normal" => Mode::Normal,
+                    "select" => Mode::Select,
+                    "insert" => Mode::Insert,
+                    _ => anyhow::bail!("Unable to match mode from string: {}", mode),
+                };
+
+                let kind = match shape.as_str() {
+                    "block" => CursorKind::Block,
+                    "bar" => CursorKind::Bar,
+                    "underline" => CursorKind::Underline,
+                    "hidden" => CursorKind::Hidden,
+                    _ => anyhow::bail!("Unable to match cursor kind from string: {}", shape),
+                };
+
+                config.update(mode, kind);
+                drop(config);
+                Ok(value)
+            },
+        );
+
+    module
+        .register_fn("raw-file-picker", || FilePickerConfig::default())
+        .register_fn("register-file-picker", HelixConfiguration::file_picker)
+        .register_fn("fp-hidden", fp_hidden)
+        .register_fn("fp-follow-symlinks", fp_follow_symlinks)
+        .register_fn("fp-deduplicate-links", fp_deduplicate_links)
+        .register_fn("fp-parents", fp_parents)
+        .register_fn("fp-ignore", fp_ignore)
+        .register_fn("fp-git-ignore", fp_git_ignore)
+        .register_fn("fp-git-global", fp_git_global)
+        .register_fn("fp-git-exclude", fp_git_exclude)
+        .register_fn("fp-max-depth", fp_max_depth);
+
+    module
+        .register_fn("raw-soft-wrap", || SoftWrap::default())
+        .register_fn("register-soft-wrap", HelixConfiguration::soft_wrap)
+        .register_fn("sw-enable", sw_enable)
+        .register_fn("sw-max-wrap", sw_max_wrap)
+        .register_fn("sw-max-indent-retain", sw_max_indent_retain)
+        .register_fn("sw-wrap-indicator", sw_wrap_indicator)
+        .register_fn("sw-wrap-at-text-width", wrap_at_text_width);
+
+    module
+        .register_fn("scrolloff", HelixConfiguration::scrolloff)
+        .register_fn("scroll_lines", HelixConfiguration::scroll_lines)
+        .register_fn("mouse", HelixConfiguration::mouse)
+        .register_fn("shell", HelixConfiguration::shell)
+        .register_fn("line-number", HelixConfiguration::line_number)
+        .register_fn("cursorline", HelixConfiguration::cursorline)
+        .register_fn("cursorcolumn", HelixConfiguration::cursorcolumn)
+        .register_fn("middle-click-paste", HelixConfiguration::middle_click_paste)
+        .register_fn("auto-pairs", HelixConfiguration::auto_pairs)
+        // Specific constructors for the auto pairs configuration
+        .register_fn("auto-pairs-default", |enabled: bool| {
+            AutoPairConfig::Enable(enabled)
+        })
+        .register_fn("auto-pairs-map", |map: HashMap<char, char>| {
+            AutoPairConfig::Pairs(map)
+        })
+        // TODO: Finish this up
+        .register_fn("auto-save-default", || AutoSave::default())
+        .register_fn(
+            "auto-save-after-delay-enable",
+            HelixConfiguration::auto_save_after_delay_enable,
+        )
+        .register_fn(
+            "inline-diagnostics-cursor-line-enable",
+            HelixConfiguration::inline_diagnostics_cursor_line_enable,
+        )
+        .register_fn(
+            "inline-diagnostics-end-of-line-enable",
+            HelixConfiguration::inline_diagnostics_end_of_line_enable,
+        )
+        .register_fn("auto-completion", HelixConfiguration::auto_completion)
+        .register_fn("auto-format", HelixConfiguration::auto_format)
+        .register_fn("auto-save", HelixConfiguration::auto_save)
+        .register_fn("text-width", HelixConfiguration::text_width)
+        .register_fn("idle-timeout", HelixConfiguration::idle_timeout)
+        .register_fn("completion-timeout", HelixConfiguration::completion_timeout)
+        .register_fn(
+            "preview-completion-insert",
+            HelixConfiguration::preview_completion_insert,
+        )
+        .register_fn(
+            "completion-trigger-len",
+            HelixConfiguration::completion_trigger_len,
+        )
+        .register_fn("completion-replace", HelixConfiguration::completion_replace)
+        .register_fn("auto-info", HelixConfiguration::auto_info)
+        .register_fn("#%raw-cursor-shape", HelixConfiguration::cursor_shape)
+        .register_fn("true-color", HelixConfiguration::true_color)
+        .register_fn(
+            "insert-final-newline",
+            HelixConfiguration::insert_final_newline,
+        )
+        .register_fn("color-modes", HelixConfiguration::color_modes)
+        .register_fn("gutters", HelixConfiguration::gutters)
+        // .register_fn("file-picker", HelixConfiguration::file_picker)
+        .register_fn("statusline", HelixConfiguration::statusline)
+        .register_fn("undercurl", HelixConfiguration::undercurl)
+        .register_fn("search", HelixConfiguration::search)
+        .register_fn("lsp", HelixConfiguration::lsp)
+        .register_fn("terminal", HelixConfiguration::terminal)
+        .register_fn("rulers", HelixConfiguration::rulers)
+        .register_fn("whitespace", HelixConfiguration::whitespace)
+        .register_fn("bufferline", HelixConfiguration::bufferline)
+        .register_fn("indent-guides", HelixConfiguration::indent_guides)
+        .register_fn(
+            "workspace-lsp-roots",
+            HelixConfiguration::workspace_lsp_roots,
+        )
+        .register_fn(
+            "default-line-ending",
+            HelixConfiguration::default_line_ending,
+        )
+        .register_fn("smart-tab", HelixConfiguration::smart_tab);
+
+    // Keybinding stuff
+    module
+        .register_fn("keybindings", HelixConfiguration::keybindings)
+        .register_fn("get-keybindings", HelixConfiguration::get_keybindings)
+        .register_fn("set-option!", dynamic_set_option);
+
+    if generate_sources {
+        let mut builtin_configuration_module =
+            r#"(require-builtin helix/core/configuration as helix.)
+
+(provide register-lsp-notification-handler)
+
+;;@doc
+;; Register a callback to be called on LSP notifications sent from the server -> client
+;; that aren't currently handled by Helix as a built in.
+;;
+;; ```scheme
+;; (register-lsp-notification-handler lsp-name event-name handler)
+;; ```
+;;
+;; * lsp-name : string?
+;; * event-name : string?
+;; * function : (-> hash? any?) ;; Function where the first argument is the parameters
+;;
+;; # Examples
+;; ```
+;; (register-lsp-notification-handler "dart"
+;;                                    "dart/textDocument/publishClosingLabels"
+;;                                    (lambda (args) (displayln args)))
+;; ```
+(define register-lsp-notification-handler helix.register-lsp-notification-handler)
+
+(provide set-option!)
+(define (set-option! key value)
+    (helix.set-option! *helix.config* key value))
+                
+(provide define-lsp)
+(define-syntax define-lsp
+  (syntax-rules (#%crunch #%name #%conf)
+    ;; Other generic keys
+    [(_ #%crunch #%name name #%conf conf (key (inner-key value) ...))
+     (set-lsp-config! name
+                      (hash-insert conf
+                                   (quote key)
+                                   (transduce (list (list (quote inner-key) value) ...)
+                                              (into-hashmap))))]
+
+    [(_ #%crunch #%name name #%conf conf (key (inner-key value) ...) remaining ...)
+     ;  ;; Crunch the remaining stuff
+     (define-lsp #%crunch
+          #%name
+          name
+          #%conf
+          (hash-insert conf
+                       (quote key)
+                       (transduce (list (list (quote inner-key) value) ...) (into-hashmap)))
+          remaining ...)]
+
+    ;; Other generic keys
+    [(_ #%crunch #%name name #%conf conf (key value))
+     (set-lsp-config! name (hash-insert conf (quote key) value))]
+
+    [(_ #%crunch #%name name #%conf conf (key value) remaining ...)
+     ;  ;; Crunch the remaining stuff
+     (define-lsp #%crunch #%name name #%conf (hash-insert conf (quote key) value) remaining ...)]
+
+    [(_ name (key value ...) ...)
+     (define-lsp #%crunch #%name name #%conf (hash "name" name) (key value ...) ...)]
+
+    [(_ name (key value)) (define-lsp #%crunch #%name name #%conf (hash "name" name) (key value))]
+
+    [(_ name (key value) ...) (define-lsp #%crunch #%name name #%conf (hash "name" name) (key value) ...)]))
+
+(provide define-language)
+(define-syntax define-language
+  (syntax-rules (#%crunch #%name #%conf)
+
+    ;; Other generic keys
+    [(_ #%crunch #%name name #%conf conf (key (inner-key value) ...))
+     (update-language-config! name
+                              (hash-insert conf
+                                           (quote key)
+                                           (transduce (list (list (quote inner-key) value) ...)
+                                                      (into-hashmap))))]
+
+    [(_ #%crunch #%name name #%conf conf (key (inner-key value) ...) remaining ...)
+     ;  ;; Crunch the remaining stuff
+     (define-language #%crunch
+               #%name
+               name
+               #%conf
+               (hash-insert conf
+                            (quote key)
+                            (transduce (list (list (quote inner-key) value) ...) (into-hashmap)))
+               remaining ...)]
+
+    ;; Other generic keys
+    [(_ #%crunch #%name name #%conf conf (key value))
+     (update-language-config! name (hash-insert conf (quote key) value))]
+
+    [(_ #%crunch #%name name #%conf conf (key value) remaining ...)
+     ;  ;; Crunch the remaining stuff
+     (define-language #%crunch #%name name #%conf (hash-insert conf (quote key) value) remaining ...)]
+
+    [(_ name (key value ...) ...)
+     (define-language #%crunch #%name name #%conf (hash "name" name) (key value ...) ...)]
+
+    [(_ name (key value)) (language #%crunch #%name name #%conf (hash "name" name) (key value))]
+
+    [(_ name (key value) ...)
+     (define-language #%crunch #%name name #%conf (hash "name" name) (key value) ...)]))
+"#
+            .to_string();
+
+        builtin_configuration_module.push_str(
+            r#"
+(provide cursor-shape)
+;;@doc
+;; Shape for cursor in each mode
+;;
+;; (cursor-shape #:normal (normal 'block)
+;;               #:select (select 'block)
+;;               #:insert (insert 'block))
+;;
+;; # Examples
+;; 
+;; ```scheme
+;; (cursor-shape #:normal 'block #:select 'underline #:insert 'bar)
+;; ```
+(define (cursor-shape #:normal (normal 'block)
+                      #:select (select 'block)
+                      #:insert (insert 'block))
+    (define cursor-shape-config (helix.raw-cursor-shape))
+    (helix.raw-cursor-shape-set! cursor-shape-config 'normal normal)
+    (helix.raw-cursor-shape-set! cursor-shape-config 'select select)
+    (helix.raw-cursor-shape-set! cursor-shape-config 'insert insert)
+    (helix.#%raw-cursor-shape *helix.config* cursor-shape-config))                
+            "#,
+        );
+
+        builtin_configuration_module.push_str(
+            r#"
+(provide refresh-all-language-configs!)
+(define (refresh-all-language-configs!)
+    (helix.refresh-all-language-configs! *helix.cx*))
+            "#,
+        );
+
+        builtin_configuration_module.push_str(&format!(
+            r#"
+(provide update-configuration!)
+(define (update-configuration!)
+    (helix.update-configuration! *helix.config*))
+"#,
+        ));
+
+        builtin_configuration_module.push_str(&format!(
+            r#"
+(provide get-config-option-value)
+(define (get-config-option-value arg)
+    (helix.get-config-option-value *helix.cx* arg))
+"#,
+        ));
+
+        builtin_configuration_module.push_str(&format!(
+            r#"
+(provide set-configuration-for-file!)
+(define (set-configuration-for-file! path config)
+    (helix.set-configuration-for-file! *helix.cx* path config))
+"#,
+        ));
+
+        builtin_configuration_module.push_str(
+            r#"
+(provide set-lsp-config!)
+;;@doc
+;; Sets the language server config for a specific language server.
+;;
+;; ```scheme
+;; (set-lsp-config! lsp config)
+;; ```
+;; * lsp : string?
+;; * config: hash?
+;;
+;; This will overlay the existing configuration, much like the existing
+;; toml definition does.
+;;
+;; Available options for the config hash are:
+;; ```scheme
+;; (hash "command" "<command>"
+;;       "args" (list "args" ...)
+;;       "environment" (hash "ENV" "VAR" ...)
+;;       "config" (hash ...)
+;;       "timeout" 100 ;; number
+;;       "required-root-patterns" (listof "pattern" ...))
+;;
+;; ```
+;;
+;; # Examples
+;; ```
+;; (set-lsp-config! "jdtls"
+;;    (hash "args" (list "-data" "/home/matt/code/java-scratch/workspace")))
+;; ```
+(define (set-lsp-config! lsp config)
+    (helix.set-lsp-config! *helix.config* lsp config))
+"#,
+        );
+
+        builtin_configuration_module.push_str(
+            r#"
+(provide update-language-config!)
+(define (update-language-config! lsp config)
+    (helix.update-language-config! *helix.config* lsp config)
+    (refresh-all-language-configs!))
+"#,
+        );
+
+        // Register the get keybindings function
+        builtin_configuration_module.push_str(&format!(
+            r#"
+(provide get-keybindings)
+(define (get-keybindings)
+    (helix.get-keybindings *helix.config*))
+"#,
+        ));
+
+        let mut template_soft_wrap = |name: &str| {
+            builtin_configuration_module.push_str(&format!(
+                r#"
+(provide {})
+(define ({} arg)
+    (lambda (picker) 
+            (helix.{} picker arg)
+            picker))
+"#,
+                name, name, name
+            ));
+        };
+
+        let soft_wrap_functions = &[
+            "sw-enable",
+            "sw-max-wrap",
+            "sw-max-indent-retain",
+            "sw-wrap-indicator",
+            "sw-wrap-at-text-width",
+        ];
+
+        for name in soft_wrap_functions {
+            template_soft_wrap(name);
+        }
+
+        let mut template_file_picker_function = |name: &str| {
+            builtin_configuration_module.push_str(&format!(
+                r#"
+(provide {})
+(define ({} arg)
+    (lambda (picker) 
+            (helix.{} picker arg)
+            picker))
+"#,
+                name, name, name
+            ));
+        };
+
+        let file_picker_functions = &[
+            "fp-hidden",
+            "fp-follow-symlinks",
+            "fp-deduplicate-links",
+            "fp-parents",
+            "fp-ignore",
+            "fp-git-ignore",
+            "fp-git-global",
+            "fp-git-exclude",
+            "fp-max-depth",
+        ];
+
+        for name in file_picker_functions {
+            template_file_picker_function(name);
+        }
+
+        builtin_configuration_module.push_str(
+            r#"
+(provide file-picker-kw)
+;;@doc
+;; Sets the configuration for the file picker using keywords.
+;;
+;; ```scheme
+;; (file-picker-kw #:hidden #t
+;;                 #:follow-symlinks #t
+;;                 #:deduplicate-links #t
+;;                 #:parents #t
+;;                 #:ignore #t
+;;                 #:git-ignore #t
+;;                 #:git-exclude #t
+;;                 #:git-global #t
+;;                 #:max-depth #f) ;; Expects either #f or an int?
+;; ```
+;; By default, max depth is `#f` while everything else is an int?
+;;
+;; To use this, call this in your `init.scm` or `helix.scm`:
+;;
+;; # Examples
+;; ```scheme
+;; (file-picker-kw #:hidden #f)
+;; ```
+(define (file-picker-kw
+            #:hidden [hidden #t]
+            #:follow-symlinks [follow-symlinks #t]
+            #:deduplicate-links [deduplicate-links #t]
+            #:parents [parents #t]
+            #:ignore [ignore #t]
+            #:git-ignore [git-ignore #t]
+            #:git-global [git-global #t]
+            #:git-exclude [git-exclude #t]
+            #:max-depth [max-depth #f])
+
+    (define picker (helix.raw-file-picker))
+    (unless hidden (helix.fp-hidden picker hidden))
+    (unless follow-symlinks (helix.fp-follow-symlinks picker follow-symlinks))
+    (unless deduplicate-links (helix.fp-deduplicate-links picker deduplicate-links))
+    (unless parents (helix.fp-parents picker parents))
+    (unless ignore (helix.fp-ignore picker ignore))
+    (unless git-ignore (helix.fp-git-ignore picker git-ignore))
+    (unless git-global (helix.fp-git-global picker git-global))
+    (unless git-exclude (helix.fp-git-exclude picker git-exclude))
+    (when max-depth (helix.fp-max-depth picker max-depth))
+    (helix.register-file-picker *helix.config* picker))
+            "#,
+        );
+
+        builtin_configuration_module.push_str(&format!(
+            r#"
+(provide file-picker)
+;;@doc
+;; Sets the configuration for the file picker using var args.
+;;
+;; ```scheme
+;; (file-picker . args)
+;; ```
+;;
+;; The args are expected to be something of the value:
+;; ```scheme
+;; (-> FilePickerConfiguration? bool?)    
+;; ```
+;;
+;; These other functions in this module which follow this behavior are all
+;; prefixed `fp-`, and include:
+;;
+;; * fp-hidden
+;; * fp-follow-symlinks
+;; * fp-deduplicate-links
+;; * fp-parents
+;; * fp-ignore
+;; * fp-git-ignore
+;; * fp-git-global
+;; * fp-git-exclude
+;; * fp-max-depth
+;; 
+;; By default, max depth is `#f` while everything else is an int?
+;;
+;; To use this, call this in your `init.scm` or `helix.scm`:
+;;
+;; # Examples
+;; ```scheme
+;; (file-picker (fp-hidden #f) (fp-parents #f))
+;; ```
+(define (file-picker . args)
+    (helix.register-file-picker
+        *helix.config*
+        (foldl (lambda (func config) (func config)) (helix.raw-file-picker) args)))
+"#,
+        ));
+
+        builtin_configuration_module.push_str(&format!(
+            r#"
+(provide soft-wrap-kw)
+;;@doc
+;; Sets the configuration for soft wrap using keyword args.
+;;
+;; ```scheme
+;; (soft-wrap-kw #:enable #f
+;;               #:max-wrap 20
+;;               #:max-indent-retain 40
+;;               #:wrap-indicator "↪"
+;;               #:wrap-at-text-width #f)
+;; ```
+;;
+;; The options are as follows:
+;;
+;; * #:enable:
+;;   Soft wrap lines that exceed viewport width. Default to off
+;; * #:max-wrap:
+;;   Maximum space left free at the end of the line.
+;;   This space is used to wrap text at word boundaries. If that is not possible within this limit
+;;   the word is simply split at the end of the line.
+;;
+;;   This is automatically hard-limited to a quarter of the viewport to ensure correct display on small views.
+;;
+;;   Default to 20
+;; * #:max-indent-retain
+;;   Maximum number of indentation that can be carried over from the previous line when softwrapping.
+;;   If a line is indented further then this limit it is rendered at the start of the viewport instead.
+;;
+;;   This is automatically hard-limited to a quarter of the viewport to ensure correct display on small views.
+;; 
+;;   Default to 40
+;; * #:wrap-indicator
+;;   Indicator placed at the beginning of softwrapped lines
+;; 
+;;   Defaults to ↪
+;; * #:wrap-at-text-width
+;;   Softwrap at `text_width` instead of viewport width if it is shorter
+;; 
+;; # Examples
+;; ```scheme
+;; (soft-wrap-kw #:sw-enable #t)
+;; ```
+(define (soft-wrap-kw #:enable [enable #f]
+                      #:max-wrap [max-wrap 20]
+                      #:max-indent-retain [max-indent-retain 40]
+                      #:wrap-indicator [wrap-indicator 4]
+                      #:wrap-at-text-width [wrap-at-text-width #f])
+    (define sw (helix.raw-soft-wrap))
+    (helix.sw-enable sw enable)
+    (helix.sw-max-wrap sw max-wrap)
+    (helix.sw-max-indent-retain sw max-indent-retain)
+    (helix.sw-wrap-indicator sw wrap-indicator)
+    (helix.sw-wrap-at-text-width sw wrap-at-text-width)
+    (helix.register-soft-wrap *helix.config* sw))
+"#,
+        ));
+
+        builtin_configuration_module.push_str(&format!(
+            r#"
+
+(provide soft-wrap)
+;;@doc
+;; Sets the configuration for soft wrap using var args.
+;;
+;; ```scheme
+;; (soft-wrap . args)
+;; ```
+;;
+;; The args are expected to be something of the value:
+;; ```scheme
+;; (-> SoftWrapConfiguration? bool?)    
+;; ```
+;; The options are as follows:
+;;
+;; * sw-enable:
+;;   Soft wrap lines that exceed viewport width. Default to off
+;; * sw-max-wrap:
+;;   Maximum space left free at the end of the line.
+;;   This space is used to wrap text at word boundaries. If that is not possible within this limit
+;;   the word is simply split at the end of the line.
+;;
+;;   This is automatically hard-limited to a quarter of the viewport to ensure correct display on small views.
+;;
+;;   Default to 20
+;; * sw-max-indent-retain
+;;   Maximum number of indentation that can be carried over from the previous line when softwrapping.
+;;   If a line is indented further then this limit it is rendered at the start of the viewport instead.
+;;
+;;   This is automatically hard-limited to a quarter of the viewport to ensure correct display on small views.
+;; 
+;;   Default to 40
+;; * sw-wrap-indicator
+;;   Indicator placed at the beginning of softwrapped lines
+;; 
+;;   Defaults to ↪
+;; * sw-wrap-at-text-width
+;;   Softwrap at `text_width` instead of viewport width if it is shorter
+;;
+;; # Examples
+;; ```scheme
+;; (soft-wrap (sw-enable #t))
+;; ```
+(define (soft-wrap . args)
+    (helix.register-soft-wrap
+        *helix.config*
+        (foldl (lambda (func config) (func config)) (helix.raw-soft-wrap) args)))
+"#,
+        ));
+
+        let mut template_function_arity_1 = |name: &str, doc: &str| {
+            let doc = format_docstring(doc);
+            builtin_configuration_module.push_str(&format!(
+                r#"
+(provide {})
+;;@doc
+;;{}
+(define ({} arg)
+    (helix.{} *helix.config* arg))
+"#,
+                name, doc, name, name
+            ));
+        };
+
+        let functions = &[
+            ("scrolloff", "Padding to keep between the edge of the screen and the cursor when scrolling. Defaults to 5."),
+            ("scroll_lines", "Number of lines to scroll at once. Defaults to 3
+"),
+            ("mouse", "Mouse support. Defaults to true."),
+            ("shell", r#"Shell to use for shell commands. Defaults to ["cmd", "/C"] on Windows and ["sh", "-c"] otherwise."#),
+            ("line-number", "Line number mode."),
+            ("cursorline", "Highlight the lines cursors are currently on. Defaults to false"),
+            ("cursorcolumn", "Highlight the columns cursors are currently on. Defaults to false"),
+            ("middle-click-paste", "Middle click paste support. Defaults to true"),
+            ("auto-pairs", r#"
+Automatic insertion of pairs to parentheses, brackets,
+etc. Optionally, this can be a list of 2-tuples to specify a
+global list of characters to pair. Defaults to true."#),
+            ("auto-completion", "Automatic auto-completion, automatically pop up without user trigger. Defaults to true."),
+            // TODO: Put in path_completion
+            ("auto-format", "Automatic formatting on save. Defaults to true."),
+            ("auto-save", r#"Automatic save on focus lost and/or after delay.
+Time delay in milliseconds since last edit after which auto save timer triggers.
+Time delay defaults to false with 3000ms delay. Focus lost defaults to false.
+                "#),
+            ("text-width", "Set a global text_width"),
+            ("idle-timeout", r#"Time in milliseconds since last keypress before idle timers trigger.
+Used for various UI timeouts. Defaults to 250ms."#),
+            ("completion-timeout", r#"
+Time in milliseconds after typing a word character before auto completions
+are shown, set to 5 for instant. Defaults to 250ms.
+                "#),
+            ("preview-completion-insert", "Whether to insert the completion suggestion on hover. Defaults to true."),
+            ("completion-trigger-len", "Length to trigger completions"),
+            ("completion-replace", r#"Whether to instruct the LSP to replace the entire word when applying a completion
+ or to only insert new text
+"#),
+            ("auto-info", "Whether to display infoboxes. Defaults to true."),
+            // ("cursor-shape", "Shape for cursor in each mode"),
+            ("true-color", "Set to `true` to override automatic detection of terminal truecolor support in the event of a false negative. Defaults to `false`."),
+            ("insert-final-newline", "Whether to automatically insert a trailing line-ending on write if missing. Defaults to `true`"),
+            ("color-modes", "Whether to color modes with different colors. Defaults to `false`."),
+            ("gutters", "Gutter configuration"),
+            ("statusline", "Configuration of the statusline elements"),
+            ("undercurl", "Set to `true` to override automatic detection of terminal undercurl support in the event of a false negative. Defaults to `false`."),
+            ("search", "Search configuration"),
+            ("lsp", "Lsp config"),
+            ("terminal", "Terminal config"),
+            ("rulers", "Column numbers at which to draw the rulers. Defaults to `[]`, meaning no rulers"),
+            ("whitespace", "Whitespace config"),
+            ("bufferline", "Persistently display open buffers along the top"),
+            ("indent-guides", "Vertical indent width guides"),
+            ("workspace-lsp-roots", "Workspace specific lsp ceiling dirs"),
+            ("default-line-ending", "Which line ending to choose for new documents. Defaults to `native`. i.e. `crlf` on Windows, otherwise `lf`."),
+            ("smart-tab", "Enables smart tab"),
+            ("keybindings", "Keybindings config"),
+            ("inline-diagnostics-cursor-line-enable", "Inline diagnostics cursor line"),
+            ("inline-diagnostics-end-of-line-enable", "Inline diagnostics end of line"),
+            // language configuration functions
+            ("get-language-config", "Get the configuration for a specific language"),
+            // ("get-language-config-by-filename", "Get the language configuration for a specific file"),
+            ("set-language-config!", "Set the language configuration"),
+        ];
+
+        for (func, doc) in functions {
+            template_function_arity_1(func, doc);
+        }
+
+        if let Some(mut target_directory) = alternative_runtime_search_path() {
+            if !target_directory.exists() {
+                std::fs::create_dir_all(&target_directory).unwrap();
+            }
+
+            target_directory.push("configuration.scm");
+
+            std::fs::write(target_directory, &builtin_configuration_module).unwrap();
+        }
+
+        engine.register_steel_module(
+            "helix/configuration.scm".to_string(),
+            builtin_configuration_module,
+        );
+    }
+
+    if generate_sources {
+        configure_lsp_builtins("configuration", &module);
+    }
+
+    engine.register_module(module);
+}
+
+fn _languages_api(_engine: &mut Engine, _generate_sources: bool) {
+    // TODO: Just look at the `cx.editor.syn_loader` for how to
+    // manipulate the languages bindings
+    todo!()
+}
+
+// TODO:
+// This isn't the best API since it pretty much requires deserializing
+// the whole theme model each time. While its not _horrible_, it is
+// certainly not as efficient as it could be. If we could just edit
+// the loaded theme in memory already, then it would be a bit nicer.
+fn load_theme_api(engine: &mut Engine, generate_sources: bool) {
+    let mut module = BuiltInModule::new("helix/core/themes");
+    module
+        .register_fn("hashmap->theme", theme_from_json_string)
+        .register_fn("add-theme!", add_theme)
+        .register_fn("theme-style", get_style)
+        .register_fn("theme-set-style!", set_style)
+        .register_fn("string->color", string_to_color);
+
+    if generate_sources {
+        configure_lsp_builtins("themes", &module);
+    }
+
+    engine.register_module(module);
+}
+
+fn load_high_level_theme_api(engine: &mut Engine, generate_sources: bool) {
+    let theme = include_str!("themes.scm");
+
+    if generate_sources {
+        if let Some(mut target_directory) = alternative_runtime_search_path() {
+            if !target_directory.exists() {
+                std::fs::create_dir_all(&target_directory).unwrap();
+            }
+
+            target_directory.push("themes.scm");
+
+            std::fs::write(target_directory, theme).unwrap();
+        }
+    }
+
+    engine.register_steel_module("helix/themes.scm".to_string(), theme.to_string());
+}
+
+#[derive(Clone)]
+struct SteelTheme(Theme);
+impl Custom for SteelTheme {}
+
+fn theme_from_json_string(name: String, value: SteelVal) -> Result<SteelTheme, anyhow::Error> {
+    // TODO: Really don't love this at all. The deserialization should be a bit more elegant
+    let json_value = serde_json::Value::try_from(value)?;
+    let value: toml::Value = serde_json::from_str(&serde_json::to_string(&json_value)?)?;
+
+    let (mut theme, _) = Theme::from_toml(value);
+    theme.set_name(name);
+    Ok(SteelTheme(theme))
+}
+
+// Mutate the theme?
+fn add_theme(cx: &mut Context, theme: SteelTheme) {
+    cx.editor
+        .user_defined_themes
+        .insert(theme.0.name().to_owned(), theme.0);
+}
+
+fn get_style(theme: &SteelTheme, name: SteelString) -> helix_view::theme::Style {
+    theme.0.get(name.as_str()).clone()
+}
+
+fn set_style(theme: &mut SteelTheme, name: String, style: helix_view::theme::Style) {
+    theme.0.set(name, style)
+}
+
+fn string_to_color(string: SteelString) -> Result<Color, anyhow::Error> {
+    // TODO: Don't expose this directly
+    helix_view::theme::ThemePalette::string_to_rgb(string.as_str()).map_err(anyhow::Error::msg)
+}
+
+fn current_buffer_area(cx: &mut Context) -> Option<helix_view::graphics::Rect> {
+    let focus = cx.editor.tree.focus;
+    cx.editor.tree.view_id_area(focus)
+}
+
+fn load_editor_api(engine: &mut Engine, generate_sources: bool) {
+    let mut module = BuiltInModule::new("helix/core/editor");
+
+    let mut builtin_editor_command_module =
+        "(require-builtin helix/core/editor as helix.)".to_string();
+
+    let mut template_function_arity_0 = |name: &str, doc: &str| {
+        let doc = format_docstring(doc);
+        builtin_editor_command_module.push_str(&format!(
+            r#"
+(provide {})
+;;@doc
+{}
+(define ({})
+    (helix.{} *helix.cx*))
+"#,
+            name, doc, name, name
+        ));
+    };
+
+    macro_rules! register_0 {
+        ($name:expr, $func:expr, $doc:expr) => {
+            module.register_fn($name, $func);
+            template_function_arity_0($name, $doc);
+        };
+    }
+
+    // Types
+    module.register_fn("Action/Load", || Action::Load);
+    module.register_fn("Action/Replace", || Action::Replace);
+    module.register_fn("Action/HorizontalSplit", || Action::HorizontalSplit);
+    module.register_fn("Action/VerticalSplit", || Action::VerticalSplit);
+
+    // Arity 0
+    register_0!(
+        "editor-focus",
+        cx_current_focus,
+        r#"
+Get the current focus of the editor, as a `ViewId`.
+
+```scheme
+(editor-focus) -> ViewId
+```
+        "#
+    );
+    register_0!(
+        "editor-mode",
+        cx_get_mode,
+        r#"
+Get the current mode of the editor
+
+```scheme
+(editor-mode) -> Mode?
+```
+        "#
+    );
+
+    register_0!(
+        "cx->themes",
+        get_themes,
+        "DEPRECATED: Please use `themes->list`"
+    );
+
+    register_0!(
+        "themes->list",
+        get_themes,
+        r#"
+Get the current themes as a list of strings.
+
+```scheme
+(themes->list) -> (listof string?)
+```
+        "#
+    );
+
+    register_0!(
+        "editor-all-documents",
+        cx_editor_all_documents,
+        r#"
+Get a list of all of the document ids that are currently open.
+
+```scheme
+(editor-all-documents) -> (listof DocumentId?)
+```
+        "#
+    );
+    register_0!(
+        "cx->cursor",
+        |cx: &mut Context| cx.editor.cursor(),
+        r#"DEPRECATED: Please use `current-cursor`"#
+    );
+
+    register_0!(
+        "current-cursor",
+        |cx: &mut Context| cx.editor.cursor(),
+        r#"Gets the primary cursor position in screen coordinates,
+or `#false` if the primary cursor is not visible on screen.
+
+```scheme
+(current-cursor) -> (listof? (or Position? #false) CursorKind)
+```
+        "#
+    );
+
+    register_0!(
+        "editor-focused-buffer-area",
+        current_buffer_area,
+        r#"
+Get the `Rect` associated with the currently focused buffer.
+
+```scheme
+(editor-focused-buffer-area) -> (or Rect? #false)
+```
+        "#
+    );
+
+    // Arity 1
+    module.register_fn("editor->doc-id", cx_get_document_id);
+    module.register_fn("editor-switch!", cx_switch);
+    module.register_fn("editor-set-focus!", |cx: &mut Context, view_id: ViewId| {
+        cx.editor.focus(view_id)
+    });
+    module.register_fn("editor-set-mode!", cx_set_mode);
+    module.register_fn("editor-doc-in-view?", cx_is_document_in_view);
+    module.register_fn("set-scratch-buffer-name!", set_scratch_buffer_name);
+
+    // Get the last saved time of the document
+    module.register_fn(
+        "editor-document-last-saved",
+        |cx: &mut Context, doc: DocumentId| -> Option<SystemTime> {
+            cx.editor.documents.get(&doc).map(|x| x.last_saved_time())
+        },
+    );
+
+    module.register_fn(
+        "editor-document-dirty?",
+        |cx: &mut Context, doc: DocumentId| -> Option<bool> {
+            cx.editor.documents.get(&doc).map(|x| x.is_modified())
+        },
+    );
+
+    module.register_fn("set-buffer-uri!", set_buffer_uri);
+
+    module.register_fn("editor-doc-exists?", cx_document_exists);
+
+    // Arity 2
+    module.register_fn("editor-switch-action!", cx_switch_action);
+    module.register_fn(
+        "set-register!",
+        |cx: &mut Context, name: char, value: Vec<String>| cx.editor.registers.write(name, value),
+    );
+
+    // Arity 1
+    module.register_fn("editor->text", document_id_to_text);
+    module.register_fn("editor-document->path", document_path);
+    module.register_fn("register->value", cx_register_value);
+
+    module.register_fn("set-editor-clip-right!", |cx: &mut Context, right: u16| {
+        cx.editor.editor_clipping.right = Some(right);
+    });
+    module.register_fn("set-editor-clip-left!", |cx: &mut Context, left: u16| {
+        cx.editor.editor_clipping.left = Some(left);
+    });
+    module.register_fn("set-editor-clip-top!", |cx: &mut Context, top: u16| {
+        cx.editor.editor_clipping.top = Some(top);
+    });
+    module.register_fn(
+        "set-editor-clip-bottom!",
+        |cx: &mut Context, bottom: u16| {
+            cx.editor.editor_clipping.bottom = Some(bottom);
+        },
+    );
+
+    if generate_sources {
+        let mut template_function_type_constructor = |name: &str| {
+            builtin_editor_command_module.push_str(&format!(
+                r#"
+(provide {})
+(define {} helix.{})
+"#,
+                name, name, name
+            ));
+        };
+
+        template_function_type_constructor("Action/Load");
+        template_function_type_constructor("Action/Replace");
+        template_function_type_constructor("Action/HorizontalSplit");
+        template_function_type_constructor("Action/VerticalSplit");
+
+        let mut template_function_arity_1 = |name: &str, doc: &str| {
+            if generate_sources {
+                let docstring = format_docstring(doc);
+                builtin_editor_command_module.push_str(&format!(
+                    r#"
+(provide {})
+;;@doc
+{}
+(define ({} arg)
+    (helix.{} *helix.cx* arg))
+"#,
+                    name, docstring, name, name
+                ));
+            }
+        };
+
+        template_function_arity_1("editor->doc-id", "Get the document from a given view.");
+        template_function_arity_1("editor-switch!", "Open the document in a vertical split.");
+        template_function_arity_1("editor-set-focus!", "Set focus on the view.");
+        template_function_arity_1("editor-set-mode!", "Set the editor mode.");
+        template_function_arity_1(
+            "editor-doc-in-view?",
+            "Check whether the current view contains a document.",
+        );
+        template_function_arity_1(
+            "set-scratch-buffer-name!",
+            "Set the name of a scratch buffer.",
+        );
+
+        // TODO: Lift this up
+        template_function_arity_1("set-buffer-uri!", "Set the URI of the buffer");
+        template_function_arity_1("editor-doc-exists?", "Check if a document exists.");
+
+        template_function_arity_1(
+            "editor-document-last-saved",
+            "Check when a document was last saved (returns a `SystemTime`)",
+        );
+
+        template_function_arity_1(
+            "editor-document-dirty?",
+            "Check if a document has unsaved changes",
+        );
+
+        template_function_arity_1("editor->text", "Get the document as a rope.");
+        template_function_arity_1("editor-document->path", "Get the path to a document.");
+        template_function_arity_1(
+            "register->value",
+            "Get register value as a list of strings.",
+        );
+        template_function_arity_1(
+            "set-editor-clip-top!",
+            "Set the editor clipping at the top.",
+        );
+        template_function_arity_1(
+            "set-editor-clip-right!",
+            "Set the editor clipping at the right.",
+        );
+        template_function_arity_1(
+            "set-editor-clip-left!",
+            "Set the editor clipping at the left.",
+        );
+        template_function_arity_1(
+            "set-editor-clip-bottom!",
+            "Set the editor clipping at the bottom.",
+        );
+
+        let mut template_function_arity_2 = |name: &str| {
+            builtin_editor_command_module.push_str(&format!(
+                r#"
+(provide {})
+(define ({} arg1 arg2)
+    (helix.{} *helix.cx* arg1 arg2))
+"#,
+                name, name, name
+            ));
+        };
+
+        template_function_arity_2("editor-switch-action!");
+        template_function_arity_2("set-register!");
+
+        if let Some(mut target_directory) = alternative_runtime_search_path() {
+            if !target_directory.exists() {
+                std::fs::create_dir_all(&target_directory).unwrap_or_else(|err| {
+                    panic!("Failed to create directory {:?}: {}", target_directory, err)
+                });
+            }
+
+            target_directory.push("editor.scm");
+
+            std::fs::write(target_directory, &builtin_editor_command_module).unwrap();
+        }
+
+        engine.register_steel_module(
+            "helix/editor.scm".to_string(),
+            builtin_editor_command_module,
+        );
+    }
+
+    // Generate the lsp configuration
+    if generate_sources {
+        configure_lsp_builtins("editor", &module);
+    }
+
+    engine.register_module(module);
+}
+
+pub struct SteelScriptingEngine;
+
+impl super::PluginSystem for SteelScriptingEngine {
+    fn initialize(&self) {
+        initialize_engine();
+    }
+
+    fn engine_name(&self) -> super::PluginSystemKind {
+        super::PluginSystemKind::Steel
+    }
+
+    fn run_initialization_script(
+        &self,
+        cx: &mut Context,
+        configuration: Arc<ArcSwapAny<Arc<Config>>>,
+        // Just apply... all the configurations at once?
+        language_configuration: Arc<ArcSwap<syntax::Loader>>,
+    ) {
+        run_initialization_script(cx, configuration, language_configuration);
+    }
+
+    fn handle_keymap_event(
+        &self,
+        editor: &mut ui::EditorView,
+        mode: Mode,
+        cxt: &mut Context,
+        event: KeyEvent,
+    ) -> Option<KeymapResult> {
+        SteelScriptingEngine::handle_keymap_event_impl(&self, editor, mode, cxt, event)
+    }
+
+    fn call_function_by_name(&self, cx: &mut Context, name: &str, args: &[Cow<str>]) -> bool {
+        if enter_engine(|x| x.global_exists(name)) {
+            let mut args = args
+                .iter()
+                .map(|x| x.clone().into_steelval().unwrap())
+                .collect::<Vec<_>>();
+
+            if let Err(e) = enter_engine(|guard| {
+                {
+                    // Install the interrupt handler, in the event this thing
+                    // is blocking for too long.
+                    with_interrupt_handler(|| {
+                        guard.with_mut_reference::<Context, Context>(cx).consume(
+                            move |engine, arguments| {
+                                let context = arguments[0].clone();
+                                engine.update_value("*helix.cx*", context);
+                                engine
+                                    .call_function_by_name_with_args_from_mut_slice(name, &mut args)
+                            },
+                        )
+                    })
+                }
+            }) {
+                cx.editor.set_error(format!("{}", e));
+            }
+            true
+        } else {
+            false
+        }
+    }
+
+    fn call_typed_command<'a>(
+        &self,
+        cx: &mut compositor::Context,
+        command: &'a str,
+        parts: &'a [&'a str],
+        event: PromptEvent,
+    ) -> bool {
+        if enter_engine(|x| x.global_exists(command)) {
+            let args = parts;
+
+            // We're finalizing the event - we actually want to call the function
+            if event == PromptEvent::Validate {
+                if let Err(e) = enter_engine(|guard| {
+                    let args = args
+                        .iter()
+                        .map(|x| x.into_steelval().unwrap())
+                        .collect::<Vec<_>>();
+
+                    let res = {
+                        let mut ctx = Context {
+                            register: None,
+                            count: std::num::NonZeroUsize::new(1),
+                            editor: cx.editor,
+                            callback: Vec::new(),
+                            on_next_key_callback: None,
+                            jobs: cx.jobs,
+                        };
+
+                        // Install interrupt handler here during the duration
+                        // of the function call
+                        match with_interrupt_handler(|| {
+                            guard
+                                .with_mut_reference(&mut ctx)
+                                .consume(move |engine, arguments| {
+                                    let context = arguments[0].clone();
+                                    engine.update_value("*helix.cx*", context);
+                                    // TODO: Fix this clone
+                                    engine.call_function_by_name_with_args(command, args.clone())
+                                })
+                        }) {
+                            Ok(res) => {
+                                match &res {
+                                    SteelVal::Void => {}
+                                    SteelVal::StringV(s) => {
+                                        cx.editor.set_status(s.as_str().to_owned());
+                                    }
+                                    _ => {
+                                        cx.editor.set_status(res.to_string());
+                                    }
+                                }
+
+                                Ok(res)
+                            }
+                            Err(e) => Err(e),
+                        }
+                    };
+
+                    res
+                }) {
+                    let mut ctx = Context {
+                        register: None,
+                        count: None,
+                        editor: &mut cx.editor,
+                        callback: Vec::new(),
+                        on_next_key_callback: None,
+                        jobs: &mut cx.jobs,
+                    };
+
+                    enter_engine(|x| present_error_inside_engine_context(&mut ctx, x, e));
+                };
+            }
+
+            // Global exists
+            true
+        } else {
+            // Global does not exist
+            false
+        }
+    }
+
+    fn get_doc_for_identifier(&self, ident: &str) -> Option<String> {
+        try_enter_engine(|engine| get_doc_for_global(engine, ident)).unwrap_or_default()
+    }
+
+    // Just dump docs for all top level values?
+    fn available_commands<'a>(&self) -> Vec<Cow<'a, str>> {
+        try_enter_engine(|engine| {
+            engine
+                .readable_globals(*GLOBAL_OFFSET.get().unwrap())
+                .iter()
+                .map(|x| x.resolve().to_string().into())
+                .collect()
+        })
+        .unwrap_or_default()
+    }
+
+    fn generate_sources(&self) {
+        fn format_markdown_doc<W: Write>(writer: &mut W, doc: &str) {
+            for line in doc.lines() {
+                if line.starts_with("# ") {
+                    write!(writer, "###").unwrap();
+                }
+                writeln!(writer, "{}", line).unwrap();
+            }
+        }
+
+        // Generate sources directly with a fresh engine
+        let mut engine = Engine::new();
+        configure_builtin_sources(&mut engine, true);
+        // Generate documentation as well
+        if let Some(target) = alternative_runtime_search_path() {
+            let mut writer =
+                std::io::BufWriter::new(std::fs::File::create("steel-docs.md").unwrap());
+
+            // Generate markdown docs
+            steel_doc::walk_dir(&mut writer, target, &mut engine).unwrap();
+
+            // Also generate docs for the built in modules
+            let module = engine.builtin_modules().get("helix/core/text").unwrap();
+
+            writeln!(&mut writer, "# helix/core/text").unwrap();
+            writeln!(
+                &mut writer,
+                "To use, you can include with `(require-builtin helix/core/text)`"
+            )
+            .unwrap();
+
+            let mut found_definitions = std::collections::HashSet::new();
+
+            let mut exported_functions: Vec<_> = module
+                .names()
+                .into_iter()
+                .filter(|name| !name.starts_with("#%"))
+                .collect();
+
+            exported_functions.sort();
+
+            for name in &exported_functions {
+                if let Some(value) = module.documentation().get(name) {
+                    found_definitions.insert(name.to_string());
+
+                    match value {
+                        steel::steel_vm::builtin::Documentation::Markdown(m) => {
+                            let escaped = name.replace("*", "\\*");
+                            writeln!(&mut writer, "### **{}**", escaped).unwrap();
+
+                            format_markdown_doc(&mut writer, &m.0);
+                        }
+                        _ => {}
+                    }
+                }
+            }
+
+            for name in exported_functions {
+                if !found_definitions.contains(&name) {
+                    writeln!(&mut writer, "### **{}**", name).unwrap();
+                }
+            }
+        }
+    }
+
+    // TODO: Should this just be a hook / event instead of a function like this?
+    // Handle an LSP notification, assuming its been sent through
+    fn handle_lsp_notification(
+        &self,
+        cx: &mut compositor::Context,
+        server_id: helix_lsp::LanguageServerId,
+        event_name: String,
+        params: helix_lsp::jsonrpc::Params,
+    ) -> bool {
+        if let Err(e) = enter_engine(|guard| {
+            {
+                let mut ctx = Context {
+                    register: None,
+                    count: None,
+                    editor: &mut cx.editor,
+                    callback: Vec::new(),
+                    on_next_key_callback: None,
+                    jobs: &mut cx.jobs,
+                };
+
+                let language_server_name = ctx
+                    .editor
+                    .language_servers
+                    .get_by_id(server_id)
+                    .map(|x| x.name().to_owned());
+
+                if language_server_name.is_none() {
+                    ctx.editor.set_error("Unable to find language server");
+                }
+
+                let language_server_name = language_server_name.unwrap();
+
+                let function = LSP_NOTIFICATION_REGISTRY
+                    .read()
+                    .unwrap()
+                    .get(&(language_server_name, event_name))
+                    .map(|x| x.value())
+                    .cloned();
+
+                if let Some(function) = function {
+                    // Install the interrupt handler, in the event this thing
+                    // is blocking for too long.
+                    with_interrupt_handler(|| {
+                        guard
+                            .with_mut_reference::<Context, Context>(&mut ctx)
+                            .consume(move |engine, arguments| {
+                                let context = arguments[0].clone();
+                                engine.update_value("*helix.cx*", context);
+
+                                let params = serde_json::to_value(&params)
+                                    .map_err(|e| SteelErr::new(ErrorKind::Generic, e.to_string()))
+                                    .and_then(|x| x.into_steelval())?;
+
+                                let args = vec![params];
+
+                                engine.call_function_with_args(function.clone(), args)
+                            })
+                    })
+                } else {
+                    Ok(SteelVal::Void)
+                }
+            }
+        }) {
+            cx.editor.set_error(format!("{}", e));
+        }
+        true
+    }
+}
+
+impl SteelScriptingEngine {
+    fn handle_keymap_event_impl(
+        &self,
+        editor: &mut ui::EditorView,
+        mode: Mode,
+        cx: &mut Context,
+        event: KeyEvent,
+    ) -> Option<KeymapResult> {
+        let extension = {
+            let current_focus = cx.editor.tree.focus;
+            let view = cx.editor.tree.get(current_focus);
+            let doc = &view.doc;
+            let current_doc = cx.editor.documents.get(doc);
+
+            current_doc
+                .and_then(|x| x.path())
+                .and_then(|x| x.extension())
+                .and_then(|x| x.to_str())
+        };
+
+        let doc_id = {
+            let current_focus = cx.editor.tree.focus;
+            let view = cx.editor.tree.get(current_focus);
+            let doc = &view.doc;
+
+            doc
+        };
+
+        if let Some(extension) = extension {
+            let map = get_extension_keymap();
+            let keymap = map.get_extension(extension);
+
+            if let Some(keymap) = keymap {
+                return Some(editor.keymaps.get_with_map(&keymap.0, mode, event));
+            }
+        }
+
+        let map = get_extension_keymap();
+
+        if let Some(keymap) = map.get_doc_id(document_id_to_usize(doc_id)) {
+            return Some(editor.keymaps.get_with_map(&keymap.0, mode, event));
+        }
+
+        None
+    }
+}
+
+pub fn initialize_engine() {
+    enter_engine(|x| x.globals().first().copied());
+}
+
+pub fn present_error_inside_engine_context(cx: &mut Context, engine: &mut Engine, e: SteelErr) {
+    cx.editor.set_error(e.to_string());
+
+    let backtrace = engine.raise_error_to_string(e);
+
+    let callback = async move {
+        let call: job::Callback = Callback::EditorCompositor(Box::new(
+            move |editor: &mut Editor, compositor: &mut Compositor| {
+                if let Some(backtrace) = backtrace {
+                    let contents = ui::Markdown::new(
+                        format!("```\n{}\n```", backtrace),
+                        editor.syn_loader.clone(),
+                    );
+                    let popup = Popup::new("engine", contents).position(Some(
+                        helix_core::Position::new(editor.cursor().0.unwrap_or_default().row, 2),
+                    ));
+                    compositor.replace_or_push("engine", popup);
+                }
+            },
+        ));
+        Ok(call)
+    };
+    cx.jobs.callback(callback);
+}
+
+pub fn present_error_inside_engine_context_with_callback(
+    cx: &mut Context,
+    engine: &mut Engine,
+    e: SteelErr,
+    mut callback: impl FnMut(&mut Compositor) + Send + Sync + 'static,
+) {
+    cx.editor.set_error(e.to_string());
+
+    let backtrace = engine.raise_error_to_string(e);
+
+    let callback = async move {
+        let call: job::Callback = Callback::EditorCompositor(Box::new(
+            move |editor: &mut Editor, compositor: &mut Compositor| {
+                if let Some(backtrace) = backtrace {
+                    let contents = ui::Markdown::new(
+                        format!("```\n{}\n```", backtrace),
+                        editor.syn_loader.clone(),
+                    );
+                    let popup = Popup::new("engine", contents).position(Some(
+                        helix_core::Position::new(editor.cursor().0.unwrap_or_default().row, 2),
+                    ));
+                    compositor.replace_or_push("engine", popup);
+
+                    callback(compositor);
+                }
+            },
+        ));
+        Ok(call)
+    };
+    cx.jobs.callback(callback);
+}
+
+// Key maps
+#[derive(Clone, Debug)]
+pub struct EmbeddedKeyMap(pub HashMap<Mode, KeyTrie>);
+impl Custom for EmbeddedKeyMap {}
+
+pub fn update_documentation(map: &mut EmbeddedKeyMap, docs: HashMap<String, String>) {
+    let mut func = move |command: &mut MappableCommand| {
+        if let Some(steel_doc) = docs.get(command.name()) {
+            if let Some(doc) = command.doc_mut() {
+                *doc = steel_doc.to_owned()
+            }
+        }
+    };
+
+    for trie in map.0.values_mut() {
+        trie.apply(&mut func)
+    }
+}
+
+// Will deep copy a value by default when using a value type
+pub fn deep_copy_keymap(copied: EmbeddedKeyMap) -> EmbeddedKeyMap {
+    copied
+}
+
+// Base level - no configuration
+pub fn default_keymap() -> EmbeddedKeyMap {
+    EmbeddedKeyMap(keymap::default())
+}
+
+// Completely empty, allow for overriding
+pub fn empty_keymap() -> EmbeddedKeyMap {
+    EmbeddedKeyMap(HashMap::default())
+}
+
+pub fn string_to_embedded_keymap(value: String) -> EmbeddedKeyMap {
+    EmbeddedKeyMap(serde_json::from_str(&value).unwrap())
+}
+
+pub fn merge_keybindings(left: &mut EmbeddedKeyMap, right: EmbeddedKeyMap) {
+    merge_keys(&mut left.0, right.0)
+}
+
+pub fn is_keymap(keymap: SteelVal) -> bool {
+    if let SteelVal::Custom(underlying) = keymap {
+        as_underlying_type::<EmbeddedKeyMap>(underlying.read().as_ref()).is_some()
+    } else {
+        false
+    }
+}
+
+fn local_config_exists() -> bool {
+    let local_helix = find_workspace().0.join(".helix");
+    local_helix.join("helix.scm").exists() && local_helix.join("init.scm").exists()
+}
+
+fn preferred_config_path(file_name: &str) -> PathBuf {
+    if let Ok(steel_config_dir) = std::env::var("HELIX_STEEL_CONFIG") {
+        PathBuf::from(steel_config_dir).join(file_name)
+    } else if local_config_exists() {
+        find_workspace().0.join(".helix").join(file_name)
+    } else {
+        helix_loader::config_dir().join(file_name)
+    }
+}
+
+pub fn helix_module_file() -> PathBuf {
+    preferred_config_path("helix.scm")
+}
+
+pub fn steel_init_file() -> PathBuf {
+    preferred_config_path("init.scm")
+}
+
+struct HelixConfiguration {
+    configuration: Arc<ArcSwapAny<Arc<Config>>>,
+    language_configuration: Arc<ArcSwap<helix_core::syntax::Loader>>,
+}
+
+#[derive(Clone)]
+struct IndividualLanguageConfiguration {
+    // Lets go ahead and just deserialize it that way.
+    // It's ugly and annoying.
+    config: LanguageConfiguration,
+}
+
+// TODO: @Matt 5/19/2025 - Finish up writing these bindings.
+impl Custom for IndividualLanguageConfiguration {}
+
+impl Custom for HelixConfiguration {}
+
+fn update_configuration_for_all_open_documents(ctx: &mut Context) {
+    for document in ctx.editor.documents.values_mut() {
+        if let Some(name) = document.language_name() {
+            let config_for_file = ctx
+                .editor
+                .syn_loader
+                .load()
+                .language_configs()
+                .find(|x| x.language_id == name)
+                .cloned()
+                .map(Arc::new);
+            document.language = config_for_file;
+        }
+    }
+}
+
+fn set_configuration_for_file(
+    ctx: &mut Context,
+    file_name: SteelString,
+    configuration: IndividualLanguageConfiguration,
+) {
+    if let Some(document) = ctx.editor.document_by_path_mut(file_name.as_str()) {
+        document.language = Some(Arc::new(configuration.config));
+    }
+}
+
+impl HelixConfiguration {
+    fn _store_language_configuration(&self, language_config: syntax::Loader) {
+        self.language_configuration.store(Arc::new(language_config))
+    }
+
+    fn get_language_config(
+        &self,
+        language: SteelString,
+    ) -> Option<IndividualLanguageConfiguration> {
+        self.language_configuration
+            .load()
+            .language_configs()
+            .find(|x| x.language_id == language.as_str())
+            .map(|config| IndividualLanguageConfiguration {
+                config: (*config).clone(),
+            })
+    }
+
+    fn update_language_config(
+        &mut self,
+        language: SteelString,
+        config: SteelVal,
+    ) -> anyhow::Result<()> {
+        // Do some gross json -> toml conversion
+        let value = serde_json::Value::try_from(config)?;
+
+        // Horrendous, disgusting
+        let mut toml_value: toml::Value = serde_json::from_str(&serde_json::to_string(&value)?)?;
+
+        let auto_format_present = toml_value.get("auto-format").is_some();
+        let diagnostic_severity_present = toml_value.get("diagnostic-severity").is_some();
+        let language_servers_present = toml_value.get("language-servers").is_some();
+        let persistent_diagnostic_sources_present =
+            toml_value.get("persistent-diagnostic-sources").is_some();
+
+        // Existing language config:
+        let mut existing_config = self
+            .language_configuration
+            .load()
+            .language_configs()
+            .find(|x| x.language_id == language.as_str())
+            .unwrap()
+            .clone();
+
+        if toml_value.get("scope").is_none() {
+            toml_value
+                .as_table_mut()
+                .and_then(|x| x.insert("scope".to_string(), existing_config.scope.into()));
+        }
+
+        for need_empty in ["file-types", "shebangs", "roots"] {
+            if toml_value.get(need_empty).is_none() {
+                toml_value.as_table_mut().and_then(|x| {
+                    x.insert(need_empty.to_owned(), <Vec<toml::Value>>::new().into())
+                });
+            }
+        }
+
+        let new_config: LanguageConfiguration = toml_value.try_into()?;
+
+        if let Some(id) = new_config.language_server_language_id {
+            existing_config.language_server_language_id = Some(id);
+        }
+
+        // Take the new scope, since its already set to the old one as a default.
+        existing_config.scope = new_config.scope;
+
+        if !new_config.file_types.is_empty() {
+            existing_config.file_types = new_config.file_types;
+        }
+
+        if !new_config.shebangs.is_empty() {
+            existing_config.shebangs = new_config.shebangs;
+        }
+
+        if !new_config.roots.is_empty() {
+            existing_config.roots = new_config.roots;
+        }
+
+        if let Some(comment_tokens) = new_config.comment_tokens {
+            existing_config.comment_tokens = Some(comment_tokens);
+        }
+
+        if let Some(block_comment_tokens) = new_config.block_comment_tokens {
+            existing_config.block_comment_tokens = Some(block_comment_tokens);
+        }
+
+        if let Some(text_width) = new_config.text_width {
+            existing_config.text_width = Some(text_width);
+        }
+
+        if let Some(soft_wrap) = new_config.soft_wrap {
+            existing_config.soft_wrap = Some(soft_wrap);
+        }
+
+        if auto_format_present {
+            existing_config.auto_format = new_config.auto_format;
+        }
+
+        if let Some(formatter) = new_config.formatter {
+            existing_config.formatter = Some(formatter);
+        }
+
+        if let Some(path_complation) = new_config.path_completion {
+            existing_config.path_completion = Some(path_complation);
+        }
+
+        if diagnostic_severity_present {
+            existing_config.diagnostic_severity = new_config.diagnostic_severity;
+        }
+
+        if let Some(grammar) = new_config.grammar {
+            existing_config.grammar = Some(grammar);
+        }
+
+        if let Some(injection_regex) = new_config.injection_regex {
+            existing_config.injection_regex = Some(injection_regex);
+        }
+
+        if language_servers_present {
+            existing_config.language_servers = new_config.language_servers;
+        }
+
+        if let Some(indent) = new_config.indent {
+            existing_config.indent = Some(indent);
+        }
+
+        if let Some(debugger) = new_config.debugger {
+            existing_config.debugger = Some(debugger);
+        }
+
+        if let Some(auto_pairs) = new_config.auto_pairs {
+            existing_config.auto_pairs = Some(auto_pairs);
+        }
+
+        if let Some(rulers) = new_config.rulers {
+            existing_config.rulers = Some(rulers);
+        }
+
+        if let Some(workspace_lsp_roots) = new_config.workspace_lsp_roots {
+            existing_config.workspace_lsp_roots = Some(workspace_lsp_roots);
+        }
+
+        if persistent_diagnostic_sources_present {
+            existing_config.persistent_diagnostic_sources =
+                new_config.persistent_diagnostic_sources;
+        }
+
+        self.update_individual_language_config(IndividualLanguageConfiguration {
+            config: existing_config,
+        });
+
+        Ok(())
+    }
+
+    // fn get_individual_language_config_for_filename(
+    //     &self,
+    //     file_name: SteelString,
+    // ) -> Option<IndividualLanguageConfiguration> {
+    //     self.language_configuration
+    //         .load()
+    //         .language_config_for_file_name(std::path::Path::new(file_name.as_str()))
+    //         .map(|config| IndividualLanguageConfiguration {
+    //             config: (*config).clone(),
+    //         })
+    // }
+
+    fn update_language_server_config(
+        &mut self,
+        lsp: SteelString,
+        map: HashMap<String, SteelVal>,
+    ) -> anyhow::Result<()> {
+        let mut loader = (*(*self.language_configuration.load())).clone();
+        let lsp_configs = loader.language_server_configs_mut();
+
+        let individual_config = lsp_configs.get_mut(lsp.as_str());
+
+        if let Some(config) = individual_config {
+            if let Some(args) = map.get("args") {
+                config.args = <Vec<String>>::from_steelval(args)?;
+            }
+
+            if let Some(command) = map.get("command") {
+                config.command = String::from_steelval(command)?;
+            }
+
+            if let Some(environment) = map.get("environment") {
+                config.environment = <HashMap<String, String>>::from_steelval(environment)?;
+            }
+
+            if let Some(config_json) = map.get("config") {
+                let serialized = serde_json::Value::try_from(config_json.clone())?;
+                config.config = Some(serialized);
+            }
+
+            if let Some(timeout) = map.get("timeout") {
+                config.timeout = u64::from_steelval(timeout)?;
+            }
+
+            if let Some(required_root_patterns) = map.get("required-root-patterns") {
+                let patterns = <Vec<String>>::from_steelval(required_root_patterns)?;
+
+                if !patterns.is_empty() {
+                    let mut builder = globset::GlobSetBuilder::new();
+                    for pattern in patterns {
+                        let glob = globset::Glob::new(&pattern)?;
+                        builder.add(glob);
+                    }
+                    config.required_root_patterns = Some(builder.build()?);
+                }
+            }
+        } else {
+            let command = if let Some(command) = map.get("command") {
+                String::from_steelval(command)?
+            } else {
+                anyhow::bail!("LSP config missing required `command` field.");
+            };
+
+            let mut config = LanguageServerConfiguration {
+                command,
+                args: Vec::new(),
+                environment: HashMap::new(),
+                config: None,
+                timeout: default_timeout(),
+                required_root_patterns: None,
+            };
+
+            if let Some(args) = map.get("args") {
+                config.args = <Vec<String>>::from_steelval(args)?;
+            }
+
+            if let Some(environment) = map.get("environment") {
+                config.environment = <HashMap<String, String>>::from_steelval(environment)?;
+            }
+
+            if let Some(config_json) = map.get("config") {
+                let serialized = serde_json::Value::try_from(config_json.clone())?;
+                config.config = Some(serialized);
+            }
+
+            if let Some(timeout) = map.get("timeout") {
+                config.timeout = u64::from_steelval(timeout)?;
+            }
+
+            if let Some(required_root_patterns) = map.get("required-root-patterns") {
+                let patterns = <Vec<String>>::from_steelval(required_root_patterns)?;
+
+                if !patterns.is_empty() {
+                    let mut builder = globset::GlobSetBuilder::new();
+                    for pattern in patterns {
+                        let glob = globset::Glob::new(&pattern)?;
+                        builder.add(glob);
+                    }
+                    config.required_root_patterns = Some(builder.build()?);
+                }
+            }
+
+            lsp_configs.insert(lsp.as_str().to_owned(), config);
+        }
+
+        self.language_configuration.store(Arc::new(loader));
+
+        Ok(())
+    }
+
+    // Update the language config - this does not immediately flush it
+    // to the actual config.
+    fn update_individual_language_config(&mut self, config: IndividualLanguageConfiguration) {
+        // TODO: Try to opportunistically load the ref counts
+        // of the inner values - if the documents haven't been opened yet, we
+        // don't need to clone the _whole_ loader.
+        let mut loader = (*(*self.language_configuration.load())).clone();
+        let config = config.config;
+
+        for lconfig in loader.language_configs_mut() {
+            if &lconfig.language_id == &config.language_id {
+                if let Some(inner) = Arc::get_mut(lconfig) {
+                    *inner = config;
+                } else {
+                    *lconfig = Arc::new(config);
+                }
+                break;
+            }
+        }
+
+        self.language_configuration.store(Arc::new(loader));
+    }
+
+    fn load_config(&self) -> Config {
+        (*self.configuration.load().clone()).clone()
+    }
+
+    fn store_config(&self, config: Config) {
+        self.configuration.store(Arc::new(config));
+    }
+
+    // Overlay new keybindings
+    fn keybindings(&self, keybindings: EmbeddedKeyMap) {
+        let mut app_config = self.load_config();
+        merge_keys(&mut app_config.keys, keybindings.0);
+        self.store_config(app_config);
+    }
+
+    fn get_keybindings(&self) -> EmbeddedKeyMap {
+        EmbeddedKeyMap(self.load_config().keys.clone())
+    }
+
+    fn scrolloff(&self, lines: usize) {
+        let mut app_config = self.load_config();
+        app_config.editor.scrolloff = lines;
+        self.store_config(app_config);
+    }
+
+    fn scroll_lines(&self, lines: isize) {
+        let mut app_config = self.load_config();
+        app_config.editor.scroll_lines = lines;
+        self.store_config(app_config);
+    }
+
+    fn mouse(&self, m: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.mouse = m;
+        self.store_config(app_config);
+    }
+
+    fn shell(&self, shell: Vec<String>) {
+        let mut app_config = self.load_config();
+        app_config.editor.shell = shell;
+        self.store_config(app_config);
+    }
+
+    // TODO: Make this a symbol, probably!
+    fn line_number(&self, mode: LineNumber) {
+        let mut app_config = self.load_config();
+        app_config.editor.line_number = mode;
+        self.store_config(app_config);
+    }
+
+    fn cursorline(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.cursorline = option;
+        self.store_config(app_config);
+    }
+
+    fn cursorcolumn(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.cursorcolumn = option;
+        self.store_config(app_config);
+    }
+
+    fn middle_click_paste(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.middle_click_paste = option;
+        self.store_config(app_config);
+    }
+
+    fn auto_pairs(&self, config: AutoPairConfig) {
+        let mut app_config = self.load_config();
+        app_config.editor.auto_pairs = config;
+        self.store_config(app_config);
+    }
+
+    fn auto_completion(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.auto_completion = option;
+        self.store_config(app_config);
+    }
+
+    fn auto_format(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.auto_format = option;
+        self.store_config(app_config);
+    }
+
+    fn auto_save(&self, option: AutoSave) {
+        let mut app_config = self.load_config();
+        app_config.editor.auto_save = option;
+        self.store_config(app_config);
+    }
+
+    // TODO: Finish the auto save options!
+    fn auto_save_after_delay_enable(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.auto_save.after_delay.enable = option;
+        self.store_config(app_config);
+    }
+
+    // TODO: Finish diagnostic options!
+    fn inline_diagnostics_cursor_line_enable(&self, severity: String) {
+        let mut app_config = self.load_config();
+        let severity = match severity.as_str() {
+            "hint" => Severity::Hint,
+            "info" => Severity::Info,
+            "warning" => Severity::Warning,
+            "error" => Severity::Error,
+            _ => return,
+        };
+        app_config.editor.inline_diagnostics.cursor_line = DiagnosticFilter::Enable(severity);
+        self.store_config(app_config);
+    }
+
+    fn inline_diagnostics_end_of_line_enable(&self, severity: String) {
+        let mut app_config = self.load_config();
+        let severity = match severity.as_str() {
+            "hint" => Severity::Hint,
+            "info" => Severity::Info,
+            "warning" => Severity::Warning,
+            "error" => Severity::Error,
+            _ => return,
+        };
+        app_config.editor.end_of_line_diagnostics = DiagnosticFilter::Enable(severity);
+        self.store_config(app_config);
+    }
+
+    fn text_width(&self, width: usize) {
+        let mut app_config = self.load_config();
+        app_config.editor.text_width = width;
+        self.store_config(app_config);
+    }
+
+    fn idle_timeout(&self, ms: usize) {
+        let mut app_config = self.load_config();
+        app_config.editor.idle_timeout = Duration::from_millis(ms as u64);
+        self.store_config(app_config);
+    }
+
+    fn completion_timeout(&self, ms: usize) {
+        let mut app_config = self.load_config();
+        app_config.editor.completion_timeout = Duration::from_millis(ms as u64);
+        self.store_config(app_config);
+    }
+
+    fn preview_completion_insert(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.preview_completion_insert = option;
+        self.store_config(app_config);
+    }
+
+    // TODO: Make sure this conversion works automatically
+    fn completion_trigger_len(&self, length: u8) {
+        let mut app_config = self.load_config();
+        app_config.editor.completion_trigger_len = length;
+        self.store_config(app_config);
+    }
+
+    fn completion_replace(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.completion_replace = option;
+        self.store_config(app_config);
+    }
+
+    fn auto_info(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.auto_info = option;
+        self.store_config(app_config);
+    }
+
+    fn cursor_shape(&self, config: CursorShapeConfig) {
+        let mut app_config = self.load_config();
+        app_config.editor.cursor_shape = config;
+        self.store_config(app_config);
+    }
+
+    fn true_color(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.true_color = option;
+        self.store_config(app_config);
+    }
+
+    fn insert_final_newline(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.insert_final_newline = option;
+        self.store_config(app_config);
+    }
+
+    fn color_modes(&self, option: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.color_modes = option;
+        self.store_config(app_config);
+    }
+
+    fn gutters(&self, config: GutterConfig) {
+        let mut app_config = self.load_config();
+        app_config.editor.gutters = config;
+        self.store_config(app_config);
+    }
+
+    fn file_picker(&self, picker: FilePickerConfig) {
+        let mut app_config = self.load_config();
+        app_config.editor.file_picker = picker;
+        self.store_config(app_config);
+    }
+
+    fn statusline(&self, config: StatusLineConfig) {
+        let mut app_config = self.load_config();
+        app_config.editor.statusline = config;
+        self.store_config(app_config);
+    }
+
+    fn undercurl(&self, undercurl: bool) {
+        let mut app_config = self.load_config();
+        app_config.editor.undercurl = undercurl;
+        self.store_config(app_config);
+    }
+
+    fn search(&self, config: SearchConfig) {
+        let mut app_config = self.load_config();
+        app_config.editor.search = config;
+        self.store_config(app_config);
+    }
+
+    fn lsp(&self, config: LspConfig) {
+        let mut app_config = self.load_config();
+        app_config.editor.lsp = config;
+        self.store_config(app_config);
+    }
+
+    fn terminal(&self, config: Option<TerminalConfig>) {
+        let mut app_config = self.load_config();
+        app_config.editor.terminal = config;
+        self.store_config(app_config);
+    }
+
+    fn rulers(&self, cols: Vec<u16>) {
+        let mut app_config = self.load_config();
+        app_config.editor.rulers = cols;
+        self.store_config(app_config);
+    }
+
+    fn whitespace(&self, config: WhitespaceConfig) {
+        let mut app_config = self.load_config();
+        app_config.editor.whitespace = config;
+        self.store_config(app_config);
+    }
+
+    fn bufferline(&self, buffer_config: SteelVal) -> anyhow::Result<()> {
+        let config = match buffer_config {
+            SteelVal::StringV(s) | SteelVal::SymbolV(s) => match s.as_str() {
+                "never" => BufferLine::Never,
+                "always" => BufferLine::Always,
+                "multiple" => BufferLine::Multiple,
+                other => anyhow::bail!("Unrecognized bufferline option: {}", other),
+            },
+            other => anyhow::bail!("Unrecognized bufferline option: {}", other),
+        };
+
+        let mut app_config = self.load_config();
+        app_config.editor.bufferline = config;
+        self.store_config(app_config);
+
+        Ok(())
+    }
+
+    fn indent_guides(&self, config: IndentGuidesConfig) {
+        let mut app_config = self.load_config();
+        app_config.editor.indent_guides = config;
+        self.store_config(app_config);
+    }
+
+    fn soft_wrap(&self, config: SoftWrap) {
+        let mut app_config = self.load_config();
+        app_config.editor.soft_wrap = config;
+        self.store_config(app_config);
+    }
+
+    fn workspace_lsp_roots(&self, roots: Vec<PathBuf>) {
+        let mut app_config = self.load_config();
+        app_config.editor.workspace_lsp_roots = roots;
+        self.store_config(app_config);
+    }
+
+    fn default_line_ending(&self, config: LineEndingConfig) {
+        let mut app_config = self.load_config();
+        app_config.editor.default_line_ending = config;
+        self.store_config(app_config);
+    }
+
+    fn smart_tab(&self, config: Option<SmartTabConfig>) {
+        let mut app_config = self.load_config();
+        app_config.editor.smart_tab = config;
+        self.store_config(app_config);
+    }
+}
+
+// Get doc from function ptr table, hack
+fn get_doc_for_global(engine: &mut Engine, ident: &str) -> Option<String> {
+    if engine.global_exists(ident) {
+        let readable_globals = engine.readable_globals(*GLOBAL_OFFSET.get().unwrap());
+
+        for global in readable_globals {
+            if global.resolve() == ident {
+                return engine.get_doc_for_identifier(ident);
+            }
+        }
+
+        None
+    } else {
+        None
+    }
+}
+
+/// Run the initialization script located at `$helix_config/init.scm`
+/// This runs the script in the global environment, and does _not_ load it as a module directly
+fn run_initialization_script(
+    cx: &mut Context,
+    configuration: Arc<ArcSwapAny<Arc<Config>>>,
+    language_configuration: Arc<ArcSwap<syntax::Loader>>,
+) {
+    log::info!("Loading init.scm...");
+
+    let helix_module_path = helix_module_file();
+
+    // TODO: Report the error from requiring the file!
+    enter_engine(|guard| {
+        // Embed the configuration so we don't have to communicate over the refresh
+        // channel. The state is still stored within the `Application` struct, but
+        // now we can just access it and signal a refresh of the config when we need to.
+        guard.update_value(
+            "*helix.config*",
+            HelixConfiguration {
+                configuration,
+                language_configuration,
+            }
+            .into_steelval()
+            .unwrap(),
+        );
+
+        if helix_module_path.exists() {
+            let res = guard.run_with_reference(
+                cx,
+                "*helix.cx*",
+                &format!(r#"(require {:?})"#, helix_module_path.to_str().unwrap()),
+            );
+
+            // Present the error in the helix.scm loading
+            if let Err(e) = res {
+                present_error_inside_engine_context(cx, guard, e);
+                return;
+            }
+        } else {
+            println!("Unable to find the `helix.scm` file, creating....");
+            std::fs::write(helix_module_path, "").ok();
+        }
+
+        let helix_module_path = steel_init_file();
+
+        // These contents need to be registered with the path?
+        if let Ok(contents) = std::fs::read_to_string(&helix_module_path) {
+            let res = guard.run_with_reference_from_path::<Context, Context>(
+                cx,
+                "*helix.cx*",
+                &contents,
+                helix_module_path,
+            );
+
+            match res {
+                Ok(_) => {}
+                Err(e) => present_error_inside_engine_context(cx, guard, e),
+            }
+
+            log::info!("Finished loading init.scm!")
+        } else {
+            log::info!("No init.scm found, skipping loading.");
+            std::fs::write(helix_module_path, "").ok();
+        }
+    });
+}
+
+impl Custom for PromptEvent {}
+
+impl<'a> CustomReference for Context<'a> {}
+
+steel::custom_reference!(Context<'a>);
+
+fn get_themes(cx: &mut Context) -> Vec<String> {
+    ui::completers::theme(cx.editor, "")
+        .into_iter()
+        .map(|x| x.1.content.to_string())
+        .collect()
+}
+
+/// A dynamic component, used for rendering thing
+impl Custom for compositor::EventResult {}
+
+pub struct WrappedDynComponent {
+    pub(crate) inner: Option<Box<dyn Component + Send + Sync + 'static>>,
+}
+
+impl Custom for WrappedDynComponent {}
+
+pub struct BoxDynComponent {
+    inner: Box<dyn Component>,
+}
+
+impl BoxDynComponent {
+    pub fn new(inner: Box<dyn Component>) -> Self {
+        Self { inner }
+    }
+}
+
+impl Component for BoxDynComponent {
+    fn handle_event(
+        &mut self,
+        _event: &helix_view::input::Event,
+        _ctx: &mut compositor::Context,
+    ) -> compositor::EventResult {
+        self.inner.handle_event(_event, _ctx)
+    }
+
+    fn should_update(&self) -> bool {
+        self.inner.should_update()
+    }
+
+    fn cursor(
+        &self,
+        _area: helix_view::graphics::Rect,
+        _ctx: &Editor,
+    ) -> (
+        Option<helix_core::Position>,
+        helix_view::graphics::CursorKind,
+    ) {
+        self.inner.cursor(_area, _ctx)
+    }
+
+    fn required_size(&mut self, _viewport: (u16, u16)) -> Option<(u16, u16)> {
+        self.inner.required_size(_viewport)
+    }
+
+    fn type_name(&self) -> &'static str {
+        std::any::type_name::<Self>()
+    }
+
+    fn id(&self) -> Option<&'static str> {
+        Some(self.inner.type_name())
+    }
+
+    fn name(&self) -> Option<&str> {
+        self.inner.name()
+    }
+
+    fn render(
+        &mut self,
+        area: helix_view::graphics::Rect,
+        frame: &mut tui::buffer::Buffer,
+        ctx: &mut compositor::Context,
+    ) {
+        self.inner.render(area, frame, ctx)
+    }
+}
+
+#[derive(Debug, Clone, Copy)]
+struct OnModeSwitchEvent {
+    old_mode: Mode,
+    new_mode: Mode,
+}
+
+impl OnModeSwitchEvent {
+    pub fn get_old_mode(&self) -> Mode {
+        self.old_mode
+    }
+
+    pub fn get_new_mode(&self) -> Mode {
+        self.new_mode
+    }
+}
+
+impl Custom for OnModeSwitchEvent {}
+impl Custom for MappableCommand {}
+
+// Don't take the function name, just take the function itself?
+fn register_hook(event_kind: String, callback_fn: SteelVal) -> steel::UnRecoverableResult {
+    let rooted = callback_fn.as_rooted();
+
+    match event_kind.as_str() {
+        "on-mode-switch" => {
+            register_hook!(move |event: &mut OnModeSwitch<'_, '_>| {
+                if let Err(e) = enter_engine(|guard| {
+                    let minimized_event = OnModeSwitchEvent {
+                        old_mode: event.old_mode,
+                        new_mode: event.new_mode,
+                    };
+
+                    guard.with_mut_reference(event.cx).consume(|engine, args| {
+                        let context = args[0].clone();
+                        engine.update_value("*helix.cx*", context);
+                        let mut args = [minimized_event.into_steelval().unwrap()];
+                        engine.call_function_with_args_from_mut_slice(
+                            rooted.value().clone(),
+                            &mut args,
+                        )
+                    })
+                }) {
+                    event.cx.editor.set_error(e.to_string());
+                }
+
+                Ok(())
+            });
+
+            Ok(SteelVal::Void).into()
+        }
+        "post-insert-char" => {
+            register_hook!(move |event: &mut PostInsertChar<'_, '_>| {
+                if let Err(e) = enter_engine(|guard| {
+                    guard.with_mut_reference(event.cx).consume(|engine, args| {
+                        let context = args[0].clone();
+                        engine.update_value("*helix.cx*", context);
+                        let mut args = [event.c.into()];
+                        engine.call_function_with_args_from_mut_slice(
+                            rooted.value().clone(),
+                            &mut args,
+                        )
+                    })
+                }) {
+                    event.cx.editor.set_error(e.to_string());
+                }
+
+                Ok(())
+            });
+
+            Ok(SteelVal::Void).into()
+        }
+        // Register hook - on save?
+        "post-command" => {
+            register_hook!(move |event: &mut PostCommand<'_, '_>| {
+                if let Err(e) = enter_engine(|guard| {
+                    guard.with_mut_reference(event.cx).consume(|engine, args| {
+                        let context = args[0].clone();
+                        engine.update_value("*helix.cx*", context);
+                        let mut args = [event.command.name().into_steelval().unwrap()];
+                        engine.call_function_with_args_from_mut_slice(
+                            rooted.value().clone(),
+                            &mut args,
+                        )
+                    })
+                }) {
+                    event.cx.editor.set_error(e.to_string());
+                }
+
+                Ok(())
+            });
+
+            Ok(SteelVal::Void).into()
+        }
+
+        "document-focus-lost" => {
+            // TODO: Pass the information from the event in here - the doc id
+            // is probably the most helpful so that way we can look the document up
+            // and act accordingly?
+            register_hook!(move |event: &mut DocumentFocusLost<'_>| {
+                let cloned_func = rooted.value().clone();
+                let doc_id = event.doc;
+
+                let callback = move |editor: &mut Editor,
+                                     _compositor: &mut Compositor,
+                                     jobs: &mut job::Jobs| {
+                    let mut ctx = Context {
+                        register: None,
+                        count: None,
+                        editor,
+                        callback: Vec::new(),
+                        on_next_key_callback: None,
+                        jobs,
+                    };
+                    enter_engine(|guard| {
+                        if let Err(e) = guard
+                            .with_mut_reference::<Context, Context>(&mut ctx)
+                            .consume(move |engine, args| {
+                                let context = args[0].clone();
+                                engine.update_value("*helix.cx*", context);
+                                let mut args = [doc_id.into_steelval().unwrap()];
+
+                                // TODO: Do something with this error!
+                                engine.call_function_with_args_from_mut_slice(
+                                    cloned_func.clone(),
+                                    &mut args,
+                                )
+                            })
+                        {
+                            present_error_inside_engine_context(&mut ctx, guard, e);
+                        }
+                    })
+                };
+                job::dispatch_blocking_jobs(callback);
+
+                Ok(())
+            });
+
+            Ok(SteelVal::Void).into()
+        }
+
+        "selection-did-change" => {
+            // TODO: Pass the information from the event in here - the doc id
+            // is probably the most helpful so that way we can look the document up
+            // and act accordingly?
+            register_hook!(move |event: &mut SelectionDidChange<'_>| {
+                let cloned_func = rooted.value().clone();
+                let view_id = event.view;
+
+                let callback = move |editor: &mut Editor,
+                                     _compositor: &mut Compositor,
+                                     jobs: &mut job::Jobs| {
+                    let mut ctx = Context {
+                        register: None,
+                        count: None,
+                        editor,
+                        callback: Vec::new(),
+                        on_next_key_callback: None,
+                        jobs,
+                    };
+                    enter_engine(|guard| {
+                        if let Err(e) = guard
+                            .with_mut_reference::<Context, Context>(&mut ctx)
+                            .consume(move |engine, args| {
+                                let context = args[0].clone();
+                                engine.update_value("*helix.cx*", context);
+                                // TODO: Reuse this allocation
+                                let mut args = [view_id.into_steelval().unwrap()];
+                                engine.call_function_with_args_from_mut_slice(
+                                    cloned_func.clone(),
+                                    &mut args,
+                                )
+                            })
+                        {
+                            present_error_inside_engine_context(&mut ctx, guard, e);
+                        }
+                    })
+                };
+                job::dispatch_blocking_jobs(callback);
+
+                Ok(())
+            });
+
+            Ok(SteelVal::Void).into()
+        }
+
+        "document-opened" => {
+            // TODO: Share this code with the above since most of it is
+            // exactly the same
+            register_hook!(move |event: &mut DocumentDidOpen<'_>| {
+                let cloned_func = rooted.value().clone();
+                let doc_id = event.doc;
+
+                let callback = move |editor: &mut Editor,
+                                     _compositor: &mut Compositor,
+                                     jobs: &mut job::Jobs| {
+                    let mut ctx = Context {
+                        register: None,
+                        count: None,
+                        editor,
+                        callback: Vec::new(),
+                        on_next_key_callback: None,
+                        jobs,
+                    };
+                    enter_engine(|guard| {
+                        if let Err(e) = guard
+                            .with_mut_reference::<Context, Context>(&mut ctx)
+                            .consume(move |engine, args| {
+                                let context = args[0].clone();
+                                engine.update_value("*helix.cx*", context);
+                                // TODO: Reuse this allocation if possible
+                                let mut args = [doc_id.into_steelval().unwrap()];
+                                engine.call_function_with_args_from_mut_slice(
+                                    cloned_func.clone(),
+                                    &mut args,
+                                )
+                            })
+                        {
+                            present_error_inside_engine_context(&mut ctx, guard, e);
+                        }
+                    })
+                };
+                job::dispatch_blocking_jobs(callback);
+
+                Ok(())
+            });
+
+            Ok(SteelVal::Void).into()
+        }
+
+        "document-saved" => {
+            // TODO: Share this code with the above since most of it is
+            // exactly the same
+            register_hook!(move |event: &mut DocumentSaved<'_>| {
+                let cloned_func = rooted.value().clone();
+                let doc_id = event.doc;
+
+                let callback = move |editor: &mut Editor,
+                                     _compositor: &mut Compositor,
+                                     jobs: &mut job::Jobs| {
+                    let mut ctx = Context {
+                        register: None,
+                        count: None,
+                        editor,
+                        callback: Vec::new(),
+                        on_next_key_callback: None,
+                        jobs,
+                    };
+                    enter_engine(|guard| {
+                        if let Err(e) = guard
+                            .with_mut_reference::<Context, Context>(&mut ctx)
+                            .consume(move |engine, args| {
+                                let context = args[0].clone();
+                                engine.update_value("*helix.cx*", context);
+                                // TODO: Reuse this allocation if possible
+                                let mut args = [doc_id.into_steelval().unwrap()];
+                                engine.call_function_with_args_from_mut_slice(
+                                    cloned_func.clone(),
+                                    &mut args,
+                                )
+                            })
+                        {
+                            present_error_inside_engine_context(&mut ctx, guard, e);
+                        }
+                    })
+                };
+                job::dispatch_blocking_jobs(callback);
+
+                Ok(())
+            });
+
+            Ok(SteelVal::Void).into()
+        }
+
+        _ => steelerr!(Generic => "Unable to register hook: Unknown event type: {}", event_kind)
+            .into(),
+    }
+}
+
+fn configure_lsp_globals() {
+    use std::fmt::Write;
+    let steel_lsp_home = steel_lsp_home_dir();
+    let mut path = PathBuf::from(steel_lsp_home);
+    path.push("_helix-global-builtins.scm");
+
+    let mut output = String::new();
+
+    let names = &[
+        "*helix.cx*",
+        "*helix.config*",
+        "*helix.id*",
+        "register-hook!",
+        "log::info!",
+        "fuzzy-match",
+        "helix-find-workspace",
+        "find-workspace",
+        "doc-id->usize",
+        "new-component!",
+        "acquire-context-lock",
+        "SteelDynamicComponent?",
+        "prompt",
+        "picker",
+        "#%exp-picker",
+        "Component::Text",
+        "hx.create-directory",
+    ];
+
+    for value in names {
+        writeln!(&mut output, "(#%register-global '{})", value).unwrap();
+    }
+
+    writeln!(&mut output, "").unwrap();
+    writeln!(
+        &mut output,
+        "(#%register-additional-search-path \"{}\")",
+        helix_loader::config_dir().to_str().unwrap()
+    )
+    .unwrap();
+
+    for dir in helix_loader::runtime_dirs() {
+        writeln!(
+            &mut output,
+            "(#%register-additional-search-path \"{}\")",
+            dir.to_str().unwrap()
+        )
+        .unwrap();
+    }
+
+    std::fs::write(path, output).unwrap();
+}
+
+fn configure_lsp_builtins(name: &str, module: &BuiltInModule) {
+    use std::fmt::Write;
+    let steel_lsp_home = steel_lsp_home_dir();
+    let mut path = PathBuf::from(steel_lsp_home);
+    path.push(&format!("_helix-{}-builtins.scm", name));
+
+    let mut output = String::new();
+
+    output.push_str(&format!(
+        r#"(define #%helix-{}-module (#%module "{}"))
+
+(define (register-values module values)
+  (map (lambda (ident) (#%module-add module (symbol->string ident) void)) values))
+"#,
+        name,
+        module.name()
+    ));
+
+    output.push_str(&format!(r#"(register-values #%helix-{}-module '("#, name));
+
+    for value in module.names() {
+        writeln!(&mut output, "{}", value).unwrap();
+    }
+
+    output.push_str("))");
+
+    for value in module.names() {
+        if let Some(doc) = module.get_documentation(&value) {
+            output.push_str(&format!(
+                "(#%module-add-doc #%helix-{}-module {:?} {:?})\n",
+                name, value, doc
+            ));
+        }
+    }
+
+    std::fs::write(path, output).unwrap();
+}
+
+fn load_rope_api(engine: &mut Engine, generate_sources: bool) {
+    // Wrap the rope module?
+    let rope_slice_module = rope_module();
+
+    if generate_sources {
+        configure_lsp_builtins("rope", &rope_slice_module);
+    }
+
+    engine.register_module(rope_slice_module);
+}
+
+fn load_misc_api(engine: &mut Engine, generate_sources: bool) {
+    let mut module = BuiltInModule::new("helix/core/misc");
+
+    let mut builtin_misc_module = if generate_sources {
+        "(require-builtin helix/core/misc as helix.)".to_string()
+    } else {
+        "".to_string()
+    };
+
+    let mut template_function_arity_0 = |name: &str, doc: &str| {
+        if generate_sources {
+            let doc = format_docstring(doc);
+            builtin_misc_module.push_str(&format!(
+                r#"
+(provide {})
+;;@doc
+{}
+(define ({})
+    (helix.{} *helix.cx*))
+"#,
+                name, doc, name, name
+            ));
+        }
+    };
+
+    // Arity 0
+    module.register_fn("hx.cx->pos", cx_pos_within_text);
+    module.register_fn("cursor-position", cx_pos_within_text);
+    module.register_fn("mode-switch-old", OnModeSwitchEvent::get_old_mode);
+    module.register_fn("mode-switch-new", OnModeSwitchEvent::get_new_mode);
+
+    template_function_arity_0("hx.cx->pos", "DEPRECATED: Please use `cursor-position`");
+    template_function_arity_0(
+        "cursor-position",
+        "Returns the cursor position within the current buffer as an integer",
+    );
+
+    let mut template_function_arity_1 = |name: &str, doc: &str| {
+        let doc = format_docstring(doc);
+        if generate_sources {
+            builtin_misc_module.push_str(&format!(
+                r#"
+(provide {})
+;;@doc
+{}
+(define ({} arg)
+    (helix.{} *helix.cx* arg))
+"#,
+                name, doc, name, name
+            ));
+        }
+    };
+
+    macro_rules! register_1 {
+        ($name:expr, $func:expr, $doc:expr) => {{
+            module.register_fn($name, $func);
+            template_function_arity_1($name, $doc);
+        }};
+    }
+
+    // TODO: Get rid of the `hx.` prefix
+    register_1!(
+        "hx.custom-insert-newline",
+        custom_insert_newline,
+        "DEPRECATED: Please use `insert-newline-hook`"
+    );
+    register_1!(
+        "insert-newline-hook",
+        custom_insert_newline,
+        r#"Inserts a new line with the provided indentation.
+
+```scheme
+(insert-newline-hook indent-string)
+```
+
+indent-string : string?
+
+"#
+    );
+    register_1!(
+        "push-component!",
+        push_component,
+        r#"
+Push a component on to the top of the stack.
+
+```scheme
+(push-component! component)
+```
+
+component : WrappedDynComponent?
+        "#
+    );
+
+    // Arity 1
+    register_1!(
+        "pop-last-component!",
+        pop_last_component_by_name,
+        "DEPRECATED: Please use `pop-last-component-by-name!`"
+    );
+    register_1!(
+        "pop-last-component-by-name!",
+        pop_last_component_by_name,
+        r#"Pops the last component off of the stack by name. In other words,
+it removes the component matching this name from the stack.
+
+```scheme
+(pop-last-component-by-name! name)
+```
+
+name : string?
+        "#
+    );
+
+    register_1!(
+        "enqueue-thread-local-callback",
+        enqueue_command,
+        r#"
+Enqueue a function to be run following this context of execution. This could
+be useful for yielding back to the editor in the event you want updates to happen
+before your function is run.
+
+```scheme
+(enqueue-thread-local-callback callback)
+```
+
+callback : (-> any?)
+    Function with no arguments.
+
+# Examples
+
+```scheme
+(enqueue-thread-local-callback (lambda () (theme "focus_nova")))
+```
+        "#
+    );
+
+    register_1!(
+        "set-status!",
+        set_status,
+        "Sets the content of the status line, with the info severity"
+    );
+
+    register_1!(
+        "set-warning!",
+        set_warning,
+        "Sets the content of the status line, with the warning severity"
+    );
+
+    register_1!(
+        "set-error!",
+        set_error,
+        "Sets the content of the status line, with the error severity"
+    );
+
+    module.register_fn("send-lsp-command", send_arbitrary_lsp_command);
+    if generate_sources {
+        builtin_misc_module.push_str(
+            r#"
+    (provide send-lsp-command)
+    ;;@doc
+    ;; Send an lsp command. The `lsp-name` must correspond to an active lsp.
+    ;; The method name corresponds to the method name that you'd expect to see
+    ;; with the lsp, and the params can be passed as a hash table. The callback
+    ;; provided will be called with whatever result is returned from the LSP,
+    ;; deserialized from json to a steel value.
+    ;; 
+    ;; # Example
+    ;; ```scheme
+    ;; (define (view-crate-graph)
+    ;;   (send-lsp-command "rust-analyzer"
+    ;;                     "rust-analyzer/viewCrateGraph"
+    ;;                     (hash "full" #f)
+    ;;                     ;; Callback to run with the result
+    ;;                     (lambda (result) (displayln result))))
+    ;; ```
+    (define (send-lsp-command lsp-name method-name params callback)
+        (helix.send-lsp-command *helix.cx* lsp-name method-name params callback))
+            "#,
+        );
+    }
+
+    macro_rules! register_2_no_context {
+        ($name:expr, $func:expr, $doc:expr) => {{
+            module.register_fn($name, $func);
+            if generate_sources {
+                let doc = format_docstring($doc);
+                builtin_misc_module.push_str(&format!(
+                    r#"
+(provide {})
+;;@doc
+{}
+(define ({} arg1 arg2)
+    (helix.{} arg1 arg2))
+"#,
+                    $name, doc, $name, $name
+                ));
+            }
+        }};
+    }
+
+    register_2_no_context!(
+        "acquire-context-lock",
+        acquire_context_lock,
+        r#"
+Schedule a function to run on the main thread. This is a fairly low level function, and odds are
+you'll want to use some abstractions on top of this.
+
+The provided function will get enqueued to run on the main thread, and during the duration of the functions
+execution, the provided mutex will be locked.
+
+```scheme
+(acquire-context-lock callback-fn mutex)
+```
+
+callback-fn : (-> void?)
+    Function with no arguments
+
+mutex : mutex?
+"#
+    );
+
+    let mut template_function_arity_2 = |name: &str, doc: &str| {
+        if generate_sources {
+            let doc = format_docstring(doc);
+            builtin_misc_module.push_str(&format!(
+                r#"
+(provide {})
+;;@doc
+{}
+(define ({} arg1 arg2)
+    (helix.{} *helix.cx* arg1 arg2))
+"#,
+                name, doc, name, name
+            ));
+        }
+    };
+
+    macro_rules! register_2 {
+        ($name:expr, $func:expr, $doc:expr) => {{
+            module.register_fn($name, $func);
+            template_function_arity_2($name, $doc);
+        }};
+    }
+
+    // Arity 2
+    register_2!(
+        "enqueue-thread-local-callback-with-delay",
+        enqueue_command_with_delay,
+        r#"
+Enqueue a function to be run following this context of execution, after a delay. This could
+be useful for yielding back to the editor in the event you want updates to happen
+before your function is run.
+
+```scheme
+(enqueue-thread-local-callback-with-delay delay callback)
+```
+
+delay : int?
+    Time to delay the callback by in milliseconds
+
+callback : (-> any?)
+    Function with no arguments.
+
+# Examples
+
+```scheme
+(enqueue-thread-local-callback-with-delay 1000 (lambda () (theme "focus_nova"))) ;; Run after 1 second
+``
+        "#
+    );
+
+    register_2!(
+        "helix-await-callback",
+        await_value,
+        "DEPRECATED: Please use `await-callback`"
+    );
+
+    // Arity 2
+    register_2!(
+        "await-callback",
+        await_value,
+        r#"
+Await the given value, and call the callback function on once the future is completed.
+
+```scheme
+(await-callback future callback)
+```
+
+* future : future?
+* callback (-> any?)
+    Function with no arguments"#
+    );
+
+    register_2!(
+        "add-inlay-hint",
+        add_inlay_hint,
+        r#"
+Warning: this is experimental
+
+Adds an inlay hint at the given character index. Returns the (first-line, last-line) list
+associated with this snapshot of the inlay hints. Use this pair of line numbers to invalidate
+the inlay hints.
+
+```scheme
+(add-inlay-hint char-index completion) -> (list int? int?)
+```
+
+char-index : int?
+completion : string?
+
+"#
+    );
+    register_2!(
+        "remove-inlay-hint",
+        remove_inlay_hint,
+        r#"
+Warning: this is experimental and should not be used.
+This will most likely be removed soon.
+
+Removes an inlay hint at the given character index. Note - to remove
+properly, the completion must match what was already there.
+
+```scheme
+(remove-inlay-hint char-index completion)
+```
+
+char-index : int?
+completion : string?
+
+"#
+    );
+
+    register_2!(
+        "remove-inlay-hint-by-id",
+        remove_inlay_hint_by_id,
+        r#"
+Warning: this is experimental
+
+Removes an inlay hint by the id that was associated with the added inlay hints.
+
+```scheme
+(remove-inlay-hint first-line last-line)
+```
+
+first-line : int?
+last-line : int?
+
+"#
+    );
+
+    if generate_sources {
+        if let Some(mut target_directory) = alternative_runtime_search_path() {
+            if !target_directory.exists() {
+                std::fs::create_dir_all(&target_directory).unwrap();
+            }
+
+            target_directory.push("misc.scm");
+
+            std::fs::write(target_directory, &builtin_misc_module).unwrap();
+        }
+
+        engine.register_steel_module("helix/misc.scm".to_string(), builtin_misc_module);
+    }
+
+    if generate_sources {
+        configure_lsp_builtins("misc", &module);
+    }
+
+    engine.register_module(module);
+}
+
+// TODO: Generate sources into the cogs directory, so that the
+// LSP can go find it. When it comes to loading though, it'll look
+// up internally.
+pub fn alternative_runtime_search_path() -> Option<PathBuf> {
+    if let Some(path) = steel_home() {
+        Some(PathBuf::from(path).join("cogs").join("helix"))
+    } else {
+        None
+    }
+}
+
+pub fn generate_cog_file() {
+    if let Some(path) = alternative_runtime_search_path() {
+        std::fs::write(
+            path.join("cog.scm"),
+            r#"(define package-name 'helix)
+            (define version "0.1.0")"#,
+        )
+        .unwrap();
+    }
+}
+
+pub fn load_ext_api(engine: &mut Engine, generate_sources: bool) {
+    let ext_api = r#"
+(require "helix/editor.scm")
+(require "helix/misc.scm")
+(require-builtin helix/core/text as text.)
+(require "steel/sync")
+
+(provide eval-buffer
+         evalp
+         running-on-main-thread?
+         hx.with-context
+         hx.block-on-task)
+
+(define (get-document-as-slice)
+  (let* ([focus (editor-focus)]
+         [focus-doc-id (editor->doc-id focus)])
+    (text.rope->string (editor->text focus-doc-id))))
+
+;;@doc
+;; Eval the current buffer, morally equivalent to load-buffer!
+(define (eval-buffer)
+  (eval-string (get-document-as-slice)))
+
+;;@doc
+;; Eval prompt
+(define (evalp)
+  (push-component! (prompt "" (lambda (expr) (set-status! (eval-string expr))))))
+
+;;@doc
+;; Check what the main thread id is, compare to the main thread
+(define (running-on-main-thread?)
+  (= (current-thread-id) *helix.id*))
+
+;;@doc
+;; If running on the main thread already, just do nothing.
+;; Check the ID of the engine, and if we're already on the
+;; main thread, just continue as is - i.e. just block. This does
+;; not block on the function if this is running on another thread.
+;;
+;; ```scheme
+;; (hx.with-context thunk)
+;; ```
+;; thunk : (-> any?) ;; Function that has no arguments
+;;
+;; # Examples
+;; ```scheme
+;; (spawn-native-thread
+;;   (lambda () 
+;;     (hx.with-context (lambda () (theme "nord")))))
+;; ```
+(define (hx.with-context thunk)
+  (if (running-on-main-thread?)
+      (thunk)
+      (begin
+        (define task (task #f))
+        ;; Send on the main thread
+        (acquire-context-lock thunk task)
+        task)))
+
+;;@doc
+;; Block on the given function.
+;; ```scheme
+;; (hx.block-on-task thunk)
+;; ```
+;; thunk : (-> any?) ;; Function that has no arguments
+;;
+;; # Examples
+;; ```scheme
+;; (define thread
+;;   (spawn-native-thread
+;;     (lambda () 
+;;       (hx.block-on-task (lambda () (theme "nord") 10)))))
+;;
+;; ;; Some time later, in a different context - if done at the same time,
+;; ;; this will deadline, since the join depends on the callback previously
+;; ;; executing.
+;; (equal? (thread-join! thread) 10) ;; => #true
+;; ```
+(define (hx.block-on-task thunk)
+  (if (running-on-main-thread?) (thunk) (block-on-task (hx.with-context thunk))))
+    "#;
+
+    if let Some(mut target_directory) = alternative_runtime_search_path() {
+        if generate_sources {
+            if !target_directory.exists() {
+                std::fs::create_dir_all(&target_directory).unwrap_or_else(|err| {
+                    panic!("Failed to create directory {:?}: {}", target_directory, err)
+                });
+            }
+
+            target_directory.push("ext.scm");
+
+            std::fs::write(target_directory, &ext_api).unwrap();
+        }
+    }
+
+    engine.register_steel_module("helix/ext.scm".to_string(), ext_api.to_string());
+}
+
+// Note: This implementation is aligned with what the steel language server
+// expects. This shouldn't stay here, but for alpha purposes its fine.
+pub fn steel_lsp_home_dir() -> PathBuf {
+    if let Ok(home) = std::env::var("STEEL_LSP_HOME") {
+        return PathBuf::from(home);
+    }
+
+    let mut home_directory =
+        PathBuf::from(steel_home().expect("Unable to find steel home location"));
+    home_directory.push("lsp");
+
+    if !home_directory.exists() {
+        std::fs::create_dir_all(&home_directory).expect("Unable to create the lsp home directory");
+    }
+
+    home_directory
+}
+
+// Embed them in the binary... first
+pub fn configure_builtin_sources(engine: &mut Engine, generate_sources: bool) {
+    load_editor_api(engine, generate_sources);
+    load_theme_api(engine, generate_sources);
+    load_configuration_api(engine, generate_sources);
+    load_typed_commands(engine, generate_sources);
+    load_static_commands(engine, generate_sources);
+    // Note: This is going to be completely revamped soon.
+    load_keymap_api(engine, generate_sources);
+    load_rope_api(engine, generate_sources);
+    load_misc_api(engine, generate_sources);
+    load_component_api(engine, generate_sources);
+
+    // This depends on the components and theme api, so should
+    // be loaded after.
+    load_high_level_theme_api(engine, generate_sources);
+    load_ext_api(engine, generate_sources);
+
+    // TODO: Remove this once all of the globals have been moved into their own modules
+    if generate_sources {
+        configure_lsp_globals();
+
+        // Generate cog file for the stubs
+        // that are generated and written to the $STEEL_HOME directory
+        generate_cog_file()
+    }
+}
+
+fn acquire_context_lock(
+    callback_fn: SteelVal,
+    place: Option<SteelVal>,
+) -> steel::rvals::Result<()> {
+    static TASK_DONE: Lazy<SteelVal> = Lazy::new(|| SteelVal::SymbolV("done".into()));
+
+    match (&callback_fn, &place) {
+        (SteelVal::Closure(_), Some(SteelVal::CustomStruct(_))) => {}
+        _ => {
+            steel::stop!(TypeMismatch => "acquire-context-lock expected a 
+                        callback function and a task object")
+        }
+    }
+
+    let rooted = callback_fn.as_rooted();
+    let rooted_place = place.map(|x| x.as_rooted());
+
+    let callback = move |editor: &mut Editor,
+                         _compositor: &mut Compositor,
+                         jobs: &mut job::Jobs| {
+        let mut ctx = Context {
+            register: None,
+            count: None,
+            editor,
+            callback: Vec::new(),
+            on_next_key_callback: None,
+            jobs,
+        };
+
+        let cloned_func = rooted.value();
+        let cloned_place = rooted_place.as_ref().map(|x| x.value());
+
+        enter_engine(|guard| {
+            if let Err(e) = guard
+                .with_mut_reference::<Context, Context>(&mut ctx)
+                // Block until the other thread is finished in its critical
+                // section...
+                .consume(move |engine, args| {
+                    let context = args[0].clone();
+                    engine.update_value("*helix.cx*", context);
+
+                    let mut lock = None;
+
+                    if let Some(SteelVal::CustomStruct(s)) = cloned_place {
+                        let mutex = s.get_mut_index(0).unwrap();
+                        lock = Some(mutex_lock(&mutex).unwrap());
+                    }
+
+                    // Acquire lock, wait until its done
+                    let result = engine.call_function_with_args(cloned_func.clone(), Vec::new());
+
+                    if let Some(SteelVal::CustomStruct(s)) = cloned_place {
+                        match result {
+                            Ok(result) => {
+                                // Store the result of the callback so that the
+                                // next downstream user can handle it.
+                                s.set_index(2, result);
+
+                                // Set the task to be done
+                                s.set_index(1, (*TASK_DONE).clone());
+
+                                mutex_unlock(&lock.unwrap()).unwrap();
+                            }
+
+                            Err(e) => {
+                                return Err(e);
+                            }
+                        }
+                    }
+
+                    Ok(())
+                })
+            {
+                present_error_inside_engine_context(&mut ctx, guard, e);
+            }
+        })
+    };
+    job::dispatch_blocking_jobs(callback);
+
+    Ok(())
+}
+
+fn configure_engine_impl(mut engine: Engine) -> Engine {
+    log::info!("Loading engine!");
+
+    // Engine: Add search directories.
+    engine.add_search_directory(helix_loader::config_dir());
+
+    for dir in helix_loader::runtime_dirs() {
+        engine.add_search_directory(dir.to_owned());
+    }
+
+    engine.register_value("*helix.cx*", SteelVal::Void);
+    engine.register_value("*helix.config*", SteelVal::Void);
+    engine.register_value(
+        "*helix.id*",
+        SteelVal::IntV(engine.engine_id().as_usize() as _),
+    );
+
+    configure_builtin_sources(&mut engine, true);
+
+    // Hooks
+    engine.register_fn("register-hook!", register_hook);
+    engine.register_fn("log::info!", |message: SteelVal| {
+        if let SteelVal::StringV(s) = &message {
+            log::info!("{}", s)
+        } else {
+            log::info!("{}", message)
+        }
+    });
+
+    engine.register_fn("fuzzy-match", |pattern: SteelString, items: SteelVal| {
+        if let SteelVal::ListV(l) = items {
+            let res = helix_core::fuzzy::fuzzy_match(
+                pattern.as_str(),
+                l.iter().filter_map(|x| x.as_string().map(|x| x.as_str())),
+                false,
+            );
+
+            return res
+                .into_iter()
+                .map(|x| x.0.to_string().into())
+                .collect::<Vec<SteelVal>>();
+        }
+
+        return Vec::new();
+    });
+
+    // Find the workspace
+    engine.register_fn("helix-find-workspace", || {
+        helix_core::find_workspace().0.to_str().unwrap().to_string()
+    });
+
+    // TODO: Deprecate the above
+    engine.register_fn("find-workspace", || {
+        helix_core::find_workspace().0.to_str().unwrap().to_string()
+    });
+
+    engine.register_fn("doc-id->usize", document_id_to_usize);
+
+    // TODO: Remove that this is now in helix/core/misc
+    engine.register_fn("acquire-context-lock", acquire_context_lock);
+
+    engine.register_fn("SteelDynamicComponent?", |object: SteelVal| {
+        if let SteelVal::Custom(v) = object {
+            if let Some(wrapped) = v.read().as_any_ref().downcast_ref::<BoxDynComponent>() {
+                return wrapped.inner.as_any().is::<SteelDynamicComponent>();
+            } else {
+                false
+            }
+        } else {
+            false
+        }
+    });
+
+    engine.register_fn(
+        "prompt",
+        |prompt: String, callback_fn: SteelVal| -> WrappedDynComponent {
+            let callback_fn_guard = callback_fn.as_rooted();
+
+            let prompt = Prompt::new(
+                prompt.into(),
+                None,
+                |_, _| Vec::new(),
+                move |cx, input, prompt_event| {
+                    log::info!("Calling dynamic prompt callback");
+
+                    if prompt_event != PromptEvent::Validate {
+                        return;
+                    }
+
+                    let mut ctx = Context {
+                        register: None,
+                        count: None,
+                        editor: cx.editor,
+                        callback: Vec::new(),
+                        on_next_key_callback: None,
+                        jobs: cx.jobs,
+                    };
+
+                    let cloned_func = callback_fn_guard.value();
+
+                    with_interrupt_handler(|| {
+                        enter_engine(|guard| {
+                            if let Err(e) = guard
+                                .with_mut_reference::<Context, Context>(&mut ctx)
+                                .consume(move |engine, args| {
+                                    let context = args[0].clone();
+
+                                    engine.update_value("*helix.cx*", context);
+
+                                    engine.call_function_with_args(
+                                        cloned_func.clone(),
+                                        vec![input.into_steelval().unwrap()],
+                                    )
+                                })
+                            {
+                                present_error_inside_engine_context(&mut ctx, guard, e);
+                            }
+                        })
+                    })
+                },
+            );
+
+            WrappedDynComponent {
+                inner: Some(Box::new(prompt)),
+            }
+        },
+    );
+
+    engine.register_fn("picker", |values: Vec<String>| -> WrappedDynComponent {
+        let columns = [PickerColumn::new(
+            "path",
+            |item: &PathBuf, root: &PathBuf| {
+                item.strip_prefix(root)
+                    .unwrap_or(item)
+                    .to_string_lossy()
+                    .into()
+            },
+        )];
+        let cwd = helix_stdx::env::current_working_dir();
+
+        let picker = ui::Picker::new(columns, 0, [], cwd, move |cx, path: &PathBuf, action| {
+            if let Err(e) = cx.editor.open(path, action) {
+                let err = if let Some(err) = e.source() {
+                    format!("{}", err)
+                } else {
+                    format!("unable to open \"{}\"", path.display())
+                };
+                cx.editor.set_error(err);
+            }
+        })
+        .with_preview(|_editor, path| Some((PathOrId::Path(path), None)));
+
+        let injector = picker.injector();
+
+        for file in values {
+            if injector.push(PathBuf::from(file)).is_err() {
+                break;
+            }
+        }
+
+        WrappedDynComponent {
+            inner: Some(Box::new(ui::overlay::overlaid(picker))),
+        }
+    });
+
+    // Experimental - use at your own risk.
+    engine.register_fn(
+        "#%exp-picker",
+        |values: Vec<String>, callback_fn: SteelVal| -> WrappedDynComponent {
+            let columns = [PickerColumn::new(
+                "path",
+                |item: &PathBuf, root: &PathBuf| {
+                    item.strip_prefix(root)
+                        .unwrap_or(item)
+                        .to_string_lossy()
+                        .into()
+                },
+            )];
+            let cwd = helix_stdx::env::current_working_dir();
+
+            let rooted = callback_fn.as_rooted();
+
+            let picker = ui::Picker::new(columns, 0, [], cwd, move |cx, path: &PathBuf, action| {
+                let result = cx.editor.open(path, action);
+                match result {
+                    Err(e) => {
+                        let err = if let Some(err) = e.source() {
+                            format!("{}", err)
+                        } else {
+                            format!("unable to open \"{}\"", path.display())
+                        };
+                        cx.editor.set_error(err);
+                    }
+                    Ok(_) => {
+                        let mut ctx = Context {
+                            register: None,
+                            count: None,
+                            editor: cx.editor,
+                            callback: Vec::new(),
+                            on_next_key_callback: None,
+                            jobs: cx.jobs,
+                        };
+
+                        let cloned_func = rooted.value();
+
+                        enter_engine(|guard| {
+                            if let Err(e) = guard
+                                .with_mut_reference::<Context, Context>(&mut ctx)
+                                .consume(move |engine, args| {
+                                    let context = args[0].clone();
+                                    engine.update_value("*helix.cx*", context);
+                                    engine.call_function_with_args(cloned_func.clone(), Vec::new())
+                                })
+                            {
+                                present_error_inside_engine_context(&mut ctx, guard, e);
+                            }
+                        })
+                    }
+                }
+            })
+            .with_preview(|_editor, path| Some((PathOrId::Path(path), None)));
+
+            let injector = picker.injector();
+
+            for file in values {
+                if injector.push(PathBuf::from(file)).is_err() {
+                    break;
+                }
+            }
+
+            WrappedDynComponent {
+                inner: Some(Box::new(ui::overlay::overlaid(picker))),
+            }
+        },
+    );
+
+    engine.register_fn("Component::Text", |contents: String| WrappedDynComponent {
+        inner: Some(Box::new(crate::ui::Text::new(contents))),
+    });
+
+    // Create directory since we can't do that in the current state
+    engine.register_fn("hx.create-directory", create_directory);
+
+    GLOBAL_OFFSET.set(engine.globals().len()).unwrap();
+
+    engine
+}
+
+fn get_highlighted_text(cx: &mut Context) -> String {
+    let (view, doc) = current_ref!(cx.editor);
+    let text = doc.text().slice(..);
+    doc.selection(view.id).primary().slice(text).to_string()
+}
+
+fn current_selection(cx: &mut Context) -> Selection {
+    let (view, doc) = current_ref!(cx.editor);
+    doc.selection(view.id).clone()
+}
+
+fn set_selection(cx: &mut Context, selection: Selection) {
+    let (view, doc) = current!(cx.editor);
+    doc.set_selection(view.id, selection)
+}
+
+fn current_line_number(cx: &mut Context) -> usize {
+    let (view, doc) = current_ref!(cx.editor);
+    helix_core::coords_at_pos(
+        doc.text().slice(..),
+        doc.selection(view.id)
+            .primary()
+            .cursor(doc.text().slice(..)),
+    )
+    .row
+}
+
+fn get_selection(cx: &mut Context) -> String {
+    let (view, doc) = current_ref!(cx.editor);
+    let text = doc.text().slice(..);
+
+    let grapheme_start = doc.selection(view.id).primary().cursor(text);
+    let grapheme_end = graphemes::next_grapheme_boundary(text, grapheme_start);
+
+    if grapheme_start == grapheme_end {
+        return "".into();
+    }
+
+    let grapheme = text.slice(grapheme_start..grapheme_end).to_string();
+
+    let printable = grapheme.chars().fold(String::new(), |mut s, c| {
+        match c {
+            '\0' => s.push_str("\\0"),
+            '\t' => s.push_str("\\t"),
+            '\n' => s.push_str("\\n"),
+            '\r' => s.push_str("\\r"),
+            _ => s.push(c),
+        }
+
+        s
+    });
+
+    printable
+}
+
+// TODO: Replace with eval-string
+pub fn run_expression_in_engine(cx: &mut Context, text: String) -> anyhow::Result<()> {
+    let callback = async move {
+        let call: Box<dyn FnOnce(&mut Editor, &mut Compositor, &mut job::Jobs)> = Box::new(
+            move |editor: &mut Editor, compositor: &mut Compositor, jobs: &mut job::Jobs| {
+                let mut ctx = Context {
+                    register: None,
+                    count: None,
+                    editor,
+                    callback: Vec::new(),
+                    on_next_key_callback: None,
+                    jobs,
+                };
+
+                let output = enter_engine(|guard| {
+                    guard
+                        .with_mut_reference::<Context, Context>(&mut ctx)
+                        .consume(move |engine, args| {
+                            let context = args[0].clone();
+                            engine.update_value("*helix.cx*", context);
+
+                            engine.compile_and_run_raw_program(text.clone())
+                        })
+                });
+
+                match output {
+                    Ok(output) => {
+                        let (output, _success) = (Tendril::from(format!("{:?}", output)), true);
+
+                        let contents = ui::Markdown::new(
+                            format!("```\n{}\n```", output),
+                            editor.syn_loader.clone(),
+                        );
+                        let popup = Popup::new("engine", contents).position(Some(
+                            helix_core::Position::new(editor.cursor().0.unwrap_or_default().row, 2),
+                        ));
+                        compositor.replace_or_push("engine", popup);
+                    }
+                    Err(e) => enter_engine(|x| present_error_inside_engine_context(&mut ctx, x, e)),
+                }
+            },
+        );
+        Ok(call)
+    };
+    cx.jobs.local_callback(callback);
+
+    Ok(())
+}
+
+pub fn load_buffer(cx: &mut Context) -> anyhow::Result<()> {
+    let (text, path) = {
+        let (_, doc) = current!(cx.editor);
+
+        let text = doc.text().to_string();
+        let path = current_path(cx);
+
+        (text, path)
+    };
+
+    let callback = async move {
+        let call: Box<dyn FnOnce(&mut Editor, &mut Compositor, &mut job::Jobs)> = Box::new(
+            move |editor: &mut Editor, compositor: &mut Compositor, jobs: &mut job::Jobs| {
+                let mut ctx = Context {
+                    register: None,
+                    count: None,
+                    editor,
+                    callback: Vec::new(),
+                    on_next_key_callback: None,
+                    jobs,
+                };
+
+                let output = enter_engine(|guard| {
+                    guard
+                        .with_mut_reference::<Context, Context>(&mut ctx)
+                        .consume(move |engine, args| {
+                            let context = args[0].clone();
+                            engine.update_value("*helix.cx*", context);
+
+                            match path.clone() {
+                                Some(path) => engine.compile_and_run_raw_program_with_path(
+                                    // TODO: Figure out why I have to clone this text here.
+                                    text.clone(),
+                                    PathBuf::from(path),
+                                ),
+                                None => engine.compile_and_run_raw_program(text.clone()),
+                            }
+                        })
+                });
+
+                match output {
+                    Ok(output) => {
+                        let (output, _success) = (Tendril::from(format!("{:?}", output)), true);
+
+                        let contents = ui::Markdown::new(
+                            format!("```\n{}\n```", output),
+                            editor.syn_loader.clone(),
+                        );
+                        let popup = Popup::new("engine", contents).position(Some(
+                            helix_core::Position::new(editor.cursor().0.unwrap_or_default().row, 2),
+                        ));
+                        compositor.replace_or_push("engine", popup);
+                    }
+                    Err(e) => enter_engine(|x| present_error_inside_engine_context(&mut ctx, x, e)),
+                }
+            },
+        );
+        Ok(call)
+    };
+    cx.jobs.local_callback(callback);
+
+    Ok(())
+}
+
+fn get_helix_scm_path() -> String {
+    helix_module_file().to_str().unwrap().to_string()
+}
+
+fn get_init_scm_path() -> String {
+    steel_init_file().to_str().unwrap().to_string()
+}
+
+/// Get the current path! See if this can be done _without_ this function?
+// TODO:
+fn current_path(cx: &mut Context) -> Option<String> {
+    let current_focus = cx.editor.tree.focus;
+    let view = cx.editor.tree.get(current_focus);
+    let doc = &view.doc;
+    // Lifetime of this needs to be tied to the existing document
+    let current_doc = cx.editor.documents.get(doc);
+    current_doc.and_then(|x| x.path().and_then(|x| x.to_str().map(|x| x.to_string())))
+}
+
+fn set_scratch_buffer_name(cx: &mut Context, name: String) {
+    let current_focus = cx.editor.tree.focus;
+    let view = cx.editor.tree.get(current_focus);
+    let doc = &view.doc;
+    // Lifetime of this needs to be tied to the existing document
+    let current_doc = cx.editor.documents.get_mut(doc);
+
+    if let Some(current_doc) = current_doc {
+        current_doc.name = Some(name);
+    }
+}
+
+fn set_buffer_uri(cx: &mut Context, uri: SteelString) -> anyhow::Result<()> {
+    let current_focus = cx.editor.tree.focus;
+    let view = cx.editor.tree.get(current_focus);
+    let doc = &view.doc;
+    // Lifetime of this needs to be tied to the existing document
+    let current_doc = cx.editor.documents.get_mut(doc);
+
+    if let Some(current_doc) = current_doc {
+        if let Ok(url) = url::Url::from_str(uri.as_str()) {
+            current_doc.uri = Some(Box::new(url));
+        } else {
+            anyhow::bail!("Unable to parse uri: {:?}", uri);
+        }
+    }
+
+    Ok(())
+}
+
+fn cx_current_focus(cx: &mut Context) -> helix_view::ViewId {
+    cx.editor.tree.focus
+}
+
+fn cx_get_document_id(cx: &mut Context, view_id: helix_view::ViewId) -> DocumentId {
+    cx.editor.tree.get(view_id).doc
+}
+
+fn document_id_to_text(cx: &mut Context, doc_id: DocumentId) -> Option<SteelRopeSlice> {
+    cx.editor
+        .documents
+        .get(&doc_id)
+        .map(|x| SteelRopeSlice::new(x.text().clone()))
+}
+
+fn cx_is_document_in_view(cx: &mut Context, doc_id: DocumentId) -> Option<helix_view::ViewId> {
+    cx.editor
+        .tree
+        .traverse()
+        .find(|(_, v)| v.doc == doc_id)
+        .map(|(id, _)| id)
+}
+
+fn cx_register_value(cx: &mut Context, name: char) -> Vec<String> {
+    cx.editor
+        .registers
+        .read(name, cx.editor)
+        .map_or(Vec::new(), |reg| reg.collect())
+        .into_iter()
+        .map(|value| value.to_string())
+        .collect()
+}
+
+fn cx_document_exists(cx: &mut Context, doc_id: DocumentId) -> bool {
+    cx.editor.documents.get(&doc_id).is_some()
+}
+
+fn document_path(cx: &mut Context, doc_id: DocumentId) -> Option<String> {
+    cx.editor
+        .documents
+        .get(&doc_id)
+        .and_then(|doc| doc.path().and_then(|x| x.to_str()).map(|x| x.to_string()))
+}
+
+fn cx_editor_all_documents(cx: &mut Context) -> Vec<DocumentId> {
+    cx.editor.documents.keys().copied().collect()
+}
+
+fn cx_switch(cx: &mut Context, doc_id: DocumentId) {
+    cx.editor.switch(doc_id, Action::VerticalSplit)
+}
+
+fn cx_switch_action(cx: &mut Context, doc_id: DocumentId, action: Action) {
+    cx.editor.switch(doc_id, action)
+}
+
+fn cx_get_mode(cx: &mut Context) -> Mode {
+    cx.editor.mode
+}
+
+fn cx_set_mode(cx: &mut Context, mode: Mode) {
+    cx.editor.mode = mode
+}
+
+// Overlay the dynamic component, see what happens?
+// Probably need to pin the values to this thread - wrap it in a shim which pins the value
+// to this thread? - call methods on the thread local value?
+fn push_component(cx: &mut Context, component: &mut WrappedDynComponent) {
+    log::info!("Pushing dynamic component!");
+
+    let inner = component.inner.take().unwrap();
+
+    let callback = async move {
+        let call: Box<dyn FnOnce(&mut Editor, &mut Compositor, &mut job::Jobs)> = Box::new(
+            move |_editor: &mut Editor, compositor: &mut Compositor, _| compositor.push(inner),
+        );
+        Ok(call)
+    };
+    cx.jobs.local_callback(callback);
+}
+
+fn pop_last_component_by_name(cx: &mut Context, name: SteelString) {
+    let callback = async move {
+        let call: Box<dyn FnOnce(&mut Editor, &mut Compositor, &mut job::Jobs)> = Box::new(
+            move |_editor: &mut Editor, compositor: &mut Compositor, _jobs: &mut job::Jobs| {
+                compositor.remove_by_dynamic_name(&name);
+            },
+        );
+        Ok(call)
+    };
+    cx.jobs.local_callback(callback);
+}
+
+fn set_status(cx: &mut Context, value: SteelVal) {
+    match value {
+        SteelVal::StringV(s) => cx.editor.set_status(s.as_ref().to_owned()),
+        _ => cx.editor.set_status(value.to_string()),
+    }
+}
+
+fn set_warning(cx: &mut Context, value: SteelVal) {
+    match value {
+        SteelVal::StringV(s) => cx.editor.set_warning(s.as_ref().to_owned()),
+        _ => cx.editor.set_warning(value.to_string()),
+    }
+}
+
+fn set_error(cx: &mut Context, value: SteelVal) {
+    match value {
+        SteelVal::StringV(s) => cx.editor.set_error(s.as_ref().to_owned()),
+        _ => cx.editor.set_error(value.to_string()),
+    }
+}
+
+fn enqueue_command(cx: &mut Context, callback_fn: SteelVal) {
+    let rooted = callback_fn.as_rooted();
+
+    let callback = async move {
+        let call: Box<dyn FnOnce(&mut Editor, &mut Compositor, &mut job::Jobs)> = Box::new(
+            move |editor: &mut Editor, _compositor: &mut Compositor, jobs: &mut job::Jobs| {
+                let mut ctx = Context {
+                    register: None,
+                    count: None,
+                    editor,
+                    callback: Vec::new(),
+                    on_next_key_callback: None,
+                    jobs,
+                };
+
+                let cloned_func = rooted.value();
+
+                enter_engine(|guard| {
+                    if let Err(e) = guard
+                        .with_mut_reference::<Context, Context>(&mut ctx)
+                        .consume(move |engine, args| {
+                            let context = args[0].clone();
+                            engine.update_value("*helix.cx*", context);
+
+                            engine.call_function_with_args(cloned_func.clone(), Vec::new())
+                        })
+                    {
+                        present_error_inside_engine_context(&mut ctx, guard, e);
+                    }
+                })
+            },
+        );
+        Ok(call)
+    };
+    cx.jobs.local_callback(callback);
+}
+
+// Apply arbitrary delay for update rate...
+fn enqueue_command_with_delay(cx: &mut Context, delay: SteelVal, callback_fn: SteelVal) {
+    let rooted = callback_fn.as_rooted();
+
+    let callback = async move {
+        let delay = delay.int_or_else(|| panic!("FIX ME")).unwrap();
+
+        tokio::time::sleep(tokio::time::Duration::from_millis(delay as u64)).await;
+
+        let call: Box<dyn FnOnce(&mut Editor, &mut Compositor, &mut job::Jobs)> = Box::new(
+            move |editor: &mut Editor, _compositor: &mut Compositor, jobs: &mut job::Jobs| {
+                let mut ctx = Context {
+                    register: None,
+                    count: None,
+                    editor,
+                    callback: Vec::new(),
+                    on_next_key_callback: None,
+                    jobs,
+                };
+
+                let cloned_func = rooted.value();
+
+                enter_engine(|guard| {
+                    if let Err(e) = guard
+                        .with_mut_reference::<Context, Context>(&mut ctx)
+                        .consume(move |engine, args| {
+                            let context = args[0].clone();
+                            engine.update_value("*helix.cx*", context);
+
+                            engine.call_function_with_args(cloned_func.clone(), Vec::new())
+                        })
+                    {
+                        present_error_inside_engine_context(&mut ctx, guard, e);
+                    }
+                })
+            },
+        );
+        Ok(call)
+    };
+    cx.jobs.local_callback(callback);
+}
+
+// value _must_ be a future here. Otherwise awaiting will cause problems!
+fn await_value(cx: &mut Context, value: SteelVal, callback_fn: SteelVal) {
+    if !value.is_future() {
+        return;
+    }
+
+    let rooted = callback_fn.as_rooted();
+
+    let callback = async move {
+        let future_value = value.as_future().unwrap().await;
+
+        let call: Box<dyn FnOnce(&mut Editor, &mut Compositor, &mut job::Jobs)> = Box::new(
+            move |editor: &mut Editor, _compositor: &mut Compositor, jobs: &mut job::Jobs| {
+                let mut ctx = Context {
+                    register: None,
+                    count: None,
+                    editor,
+                    callback: Vec::new(),
+                    on_next_key_callback: None,
+                    jobs,
+                };
+
+                let cloned_func = rooted.value();
+
+                match future_value {
+                    Ok(inner) => {
+                        let callback = move |engine: &mut Engine, args: Vec<SteelVal>| {
+                            let context = args[0].clone();
+                            engine.update_value("*helix.cx*", context);
+                            engine.call_function_with_args(cloned_func.clone(), vec![inner])
+                        };
+
+                        enter_engine(|guard| {
+                            if let Err(e) = guard
+                                .with_mut_reference::<Context, Context>(&mut ctx)
+                                .consume_once(callback)
+                            {
+                                present_error_inside_engine_context(&mut ctx, guard, e);
+                            }
+                        })
+                    }
+                    Err(e) => enter_engine(|x| present_error_inside_engine_context(&mut ctx, x, e)),
+                }
+            },
+        );
+        Ok(call)
+    };
+    cx.jobs.local_callback(callback);
+}
+// Check that we successfully created a directory?
+fn create_directory(path: String) {
+    let path = helix_stdx::path::canonicalize(&PathBuf::from(path));
+
+    if path.exists() {
+        return;
+    } else {
+        std::fs::create_dir(path).unwrap();
+    }
+}
+
+pub fn cx_pos_within_text(cx: &mut Context) -> usize {
+    let (view, doc) = current_ref!(cx.editor);
+
+    let text = doc.text().slice(..);
+
+    let selection = doc.selection(view.id).clone();
+
+    let pos = selection.primary().cursor(text);
+
+    pos
+}
+
+pub fn get_helix_cwd(_cx: &mut Context) -> Option<String> {
+    helix_stdx::env::current_working_dir()
+        .as_os_str()
+        .to_str()
+        .map(|x| x.into())
+}
+
+// Special newline...
+pub fn custom_insert_newline(cx: &mut Context, indent: String) {
+    let (view, doc) = current_ref!(cx.editor);
+
+    // let rope = doc.text().clone();
+
+    let text = doc.text().slice(..);
+
+    let contents = doc.text();
+    let selection = doc.selection(view.id).clone();
+    let mut ranges = helix_core::SmallVec::with_capacity(selection.len());
+
+    // TODO: this is annoying, but we need to do it to properly calculate pos after edits
+    let mut global_offs = 0;
+
+    let mut transaction =
+        helix_core::Transaction::change_by_selection(contents, &selection, |range| {
+            let pos = range.cursor(text);
+
+            let prev = if pos == 0 {
+                ' '
+            } else {
+                contents.char(pos - 1)
+            };
+            let curr = contents.get_char(pos).unwrap_or(' ');
+
+            let current_line = text.char_to_line(pos);
+            let line_is_only_whitespace = text
+                .line(current_line)
+                .chars()
+                .all(|char| char.is_ascii_whitespace());
+
+            let mut new_text = String::new();
+
+            // If the current line is all whitespace, insert a line ending at the beginning of
+            // the current line. This makes the current line empty and the new line contain the
+            // indentation of the old line.
+            let (from, to, local_offs) = if line_is_only_whitespace {
+                let line_start = text.line_to_char(current_line);
+                new_text.push_str(doc.line_ending.as_str());
+
+                (line_start, line_start, new_text.chars().count())
+            } else {
+                // If we are between pairs (such as brackets), we want to
+                // insert an additional line which is indented one level
+                // more and place the cursor there
+                let on_auto_pair = doc
+                    .auto_pairs(cx.editor)
+                    .and_then(|pairs| pairs.get(prev))
+                    .map_or(false, |pair| pair.open == prev && pair.close == curr);
+
+                let local_offs = if on_auto_pair {
+                    let inner_indent = indent.clone() + doc.indent_style.as_str();
+                    new_text.reserve_exact(2 + indent.len() + inner_indent.len());
+                    new_text.push_str(doc.line_ending.as_str());
+                    new_text.push_str(&inner_indent);
+                    let local_offs = new_text.chars().count();
+                    new_text.push_str(doc.line_ending.as_str());
+                    new_text.push_str(&indent);
+                    local_offs
+                } else {
+                    new_text.reserve_exact(1 + indent.len());
+                    new_text.push_str(doc.line_ending.as_str());
+                    new_text.push_str(&indent);
+                    new_text.chars().count()
+                };
+
+                (pos, pos, local_offs)
+            };
+
+            let new_range = if doc.restore_cursor {
+                // when appending, extend the range by local_offs
+                Range::new(
+                    range.anchor + global_offs,
+                    range.head + local_offs + global_offs,
+                )
+            } else {
+                // when inserting, slide the range by local_offs
+                Range::new(
+                    range.anchor + local_offs + global_offs,
+                    range.head + local_offs + global_offs,
+                )
+            };
+
+            // TODO: range replace or extend
+            // range.replace(|range| range.is_empty(), head); -> fn extend if cond true, new head pos
+            // can be used with cx.mode to do replace or extend on most changes
+            ranges.push(new_range);
+            global_offs += new_text.chars().count();
+
+            (from, to, Some(new_text.into()))
+        });
+
+    transaction = transaction.with_selection(Selection::new(ranges, selection.primary_index()));
+
+    let (view, doc) = current!(cx.editor);
+    doc.apply(&transaction, view.id);
+}
+
+// fn search_in_directory(cx: &mut Context, directory: String) {
+//     let buf = PathBuf::from(directory);
+//     let search_path = expand_tilde(&buf);
+//     let path = search_path.to_path_buf();
+//     crate::commands::search_in_directory(cx, path);
+// }
+
+// TODO: Result should create unrecoverable result, and should have a special
+// recoverable result - that way we can handle both, not one in particular
+fn regex_selection(cx: &mut Context, regex: String) {
+    if let Ok(regex) = helix_stdx::rope::Regex::new(&regex) {
+        let (view, doc) = current!(cx.editor);
+        let text = doc.text().slice(..);
+        if let Some(selection) =
+            helix_core::selection::select_on_matches(text, doc.selection(view.id), &regex)
+        {
+            doc.set_selection(view.id, selection);
+        }
+    }
+}
+
+fn replace_selection(cx: &mut Context, value: String) {
+    let (view, doc) = current!(cx.editor);
+
+    let selection = doc.selection(view.id);
+    let transaction =
+        helix_core::Transaction::change_by_selection(doc.text(), selection, |range| {
+            if !range.is_empty() {
+                (range.from(), range.to(), Some(value.to_owned().into()))
+            } else {
+                (range.from(), range.to(), None)
+            }
+        });
+
+    doc.apply(&transaction, view.id);
+}
+
+// TODO: Remove this!
+fn move_window_to_the_left(cx: &mut Context) {
+    while cx
+        .editor
+        .tree
+        .swap_split_in_direction(helix_view::tree::Direction::Left)
+        .is_some()
+    {}
+}
+
+// TODO: Remove this!
+fn move_window_to_the_right(cx: &mut Context) {
+    while cx
+        .editor
+        .tree
+        .swap_split_in_direction(helix_view::tree::Direction::Right)
+        .is_some()
+    {}
+}
+
+fn send_arbitrary_lsp_command(
+    cx: &mut Context,
+    name: SteelString,
+    command: SteelString,
+    // Arguments - these will be converted to some json stuff
+    json_argument: Option<SteelVal>,
+    callback_fn: SteelVal,
+) -> anyhow::Result<()> {
+    let argument = json_argument.map(|x| serde_json::Value::try_from(x).unwrap());
+
+    let (_view, doc) = current!(cx.editor);
+
+    let language_server_id = anyhow::Context::context(
+        doc.language_servers().find(|x| x.name() == name.as_str()),
+        "Unable to find the language server specified!",
+    )?
+    .id();
+
+    let future = match cx
+        .editor
+        .language_server_by_id(language_server_id)
+        .and_then(|language_server| {
+            language_server.non_standard_extension(command.to_string(), argument)
+        }) {
+        Some(future) => future,
+        None => {
+            // TODO: Come up with a better message once we check the capabilities for
+            // the arbitrary thing you're trying to do, since for now the above actually
+            // always returns a `Some`
+            cx.editor.set_error(
+                "Language server does not support whatever command you just tried to do",
+            );
+            return Ok(());
+        }
+    };
+
+    let rooted = callback_fn.as_rooted();
+
+    create_callback(cx, future, rooted)?;
+
+    Ok(())
+}
+
+fn create_callback<T: TryInto<SteelVal, Error = SteelErr> + 'static>(
+    cx: &mut Context,
+    future: impl std::future::Future<Output = Result<T, helix_lsp::Error>> + 'static,
+    rooted: steel::RootedSteelVal,
+) -> Result<(), anyhow::Error> {
+    let callback = async move {
+        // Result of the future - this will be whatever we get back
+        // from the lsp call
+        let res = future.await?;
+
+        let call: Box<dyn FnOnce(&mut Editor, &mut Compositor, &mut job::Jobs)> = Box::new(
+            move |editor: &mut Editor, _compositor: &mut Compositor, jobs: &mut job::Jobs| {
+                let mut ctx = Context {
+                    register: None,
+                    count: None,
+                    editor,
+                    callback: Vec::new(),
+                    on_next_key_callback: None,
+                    jobs,
+                };
+
+                let cloned_func = rooted.value();
+
+                enter_engine(move |guard| match TryInto::<SteelVal>::try_into(res) {
+                    Ok(result) => {
+                        if let Err(e) = guard
+                            .with_mut_reference::<Context, Context>(&mut ctx)
+                            .consume(move |engine, args| {
+                                let context = args[0].clone();
+                                engine.update_value("*helix.cx*", context);
+
+                                engine.call_function_with_args(
+                                    cloned_func.clone(),
+                                    vec![result.clone()],
+                                )
+                            })
+                        {
+                            present_error_inside_engine_context(&mut ctx, guard, e);
+                        }
+                    }
+                    Err(e) => {
+                        present_error_inside_engine_context(&mut ctx, guard, e);
+                    }
+                })
+            },
+        );
+        Ok(call)
+    };
+    cx.jobs.local_callback(callback);
+    Ok(())
+}
+
+// "add-inlay-hint",
+pub fn add_inlay_hint(
+    cx: &mut Context,
+    char_index: usize,
+    completion: SteelString,
+) -> Option<(usize, usize)> {
+    let view_id = cx.editor.tree.focus;
+    if !cx.editor.tree.contains(view_id) {
+        return None;
+    }
+    let view = cx.editor.tree.get(view_id);
+    let doc_id = cx.editor.tree.get(view_id).doc;
+    let doc = cx.editor.documents.get_mut(&doc_id)?;
+    let mut new_inlay_hints = doc
+        .inlay_hints(view_id)
+        .map(|x| x.clone())
+        .unwrap_or_else(|| {
+            let doc_text = doc.text();
+            let len_lines = doc_text.len_lines();
+
+            let view_height = view.inner_height();
+            let first_visible_line =
+                doc_text.char_to_line(doc.view_offset(view_id).anchor.min(doc_text.len_chars()));
+            let first_line = first_visible_line.saturating_sub(view_height);
+            let last_line = first_visible_line
+                .saturating_add(view_height.saturating_mul(2))
+                .min(len_lines);
+
+            let new_doc_inlay_hints_id = DocumentInlayHintsId {
+                first_line,
+                last_line,
+            };
+
+            DocumentInlayHints::empty_with_id(new_doc_inlay_hints_id)
+        });
+
+    // TODO: The inlay hints should actually instead return the id?
+    new_inlay_hints
+        .other_inlay_hints
+        .push(InlineAnnotation::new(char_index, completion.to_string()));
+
+    let id = new_inlay_hints.id;
+
+    doc.set_inlay_hints(view_id, new_inlay_hints);
+
+    Some((id.first_line, id.last_line))
+}
+
+pub fn remove_inlay_hint_by_id(
+    cx: &mut Context,
+    first_line: usize,
+    last_line: usize,
+) -> Option<()> {
+    // let text = completion.to_string();
+    let view_id = cx.editor.tree.focus;
+    if !cx.editor.tree.contains(view_id) {
+        return None;
+    }
+    let view = cx.editor.tree.get(view_id);
+    let doc_id = cx.editor.tree.get(view_id).doc;
+    let doc = cx.editor.documents.get_mut(&doc_id)?;
+
+    let inlay_hints = doc.inlay_hints(view_id)?;
+    let id = DocumentInlayHintsId {
+        first_line,
+        last_line,
+    };
+
+    if inlay_hints.id == id {
+        let doc_text = doc.text();
+        let len_lines = doc_text.len_lines();
+
+        let view_height = view.inner_height();
+        let first_visible_line =
+            doc_text.char_to_line(doc.view_offset(view_id).anchor.min(doc_text.len_chars()));
+        let first_line = first_visible_line.saturating_sub(view_height);
+        let last_line = first_visible_line
+            .saturating_add(view_height.saturating_mul(2))
+            .min(len_lines);
+
+        let new_doc_inlay_hints_id = DocumentInlayHintsId {
+            first_line,
+            last_line,
+        };
+
+        doc.set_inlay_hints(
+            view_id,
+            DocumentInlayHints::empty_with_id(new_doc_inlay_hints_id),
+        );
+
+        return Some(());
+    }
+
+    return None;
+}
+
+// "remove-inlay-hint",
+pub fn remove_inlay_hint(cx: &mut Context, char_index: usize, _completion: SteelString) -> bool {
+    // let text = completion.to_string();
+    let view_id = cx.editor.tree.focus;
+    if !cx.editor.tree.contains(view_id) {
+        return false;
+    }
+    let doc_id = cx.editor.tree.get_mut(view_id).doc;
+    let doc = match cx.editor.documents.get_mut(&doc_id) {
+        Some(x) => x,
+        None => return false,
+    };
+
+    let inlay_hints = match doc.inlay_hints(view_id) {
+        Some(inlay_hints) => inlay_hints,
+        None => return false,
+    };
+    let mut new_inlay_hints = inlay_hints.clone();
+    new_inlay_hints
+        .other_inlay_hints
+        .retain(|x| x.char_idx != char_index);
+    doc.set_inlay_hints(view_id, new_inlay_hints);
+    true
+}
diff --git a/helix-term/src/commands/engine/themes.scm b/helix-term/src/commands/engine/themes.scm
new file mode 100644
index 000000000..a92a321c3
--- /dev/null
+++ b/helix-term/src/commands/engine/themes.scm
@@ -0,0 +1,382 @@
+(require-builtin helix/core/themes)
+(require-builtin helix/components)
+
+(provide attribute
+         type
+         type.builtin
+         type.parameter
+         type.enum
+         type.enum.variant
+         constructor
+         constant
+         constant.builtin
+         constant.builtin.boolean
+         constant.character
+         constant.character.escape
+         constant.numeric
+         constant.numeric.integer
+         constant.numeric.float
+         string
+         string.regexp
+         string.special
+         string.special.path
+         string.special.url
+         string.special.symbol
+         comment
+         comment.line
+         comment.block
+         comment.block.documentation
+         variable
+         variable.builtin
+         variable.parameter
+         variable.other
+         variable.other.member
+         variable.other.member.private
+         label
+         punctuation
+         punctuation.delimiter
+         punctuation.bracket
+         punctuation.special
+         keyword
+         keyword.control
+         keyword.control.conditional
+         keyword.control.repeat
+         keyword.control.import
+         keyword.control.return
+         keyword.control.exception
+         keyword.operator
+         keyword.directive
+         keyword.function
+         keyword.storage
+         keyword.storage.type
+         keyword.storage.modifier
+         operator
+         function
+         function.builtin
+         function.method
+         function.method.private
+         function.macro
+         function.special
+         tag
+         tag.builtin
+         namespace
+         special
+         markup
+         markup.heading
+         markup.heading.marker
+         markup.heading.marker.1
+         markup.heading.marker.2
+         markup.heading.marker.3
+         markup.heading.marker.4
+         markup.heading.marker.5
+         markup.heading.marker.6
+         markup.list
+         markup.list.unnumbered
+         markup.list.numbered
+         markup.list.checked
+         markup.list.unchecked
+         markup.bold
+         markup.italic
+         markup.strikethrough
+         markup.link
+         markup.link.url
+         markup.link.label
+         markup.link.text
+         markup.quote
+         markup.raw
+         markup.raw.inline
+         markup.raw.block
+         diff
+         diff.plus
+         diff.plus.gutter
+         diff.minus
+         diff.minus.gutter
+         diff.delta
+         diff.delta.moved
+         diff.delta.conflict
+         diff.delta.gutter
+         markup.normal.completion
+         markup.normal.hover
+         markup.heading.completion
+         markup.heading.hover
+         markup.raw.inline.completion
+         markup.raw.inline.hover
+         ui.background
+         ui.background.separator
+         ui.cursor
+         ui.cursor.insert
+         ui.cursor.select
+         ui.cursor.match
+         ui.cursor.primary
+         ui.cursor.primary.normal
+         ui.cursor.primary.insert
+         ui.cursor.primary.select
+         ui.debug.breakpoint
+         ui.debug.active
+         ui.gutter
+         ui.gutter.selected
+         ui.highlight.frameline
+         ui.linenr
+         ui.linenr.selected
+         ui.statusline
+         ui.statusline.inactive
+         ui.statusline.normal
+         ui.statusline.insert
+         ui.statusline.select
+         ui.statusline.separator
+         ui.bufferline
+         ui.bufferline.active
+         ui.bufferline.background
+         ui.popup
+         ui.popup.info
+         ui.window
+         ui.help
+         ui.text
+         ui.text.focus
+         ui.text.inactive
+         ui.text.info
+         ui.virtual.ruler
+         ui.virtual.whitespace
+         ui.virtual.indent-guide
+         ui.virtual.inlay-hint
+         ui.virtual.inlay-hint.parameter
+         ui.virtual.inlay-hint.type
+         ui.virtual.wrap
+         ui.virtual.jump-label
+         ui.menu
+         ui.menu.selected
+         ui.menu.scroll
+         ui.selection
+         ui.selection.primary
+         ui.highlight
+         ui.cursorline
+         ui.cursorline.primary
+         ui.cursorline.secondary
+         ui.cursorcolumn.primary
+         ui.cursorcolumn.secondary
+         warning
+         error
+         info
+         hint
+         diagnostic
+         diagnostic.hint
+         diagnostic.info
+         diagnostic.warning
+         diagnostic.error
+         diagnostic.unnecessary
+         diagnostic.deprecated)
+
+(provide hashmap->theme
+         register-theme
+         theme-style
+         theme-set-style!
+         string->color)
+
+;;@doc
+;; Register this theme with helix for use
+(define (register-theme theme)
+  (add-theme! *helix.cx* theme))
+
+(define-syntax theme-func
+  (syntax-rules ()
+    [(_ scope doc-string)
+     (@doc doc-string
+           (define (scope theme style)
+             (theme-set-style! theme (quote scope) style)
+             theme))]
+
+    [(_ scope)
+     (define (scope theme style)
+       (theme-set-style! theme (quote scope) style)
+       theme)]))
+
+(theme-func attribute "Class attributes, HTML tag attributes")
+(theme-func type "Types")
+(theme-func type.builtin "Primitive types provided by the language (`int`, `usize`)")
+(theme-func type.parameter "Generic type parameters (`T`)")
+(theme-func type.enum "Enum usage")
+(theme-func type.enum.variant "Enum variant")
+(theme-func constructor "Constructor usage")
+(theme-func constant "Constants usage")
+(theme-func constant.builtin
+            "Special constants provided by the language (`true`, `false`, `nil`, etc)")
+(theme-func constant.builtin.boolean "A special case for highlighting individual booleans")
+(theme-func constant.character "Character usage")
+(theme-func constant.character.escape "Highlighting individual escape characters")
+(theme-func constant.numeric "Numbers")
+(theme-func constant.numeric.integer "Integers")
+(theme-func constant.numeric.float "Floats")
+(theme-func string "Highlighting strings")
+(theme-func string.regexp "Highlighting regular expressions")
+(theme-func string.special "Special strings")
+(theme-func string.special.path "Highlighting paths")
+(theme-func string.special.url "Highlighting URLs")
+(theme-func string.special.symbol "Erlang/Elixir atoms, Ruby symbols, Clojure keywords")
+(theme-func comment "Highlighting comments")
+(theme-func comment.line "Single line comments (`//`)")
+(theme-func comment.block "Block comments (`/* */`)")
+(theme-func comment.block.documentation "Documentation comments (e.g. `///` in Rust)")
+(theme-func variable "Variables")
+(theme-func variable.builtin "Reserved language variables (`self`, `this`, `super`, etc.)")
+(theme-func variable.parameter "Function parameters")
+(theme-func variable.other "Other variables")
+(theme-func variable.other.member "Fields of composite data types (e.g. structs, unions)")
+(theme-func variable.other.member.private
+            "Private fields that use a unique syntax (currently just EMCAScript-based languages)")
+
+(theme-func label "Highlighting labels")
+(theme-func punctuation "Highlighting punctuation")
+(theme-func punctuation.delimiter "Commas, colon")
+(theme-func punctuation.bracket "Parentheses, angle brackets, etc.")
+(theme-func punctuation.special "String interpolation brackets")
+
+(theme-func keyword "Highlighting keywords")
+(theme-func keyword.control "Control keywords")
+(theme-func keyword.control.conditional "if, else")
+(theme-func keyword.control.repeat "for, while, loop")
+(theme-func keyword.control.import "import, export")
+(theme-func keyword.control.return "return keyword")
+(theme-func keyword.control.exception "exception keyword")
+
+(theme-func keyword.operator "or, in")
+(theme-func keyword.directive "Preprocessor directives (`#if` in C)")
+(theme-func keyword.function "fn, func")
+(theme-func keyword.storage "Keywords describing how things are stored")
+(theme-func keyword.storage.type "The type of something, `class`, `function`, `var`, `let`, etc")
+(theme-func keyword.storage.modifier "Storage modifiers like `static`, `mut`, `const`, `ref`, etc")
+
+(theme-func operator "Operators such as `||`, `+=`, `>`, etc")
+(theme-func function "Highlighting function calls")
+(theme-func function.builtin "Builtin functions")
+(theme-func function.method "Calling methods")
+(theme-func function.method.private
+            "Private methods that use a unique syntax (currently just ECMAScript-based languages)")
+(theme-func function.macro "Highlighting macros")
+(theme-func function.special "Preprocessor in C")
+
+(theme-func tag "Tags (e.g. <body> in HTML)")
+(theme-func tag.builtin "Builtin tags")
+
+(theme-func namespace)
+(theme-func special)
+(theme-func markup "Highlighting markdown")
+(theme-func markup.heading "Markdown heading")
+(theme-func markup.heading.marker "Markdown heading marker")
+(theme-func markup.heading.marker.1 "Markdown heading text h1")
+(theme-func markup.heading.marker.2 "Markdown heading text h2")
+(theme-func markup.heading.marker.3 "Markdown heading text h3")
+(theme-func markup.heading.marker.4 "Markdown heading text h4")
+(theme-func markup.heading.marker.5 "Markdown heading text h5")
+(theme-func markup.heading.marker.6 "Markdown heading text h6")
+
+(theme-func markup.list "Markdown lists")
+(theme-func markup.list.unnumbered "Unnumbered markdown lists")
+(theme-func markup.list.numbered "Numbered markdown lists")
+(theme-func markup.list.checked "Checked markdown lists")
+(theme-func markup.list.unchecked "Unchecked markdown lists")
+
+(theme-func markup.bold "Markdown bold")
+(theme-func markup.italic "Markdown italics")
+(theme-func markup.strikethrough "Markdown strikethrough")
+(theme-func markup.link "Markdown links")
+(theme-func markup.link.url "URLs pointed to by links")
+(theme-func markup.link.label "non-URL link references")
+(theme-func markup.link.text "URL and image descriptions in links")
+(theme-func markup.quote "Markdown quotes")
+(theme-func markup.raw "Markdown raw")
+(theme-func markup.raw.inline "Markdown inline raw")
+(theme-func markup.raw.block "Markdown raw block")
+
+(theme-func diff "Version control changes")
+(theme-func diff.plus "Version control additions")
+(theme-func diff.plus.gutter "Version control addition gutter indicator")
+(theme-func diff.minus "Version control deletions")
+(theme-func diff.minus.gutter "Version control deletion gutter indicator")
+(theme-func diff.delta "Version control modifications")
+(theme-func diff.delta.moved "Renamed or moved files/changes")
+(theme-func diff.delta.conflict "Merge conflicts")
+(theme-func diff.delta.gutter "Gutter indicator")
+
+(theme-func markup.normal.completion "For completion doc popup UI")
+(theme-func markup.normal.hover "For hover popup UI")
+(theme-func markup.heading.completion "For completion doc popup UI")
+(theme-func markup.heading.hover "For hover popup UI")
+(theme-func markup.raw.inline.completion "For completion doc popup UI")
+(theme-func markup.raw.inline.hover "For hover popup UI")
+
+(theme-func ui.background)
+(theme-func ui.background.separator "Picker separator below input line")
+(theme-func ui.cursor)
+(theme-func ui.cursor.normal)
+(theme-func ui.cursor.insert)
+(theme-func ui.cursor.select)
+(theme-func ui.cursor.match "Matching bracket etc.")
+(theme-func ui.cursor.primary "Cursor with primary selection")
+(theme-func ui.cursor.primary.normal)
+(theme-func ui.cursor.primary.insert)
+(theme-func ui.cursor.primary.select)
+
+(theme-func ui.debug.breakpoint "Breakpoint indicator, found in the gutter")
+(theme-func ui.debug.active
+            "Indicator for the line at which debugging execution is paused at, found in the gutter")
+(theme-func ui.gutter "Gutter")
+(theme-func ui.gutter.selected "Gutter for the line the cursor is on")
+(theme-func ui.highlight.frameline "Line at which debugging execution is paused at")
+(theme-func ui.linenr "Line numbers")
+(theme-func ui.linenr.selected "Line number for the line the cursor is on")
+(theme-func ui.statusline "Statusline")
+(theme-func ui.statusline.inactive "Statusline (unfocused document)")
+(theme-func ui.statusline.normal
+            "Statusline mode during normal mode (only if editor.color-modes is enabled)")
+(theme-func ui.statusline.insert
+            "Statusline mode during insert mode (only if editor.color-modes is enabled)")
+(theme-func ui.statusline.select
+            "Statusline mode during select mode (only if editor.color-modes is enabled)")
+
+(theme-func ui.statusline.separator "Separator character in statusline")
+(theme-func ui.bufferline "Style for the buffer line")
+(theme-func ui.bufferline.active "Style for the active buffer in buffer line")
+(theme-func ui.bufferline.background "Style for the bufferline background")
+(theme-func ui.popup "Documentation popups (e.g. Space + k)")
+(theme-func ui.popup.info "Prompt for multiple key options")
+(theme-func ui.window "Borderline separating splits")
+(theme-func ui.help "Description box for commands")
+(theme-func ui.text "Default text style, command prompts, popup text, etc.")
+(theme-func ui.text.focus "The currently selected line in the picker")
+(theme-func ui.text.inactive "Same as ui.text but when the text is inactive (e.g. suggestions)")
+(theme-func ui.text.info "The key: command text in ui.popup.info boxes")
+(theme-func ui.virtual.ruler "Ruler columns (see the editor.rules config)")
+(theme-func ui.virtual.whitespace "Visible whitespace characters")
+(theme-func ui.virtual.indent-guide "Vertical indent width guides")
+(theme-func ui.virtual.inlay-hint "Default style for inlay hints of all kinds")
+(theme-func ui.virtual.inlay-hint.parameter
+            "Style for inlay hints of kind `parameter` (LSPs are not rquired to set a kind)")
+(theme-func ui.virtual.inlay-hint.type
+            "Style for inlay hints of kind `type` (LSPs are not required to set a kind)")
+(theme-func ui.virtual.wrap "Soft-wrap indicator (see the editor.soft-wrap config)")
+(theme-func ui.virtual.jump-label "Style for virtual jump labels")
+(theme-func ui.menu "Code and command completion menus")
+(theme-func ui.menu.selected "Selected autocomplete item")
+(theme-func ui.menu.scroll "fg sets thumb color, bg sets track color of scrollbar")
+(theme-func ui.selection "For selections in the editing area")
+(theme-func ui.selection.primary)
+(theme-func ui.highlight "Highlighted lines in the picker preview")
+(theme-func ui.cursorline "The line of the cursor (if cursorline is enabled)")
+(theme-func ui.cursorline.primary "The line of the primary cursor (if cursorline is enabled)")
+(theme-func ui.cursorline.secondary "The line of the secondary cursor (if cursorline is enabled)")
+(theme-func ui.cursorcolumn.primary "The column of the primary cursor (if cursorcolumn is enabled)")
+(theme-func ui.cursorcolumn.secondary
+            "The column of the secondary cursor (if cursorcolumn is enabled)")
+
+(theme-func warning "Diagnostics warning (gutter)")
+(theme-func error "Diagnostics error (gutter)")
+(theme-func info "Diagnostics info (gutter)")
+(theme-func hint "Diagnostics hint (gutter)")
+
+(theme-func diagnostic "Diagnostics fallback style (editing area)")
+(theme-func diagnostic.hint "Diagnostics hint (editing area)")
+(theme-func diagnostic.info "Diagnostics info (editing area)")
+(theme-func diagnostic.warning "Diagnostics warning (editing area)")
+(theme-func diagnostic.error "Diagnostics error (editing area)")
+(theme-func diagnostic.unnecessary "Diagnostics with unnecessary tag (editing area)")
+(theme-func diagnostic.deprecated "Diagnostics with deprecated tag (editing area)")
diff --git a/helix-term/src/commands/typed.rs b/helix-term/src/commands/typed.rs
index e1bb8ee32..5c1f5865a 100644
--- a/helix-term/src/commands/typed.rs
+++ b/helix-term/src/commands/typed.rs
@@ -1,4 +1,3 @@
-use std::fmt::Write;
 use std::io::BufReader;
 use std::ops::{self, Deref};
 
@@ -17,6 +16,8 @@
 use serde_json::Value;
 use ui::completers::{self, Completer};
 
+use std::fmt::Write;
+
 #[derive(Clone)]
 pub struct TypableCommand {
     pub name: &'static str,
@@ -48,21 +49,21 @@ pub struct CommandCompleter {
 }
 
 impl CommandCompleter {
-    const fn none() -> Self {
+    pub const fn none() -> Self {
         Self {
             positional_args: &[],
             var_args: completers::none,
         }
     }
 
-    const fn positional(completers: &'static [Completer]) -> Self {
+    pub const fn positional(completers: &'static [Completer]) -> Self {
         Self {
             positional_args: completers,
             var_args: completers::none,
         }
     }
 
-    const fn all(completer: Completer) -> Self {
+    pub const fn all(completer: Completer) -> Self {
         Self {
             positional_args: &[],
             var_args: completer,
@@ -670,6 +671,8 @@ pub(super) fn buffers_remaining_impl(editor: &mut Editor) -> anyhow::Result<()>
     let modified_ids: Vec<_> = editor
         .documents()
         .filter(|doc| doc.is_modified())
+        // Named scratch documents should not be included here
+        .filter(|doc| doc.name.is_none())
         .map(|doc| doc.id())
         .collect();
 
@@ -722,7 +725,13 @@ pub fn write_all_impl(
             if !doc.is_modified() {
                 return None;
             }
-            if doc.path().is_none() {
+
+            // This is a named buffer. We'll skip it in the saves for now
+            if doc.name.is_some() {
+                return None;
+            }
+
+            if doc.path().is_none() && doc.name.is_none() {
                 if options.write_scratch {
                     errors.push("cannot write a buffer without a filename");
                 }
@@ -926,21 +935,42 @@ fn theme(cx: &mut compositor::Context, args: Args, event: PromptEvent) -> anyhow
                 // Ensures that a preview theme gets cleaned up if the user backspaces until the prompt is empty.
                 cx.editor.unset_theme_preview();
             } else if let Some(theme_name) = args.first() {
-                if let Ok(theme) = cx.editor.theme_loader.load(theme_name) {
+                // if let Ok(theme) = cx.editor.theme_loader.load(theme_name) {
+                //     if !(true_color || theme.is_16_color()) {
+                //         bail!("Unsupported theme: theme requires true color support");
+                //     }
+                //     cx.editor.set_theme_preview(theme);
+                // };
+
+                if let Ok(theme) = cx.editor.theme_loader.load(theme_name).or_else(|_| {
+                    cx.editor
+                        .user_defined_themes
+                        .get(theme_name)
+                        .ok_or_else(|| anyhow::anyhow!("Could not load theme"))
+                        .cloned()
+                }) {
                     if !(true_color || theme.is_16_color()) {
                         bail!("Unsupported theme: theme requires true color support");
                     }
                     cx.editor.set_theme_preview(theme);
-                };
+                }
             };
         }
         PromptEvent::Validate => {
             if let Some(theme_name) = args.first() {
-                let theme = cx
-                    .editor
-                    .theme_loader
-                    .load(theme_name)
-                    .map_err(|err| anyhow::anyhow!("Could not load theme: {}", err))?;
+                let theme = cx.editor.theme_loader.load(theme_name).or_else(|_| {
+                    cx.editor
+                        .user_defined_themes
+                        .get(theme_name)
+                        .ok_or_else(|| anyhow::anyhow!("Could not load theme"))
+                        .cloned()
+                })?;
+
+                // let theme = cx
+                //     .editor
+                //     .theme_loader
+                //     .load(theme_name)
+                //     .map_err(|err| anyhow::anyhow!("Could not load theme: {}", err))?;
                 if !(true_color || theme.is_16_color()) {
                     bail!("Unsupported theme: theme requires true color support");
                 }
@@ -3596,7 +3626,41 @@ fn execute_command_line(
 
     match typed::TYPABLE_COMMAND_MAP.get(command) {
         Some(cmd) => execute_command(cx, cmd, rest, event),
-        None if event == PromptEvent::Validate => Err(anyhow!("no such command: '{command}'")),
+        None if event == PromptEvent::Validate => {
+            let parts = rest.split_whitespace().collect::<Vec<_>>();
+
+            if ScriptingEngine::call_typed_command(cx, command, &parts, event) {
+                // Engine handles the other cases
+                if event == PromptEvent::Validate {
+                    let mappable_command = MappableCommand::Typable {
+                        name: input.to_string(),
+                        args: String::default(),
+                        doc: "".to_string(),
+                    };
+
+                    let mut ctx = Context {
+                        register: None,
+                        count: None,
+                        editor: cx.editor,
+                        callback: Vec::new(),
+                        on_next_key_callback: None,
+                        jobs: cx.jobs,
+                    };
+
+                    // // TODO: Figure this out?
+                    helix_event::dispatch(crate::events::PostCommand {
+                        command: &mappable_command,
+                        cx: &mut ctx,
+                    });
+
+                    Ok(())
+                } else {
+                    Ok(())
+                }
+            } else {
+                Err(anyhow!("no such command: '{command}'"))
+            }
+        }
         None => Ok(()),
     }
 }
@@ -3617,7 +3681,30 @@ pub(super) fn execute_command(
             .expect("arg parsing cannot fail when validation is turned off")
     };
 
-    (cmd.fun)(cx, args, event).map_err(|err| anyhow!("'{}': {err}", cmd.name))
+    let res = (cmd.fun)(cx, args, event).map_err(|err| anyhow!("'{}': {err}", cmd.name));
+
+    let mappable_command = MappableCommand::Typable {
+        name: cmd.name.to_string(),
+        args: String::new(),
+        doc: "".to_string(),
+    };
+
+    let mut ctx = Context {
+        register: None,
+        count: None,
+        editor: cx.editor,
+        callback: Vec::new(),
+        on_next_key_callback: None,
+        jobs: cx.jobs,
+    };
+
+    // // TODO: Figure this out?
+    helix_event::dispatch(crate::events::PostCommand {
+        command: &mappable_command,
+        cx: &mut ctx,
+    });
+
+    res
 }
 
 #[allow(clippy::unnecessary_unwrap)]
@@ -3640,8 +3727,14 @@ pub(super) fn command_mode(cx: &mut Context) {
 }
 
 fn command_line_doc(input: &str) -> Option<Cow<str>> {
-    let (command, _, _) = command_line::split(input);
-    let command = TYPABLE_COMMAND_MAP.get(command)?;
+    let (command_name, _, _) = command_line::split(input);
+    let command = TYPABLE_COMMAND_MAP.get(command_name);
+
+    if command.is_none() {
+        return ScriptingEngine::get_doc_for_identifier(command_name).map(|x| x.into());
+    }
+
+    let command = command?;
 
     if command.aliases.is_empty() && command.signature.flags.is_empty() {
         return Some(Cow::Borrowed(command.doc));
@@ -3717,7 +3810,10 @@ fn complete_command_line(editor: &Editor, input: &str) -> Vec<ui::prompt::Comple
     if complete_command {
         fuzzy_match(
             input,
-            TYPABLE_COMMAND_LIST.iter().map(|command| command.name),
+            TYPABLE_COMMAND_LIST
+                .iter()
+                .map(|command| Cow::from(command.name))
+                .chain(crate::commands::engine::ScriptingEngine::available_commands()),
             false,
         )
         .into_iter()
diff --git a/helix-term/src/compositor.rs b/helix-term/src/compositor.rs
index 28c8651a2..8da301e8b 100644
--- a/helix-term/src/compositor.rs
+++ b/helix-term/src/compositor.rs
@@ -13,6 +13,7 @@
 pub enum EventResult {
     Ignored(Option<Callback>),
     Consumed(Option<Callback>),
+    ConsumedWithoutRerender,
 }
 
 use crate::job::Jobs;
@@ -73,6 +74,10 @@ fn type_name(&self) -> &'static str {
     fn id(&self) -> Option<&'static str> {
         None
     }
+
+    fn name(&self) -> Option<&str> {
+        self.id()
+    }
 }
 
 pub struct Compositor {
@@ -136,6 +141,14 @@ pub fn remove(&mut self, id: &'static str) -> Option<Box<dyn Component>> {
         Some(self.layers.remove(idx))
     }
 
+    pub fn remove_by_dynamic_name(&mut self, id: &str) -> Option<Box<dyn Component>> {
+        let idx = self
+            .layers
+            .iter()
+            .position(|layer| layer.name() == Some(id))?;
+        Some(self.layers.remove(idx))
+    }
+
     pub fn handle_event(&mut self, event: &Event, cx: &mut Context) -> bool {
         // If it is a key event, a macro is being recorded, and a macro isn't being replayed,
         // push the key event to the recording.
@@ -162,6 +175,10 @@ pub fn handle_event(&mut self, event: &Event, cx: &mut Context) -> bool {
                     consumed = true;
                     break;
                 }
+                // Swallow the event, but don't trigger a re-render
+                EventResult::ConsumedWithoutRerender => {
+                    break;
+                }
                 EventResult::Ignored(Some(callback)) => {
                     callbacks.push(callback);
                 }
@@ -178,7 +195,9 @@ pub fn handle_event(&mut self, event: &Event, cx: &mut Context) -> bool {
 
     pub fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
         for layer in &mut self.layers {
-            layer.render(area, surface, cx);
+            if layer.should_update() {
+                layer.render(area, surface, cx)
+            };
         }
     }
 
diff --git a/helix-term/src/events.rs b/helix-term/src/events.rs
index b0a422989..fc5a113c3 100644
--- a/helix-term/src/events.rs
+++ b/helix-term/src/events.rs
@@ -1,8 +1,8 @@
 use helix_event::{events, register_event};
 use helix_view::document::Mode;
 use helix_view::events::{
-    ConfigDidChange, DiagnosticsDidChange, DocumentDidChange, DocumentDidClose, DocumentDidOpen,
-    DocumentFocusLost, LanguageServerExited, LanguageServerInitialized, SelectionDidChange,
+    ConfigDidChange, DiagnosticsDidChange, DocumentDidChange, DocumentDidClose, DocumentDidOpen, DocumentFocusLost,
+    DocumentSaved, LanguageServerExited, LanguageServerInitialized, SelectionDidChange,
 };
 
 use crate::commands;
@@ -22,6 +22,7 @@ pub fn register() {
     register_event::<DocumentDidChange>();
     register_event::<DocumentDidClose>();
     register_event::<DocumentFocusLost>();
+    register_event::<DocumentSaved>();
     register_event::<SelectionDidChange>();
     register_event::<DiagnosticsDidChange>();
     register_event::<LanguageServerInitialized>();
diff --git a/helix-term/src/job.rs b/helix-term/src/job.rs
index 72ed892dd..2b9da4c29 100644
--- a/helix-term/src/job.rs
+++ b/helix-term/src/job.rs
@@ -5,13 +5,19 @@
 
 use crate::compositor::Compositor;
 
+use futures_util::future::LocalBoxFuture;
 use futures_util::future::{BoxFuture, Future, FutureExt};
 use futures_util::stream::{FuturesUnordered, StreamExt};
 use tokio::sync::mpsc::{channel, Receiver, Sender};
 
+pub type EditorCompositorJobsCallback =
+    Box<dyn FnOnce(&mut Editor, &mut Compositor, &mut Jobs) + Send>;
 pub type EditorCompositorCallback = Box<dyn FnOnce(&mut Editor, &mut Compositor) + Send>;
 pub type EditorCallback = Box<dyn FnOnce(&mut Editor) + Send>;
 
+pub type ThreadLocalEditorCompositorCallback =
+    Box<dyn FnOnce(&mut Editor, &mut Compositor, &mut Jobs)>;
+
 runtime_local! {
     static JOB_QUEUE: OnceCell<Sender<Callback>> = OnceCell::new();
 }
@@ -32,7 +38,15 @@ pub fn dispatch_blocking(job: impl FnOnce(&mut Editor, &mut Compositor) + Send +
     send_blocking(jobs, Callback::EditorCompositor(Box::new(job)))
 }
 
+pub fn dispatch_blocking_jobs(
+    job: impl FnOnce(&mut Editor, &mut Compositor, &mut Jobs) + Send + 'static,
+) {
+    let jobs = JOB_QUEUE.wait();
+    send_blocking(jobs, Callback::EditorCompositorJobs(Box::new(job)))
+}
+
 pub enum Callback {
+    EditorCompositorJobs(EditorCompositorJobsCallback),
     EditorCompositor(EditorCompositorCallback),
     Editor(EditorCallback),
 }
@@ -45,9 +59,13 @@ pub struct Job {
     pub wait: bool,
 }
 
+pub type ThreadLocalJob =
+    LocalBoxFuture<'static, anyhow::Result<Option<ThreadLocalEditorCompositorCallback>>>;
+
 pub struct Jobs {
-    /// jobs that need to complete before we exit.
+    /// jobs the ones that need to complete before we exit.
     pub wait_futures: FuturesUnordered<JobFuture>,
+    pub local_futures: FuturesUnordered<ThreadLocalJob>,
     pub callbacks: Receiver<Callback>,
     pub status_messages: Receiver<StatusMessage>,
 }
@@ -83,6 +101,7 @@ pub fn new() -> Self {
         let status_messages = helix_event::status::setup();
         Self {
             wait_futures: FuturesUnordered::new(),
+            local_futures: FuturesUnordered::new(),
             callbacks: rx,
             status_messages,
         }
@@ -99,8 +118,18 @@ pub fn callback<F: Future<Output = anyhow::Result<Callback>> + Send + 'static>(
         self.add(Job::with_callback(f));
     }
 
+    pub fn local_callback<
+        F: Future<Output = anyhow::Result<ThreadLocalEditorCompositorCallback>> + 'static,
+    >(
+        &mut self,
+        f: F,
+    ) {
+        self.local_futures
+            .push(f.map(|r| r.map(Some)).boxed_local());
+    }
+
     pub fn handle_callback(
-        &self,
+        &mut self,
         editor: &mut Editor,
         compositor: &mut Compositor,
         call: anyhow::Result<Option<Callback>>,
@@ -108,6 +137,7 @@ pub fn handle_callback(
         match call {
             Ok(None) => {}
             Ok(Some(call)) => match call {
+                Callback::EditorCompositorJobs(call) => call(editor, compositor, self),
                 Callback::EditorCompositor(call) => call(editor, compositor),
                 Callback::Editor(call) => call(editor),
             },
@@ -117,6 +147,21 @@ pub fn handle_callback(
         }
     }
 
+    pub fn handle_local_callback(
+        &mut self,
+        editor: &mut Editor,
+        compositor: &mut Compositor,
+        call: anyhow::Result<Option<ThreadLocalEditorCompositorCallback>>,
+    ) {
+        match call {
+            Ok(None) => {}
+            Ok(Some(call)) => call(editor, compositor, self),
+            Err(e) => {
+                editor.set_error(format!("Sync job failed: {}", e));
+            }
+        }
+    }
+
     pub fn add(&self, j: Job) {
         if j.wait {
             self.wait_futures.push(j.future);
diff --git a/helix-term/src/keymap.rs b/helix-term/src/keymap.rs
index d8227b500..d881421a7 100644
--- a/helix-term/src/keymap.rs
+++ b/helix-term/src/keymap.rs
@@ -235,6 +235,23 @@ fn map_node(cmd_map: &mut ReverseKeymap, node: &KeyTrie, keys: &mut Vec<KeyEvent
         res
     }
 
+    pub fn apply(&mut self, func: &mut dyn FnMut(&mut MappableCommand)) {
+        match self {
+            KeyTrie::MappableCommand(MappableCommand::Macro { .. }) => {}
+            KeyTrie::MappableCommand(cmd) => (func)(cmd),
+            KeyTrie::Node(next) => {
+                for (_, trie) in &mut next.map {
+                    trie.apply(func);
+                }
+            }
+            KeyTrie::Sequence(seq) => {
+                for s in seq {
+                    (func)(s)
+                }
+            }
+        };
+    }
+
     pub fn node(&self) -> Option<&KeyTrieNode> {
         match *self {
             KeyTrie::Node(ref node) => Some(node),
@@ -326,12 +343,14 @@ pub fn contains_key(&self, mode: Mode, key: KeyEvent) -> bool {
             .is_some_and(|node| node.contains_key(&key))
     }
 
-    /// Lookup `key` in the keymap to try and find a command to execute. Escape
-    /// key cancels pending keystrokes. If there are no pending keystrokes but a
-    /// sticky node is in use, it will be cleared.
-    pub fn get(&mut self, mode: Mode, key: KeyEvent) -> KeymapResult {
+    pub(crate) fn get_with_map(
+        &mut self,
+        keymaps: &HashMap<Mode, KeyTrie>,
+        mode: Mode,
+        key: KeyEvent,
+    ) -> KeymapResult {
         // TODO: remove the sticky part and look up manually
-        let keymaps = &*self.map();
+        // let keymaps = &*self.map();
         let keymap = &keymaps[&mode];
 
         if key!(Esc) == key {
@@ -379,6 +398,13 @@ pub fn get(&mut self, mode: Mode, key: KeyEvent) -> KeymapResult {
             None => KeymapResult::Cancelled(self.state.drain(..).collect()),
         }
     }
+
+    /// Lookup `key` in the keymap to try and find a command to execute. Escape
+    /// key cancels pending keystrokes. If there are no pending keystrokes but a
+    /// sticky node is in use, it will be cleared.
+    pub fn get(&mut self, mode: Mode, key: KeyEvent) -> KeymapResult {
+        self.get_with_map(&*self.map(), mode, key)
+    }
 }
 
 impl Default for Keymaps {
diff --git a/helix-term/src/main.rs b/helix-term/src/main.rs
index 31ab85cff..6715f56c2 100644
--- a/helix-term/src/main.rs
+++ b/helix-term/src/main.rs
@@ -4,6 +4,7 @@
 use helix_term::application::Application;
 use helix_term::args::Args;
 use helix_term::config::{Config, ConfigLoadError};
+use indexmap::map::MutableKeys;
 
 fn setup_logging(verbosity: u64) -> Result<()> {
     let mut base_config = fern::Dispatch::new();
@@ -40,7 +41,7 @@ fn main() -> Result<()> {
 
 #[tokio::main]
 async fn main_impl() -> Result<i32> {
-    let args = Args::parse_args().context("could not parse arguments")?;
+    let mut args = Args::parse_args().context("could not parse arguments")?;
 
     helix_loader::initialize_config_file(args.config_file.clone());
     helix_loader::initialize_log_file(args.log_file.clone());
@@ -114,6 +115,14 @@ async fn main_impl() -> Result<i32> {
 
     setup_logging(args.verbosity).context("failed to initialize logging")?;
 
+    // Initialize the engine before we boot up!
+    helix_term::commands::ScriptingEngine::initialize();
+
+    // Before setting the working directory, resolve all the paths in args.files
+    for (path, _) in args.files.iter_mut2() {
+        *path = helix_stdx::path::canonicalize(&*path);
+    }
+
     // NOTE: Set the working directory early so the correct configuration is loaded. Be aware that
     // Application::new() depends on this logic so it must be updated if this changes.
     if let Some(path) = &args.working_directory {
diff --git a/helix-term/src/ui/document.rs b/helix-term/src/ui/document.rs
index 524d829c4..964a0a08b 100644
--- a/helix-term/src/ui/document.rs
+++ b/helix-term/src/ui/document.rs
@@ -46,6 +46,7 @@ pub fn render_document(
         Position::new(offset.vertical_offset, offset.horizontal_offset),
         viewport,
     );
+
     render_text(
         &mut renderer,
         doc.text().slice(..),
diff --git a/helix-term/src/ui/editor.rs b/helix-term/src/ui/editor.rs
index 1521ca7ea..59048858d 100644
--- a/helix-term/src/ui/editor.rs
+++ b/helix-term/src/ui/editor.rs
@@ -1,5 +1,5 @@
 use crate::{
-    commands::{self, OnKeyCallback, OnKeyCallbackKind},
+    commands::{self, engine::ScriptingEngine, OnKeyCallback, OnKeyCallbackKind},
     compositor::{Component, Context, Event, EventResult},
     events::{OnModeSwitch, PostCommand},
     handlers::completion::CompletionItem,
@@ -1118,7 +1118,11 @@ fn handle_keymap_event(
     ) -> Option<KeymapResult> {
         let mut last_mode = mode;
         self.pseudo_pending.extend(self.keymaps.pending());
-        let key_result = self.keymaps.get(mode, event);
+
+        // Check the engine for any buffer specific keybindings first
+        let key_result = ScriptingEngine::handle_keymap_event(self, mode, cxt, event)
+            .unwrap_or_else(|| self.keymaps.get(mode, event));
+
         cxt.editor.autoinfo = self.keymaps.sticky().map(|node| node.infobox());
 
         let mut execute_command = |command: &commands::MappableCommand| {
@@ -1782,6 +1786,22 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
             _ => false,
         };
 
+        let mut area = area;
+
+        // TODO: This may need to get looked at!
+        if let Some(top) = cx.editor.editor_clipping.top {
+            area = area.clip_top(top);
+        }
+        if let Some(bottom) = cx.editor.editor_clipping.bottom {
+            area = area.clip_bottom(bottom);
+        }
+        if let Some(left) = cx.editor.editor_clipping.left {
+            area = area.clip_left(left);
+        }
+        if let Some(right) = cx.editor.editor_clipping.right {
+            area = area.clip_right(right);
+        }
+
         // -1 for commandline and -1 for bufferline
         let mut editor_area = area.clip_bottom(1);
         if use_bufferline {
diff --git a/helix-term/src/ui/extension.rs b/helix-term/src/ui/extension.rs
new file mode 100644
index 000000000..71552c433
--- /dev/null
+++ b/helix-term/src/ui/extension.rs
@@ -0,0 +1,11 @@
+#[cfg(feature = "steel")]
+mod steel_implementations {
+
+    use crate::{
+        compositor::Component,
+        ui::{Popup, Text},
+    };
+
+    impl steel::rvals::Custom for Text {}
+    impl<T: steel::rvals::IntoSteelVal + Component> steel::rvals::Custom for Popup<T> {}
+}
diff --git a/helix-term/src/ui/mod.rs b/helix-term/src/ui/mod.rs
index 147280cf4..099432683 100644
--- a/helix-term/src/ui/mod.rs
+++ b/helix-term/src/ui/mod.rs
@@ -1,6 +1,7 @@
 mod completion;
 mod document;
 pub(crate) mod editor;
+mod extension;
 mod info;
 pub mod lsp;
 mod markdown;
@@ -455,13 +456,18 @@ pub fn buffer(editor: &Editor, input: &str) -> Vec<Completion> {
             .collect()
     }
 
-    pub fn theme(_editor: &Editor, input: &str) -> Vec<Completion> {
+    pub fn theme(editor: &Editor, input: &str) -> Vec<Completion> {
         let mut names = theme::Loader::read_names(&helix_loader::config_dir().join("themes"));
         for rt_dir in helix_loader::runtime_dirs() {
             names.extend(theme::Loader::read_names(&rt_dir.join("themes")));
         }
+
         names.push("default".into());
         names.push("base16_default".into());
+
+        // Include any user defined themes as well
+        names.extend(editor.user_defined_themes.keys().map(|x| x.into()));
+
         names.sort();
         names.dedup();
 
diff --git a/helix-term/src/ui/overlay.rs b/helix-term/src/ui/overlay.rs
index ff184d407..2dcbcdc92 100644
--- a/helix-term/src/ui/overlay.rs
+++ b/helix-term/src/ui/overlay.rs
@@ -15,6 +15,12 @@ pub struct Overlay<T> {
     pub calc_child_size: Box<dyn Fn(Rect) -> Rect>,
 }
 
+// TODO: For this to be sound, all of the various functions
+// have to now be marked as send + sync + 'static. Annoying,
+// and something I'll look into with steel.
+unsafe impl<T> Send for Overlay<T> {}
+unsafe impl<T> Sync for Overlay<T> {}
+
 /// Surrounds the component with a margin of 5% on each side, and an additional 2 rows at the bottom
 pub fn overlaid<T>(content: T) -> Overlay<T> {
     Overlay {
diff --git a/helix-term/src/ui/prompt.rs b/helix-term/src/ui/prompt.rs
index 20b390c0a..f20e13fde 100644
--- a/helix-term/src/ui/prompt.rs
+++ b/helix-term/src/ui/prompt.rs
@@ -49,6 +49,12 @@ pub struct Prompt {
     language: Option<(&'static str, Arc<ArcSwap<syntax::Loader>>)>,
 }
 
+// TODO: For this to be sound, all of the various functions
+// have to now be marked as send + sync + 'static. Annoying,
+// and something I'll look into with steel.
+unsafe impl Send for Prompt {}
+unsafe impl Sync for Prompt {}
+
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum PromptEvent {
     /// The prompt input has been updated.
diff --git a/helix-term/src/ui/statusline.rs b/helix-term/src/ui/statusline.rs
index 376e8560c..0d0ed29c5 100644
--- a/helix-term/src/ui/statusline.rs
+++ b/helix-term/src/ui/statusline.rs
@@ -538,6 +538,7 @@ fn render_file_name<'a, F>(context: &mut RenderContext<'a>, write: F)
         let path = rel_path
             .as_ref()
             .map(|p| p.to_string_lossy())
+            .or_else(|| context.doc.name.as_ref().map(|x| x.into()))
             .unwrap_or_else(|| SCRATCH_BUFFER_NAME.into());
         format!(" {} ", path)
     };
@@ -591,6 +592,7 @@ fn render_file_base_name<'a, F>(context: &mut RenderContext<'a>, write: F)
         let path = rel_path
             .as_ref()
             .and_then(|p| p.file_name().map(|s| s.to_string_lossy()))
+            .or_else(|| context.doc.name.as_ref().map(|x| x.into()))
             .unwrap_or_else(|| SCRATCH_BUFFER_NAME.into());
         format!(" {} ", path)
     };
diff --git a/helix-tui/Cargo.toml b/helix-tui/Cargo.toml
index 2b5767a58..d4db46ca5 100644
--- a/helix-tui/Cargo.toml
+++ b/helix-tui/Cargo.toml
@@ -13,6 +13,7 @@ homepage.workspace = true
 
 [features]
 default = ["crossterm"]
+steel = ["dep:steel-core", "helix-view/steel", "helix-core/steel"]
 
 [dependencies]
 helix-view = { path = "../helix-view", features = ["term"] }
@@ -25,3 +26,5 @@ crossterm = { version = "0.28", optional = true }
 termini = "1.0"
 once_cell = "1.21"
 log = "~0.4"
+
+steel-core = { workspace = true, optional = true }
diff --git a/helix-tui/src/extension.rs b/helix-tui/src/extension.rs
new file mode 100644
index 000000000..c046137ce
--- /dev/null
+++ b/helix-tui/src/extension.rs
@@ -0,0 +1,20 @@
+#[cfg(feature = "steel")]
+mod steel_implementations {
+
+    use crate::{
+        buffer::Buffer,
+        text::Text,
+        widgets::{Block, List, Paragraph, Table},
+    };
+
+    use steel::{gc::unsafe_erased_pointers::CustomReference, rvals::Custom};
+
+    impl CustomReference for Buffer {}
+    impl Custom for Block<'static> {}
+    impl Custom for List<'static> {}
+    impl Custom for Paragraph<'static> {}
+    impl Custom for Table<'static> {}
+    impl Custom for Text<'static> {}
+
+    steel::custom_reference!(Buffer);
+}
diff --git a/helix-tui/src/lib.rs b/helix-tui/src/lib.rs
index 59327d7c3..a4ffc186c 100644
--- a/helix-tui/src/lib.rs
+++ b/helix-tui/src/lib.rs
@@ -130,6 +130,7 @@
 
 pub mod backend;
 pub mod buffer;
+pub mod extension;
 pub mod layout;
 pub mod symbols;
 pub mod terminal;
diff --git a/helix-tui/src/widgets/list.rs b/helix-tui/src/widgets/list.rs
index 4b0fc02f4..5e9add4b4 100644
--- a/helix-tui/src/widgets/list.rs
+++ b/helix-tui/src/widgets/list.rs
@@ -1,12 +1,12 @@
 use crate::{
     buffer::Buffer,
-    layout::{Corner, Rect},
-    style::Style,
+    layout::Corner,
     text::Text,
-    widgets::{Block, StatefulWidget, Widget},
+    widgets::{Block, Widget},
 };
+use helix_core::unicode::width::UnicodeWidthStr;
+use helix_view::graphics::{Rect, Style};
 use std::iter::{self, Iterator};
-use unicode_width::UnicodeWidthStr;
 
 #[derive(Debug, Clone)]
 pub struct ListState {
@@ -131,10 +131,8 @@ pub fn start_corner(mut self, corner: Corner) -> List<'a> {
     }
 }
 
-impl<'a> StatefulWidget for List<'a> {
-    type State = ListState;
-
-    fn render(mut self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {
+impl<'a> List<'a> {
+    fn render_list(mut self, area: Rect, buf: &mut Buffer, state: &mut ListState) {
         buf.set_style(area, self.style);
         let list_area = match self.block.take() {
             Some(b) => {
@@ -244,6 +242,6 @@ fn render(mut self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {
 impl<'a> Widget for List<'a> {
     fn render(self, area: Rect, buf: &mut Buffer) {
         let mut state = ListState::default();
-        StatefulWidget::render(self, area, buf, &mut state);
+        Self::render_list(self, area, buf, &mut state);
     }
 }
diff --git a/helix-tui/src/widgets/mod.rs b/helix-tui/src/widgets/mod.rs
index 3a0dfc5d8..7145ec678 100644
--- a/helix-tui/src/widgets/mod.rs
+++ b/helix-tui/src/widgets/mod.rs
@@ -10,13 +10,13 @@
 //! - [`Paragraph`]
 
 mod block;
-// mod list;
+mod list;
 mod paragraph;
 mod reflow;
 mod table;
 
 pub use self::block::{Block, BorderType};
-// pub use self::list::{List, ListItem, ListState};
+pub use self::list::{List, ListItem, ListState};
 pub use self::paragraph::{Paragraph, Wrap};
 pub use self::table::{Cell, Row, Table, TableState};
 
diff --git a/helix-view/Cargo.toml b/helix-view/Cargo.toml
index 40150513c..c585f80be 100644
--- a/helix-view/Cargo.toml
+++ b/helix-view/Cargo.toml
@@ -11,8 +11,8 @@ repository.workspace = true
 homepage.workspace = true
 
 [features]
-default = []
 term = ["crossterm"]
+steel = ["dep:steel-core", "helix-core/steel"]
 unicode-lines = []
 
 [dependencies]
@@ -49,6 +49,9 @@ serde_json = "1.0"
 toml = "0.8"
 log = "~0.4"
 
+# plugin support
+steel-core = { workspace = true, optional = true }
+
 parking_lot.workspace = true
 thiserror.workspace = true
 
diff --git a/helix-view/src/document.rs b/helix-view/src/document.rs
index 612a2dbb7..90846af33 100644
--- a/helix-view/src/document.rs
+++ b/helix-view/src/document.rs
@@ -202,6 +202,8 @@ pub struct Document {
     // when document was used for most-recent-used buffer picker
     pub focused_at: std::time::Instant,
 
+    // A name separate from the file name
+    pub name: Option<String>,
     pub readonly: bool,
 
     /// Annotations for LSP document color swatches
@@ -209,6 +211,7 @@ pub struct Document {
     // NOTE: ideally this would live on the handler for color swatches. This is blocked on a
     // large refactor that would make `&mut Editor` available on the `DocumentDidChange` event.
     pub color_swatch_controller: TaskController,
+    pub uri: Option<Box<Url>>,
 
     /// Whether to render the welcome screen when opening the document
     pub is_welcome: bool,
@@ -725,11 +728,13 @@ pub fn from(
             config,
             version_control_head: None,
             focused_at: std::time::Instant::now(),
+            name: None,
             readonly: false,
             jump_labels: HashMap::new(),
             color_swatches: None,
             color_swatch_controller: TaskController::new(),
             is_welcome: false,
+            uri: None,
             syn_loader,
         }
     }
@@ -1188,6 +1193,10 @@ pub(crate) fn detect_editor_config(&mut self) {
         }
     }
 
+    pub fn last_saved_time(&self) -> SystemTime {
+        self.last_saved_time
+    }
+
     pub fn pickup_last_saved_time(&mut self) {
         self.last_saved_time = match self.path() {
             Some(path) => match path.metadata() {
@@ -1947,7 +1956,10 @@ pub fn path(&self) -> Option<&PathBuf> {
 
     /// File path as a URL.
     pub fn url(&self) -> Option<Url> {
-        Url::from_file_path(self.path()?).ok()
+        self.uri
+            .as_ref()
+            .map(|x| *x.clone())
+            .or_else(|| Url::from_file_path(self.path()?).ok())
     }
 
     pub fn uri(&self) -> Option<helix_core::Uri> {
@@ -2003,7 +2015,9 @@ pub fn relative_path(&self) -> Option<&Path> {
 
     pub fn display_name(&self) -> Cow<'_, str> {
         self.relative_path()
-            .map_or_else(|| SCRATCH_BUFFER_NAME.into(), |path| path.to_string_lossy())
+            .map(|path| path.to_string_lossy().to_string().into())
+            .or_else(|| self.name.as_ref().map(|x| Cow::Owned(x.clone())))
+            .unwrap_or_else(|| SCRATCH_BUFFER_NAME.into())
     }
 
     // transact(Fn) ?
diff --git a/helix-view/src/editor.rs b/helix-view/src/editor.rs
index 0c2b8e9c1..1b7deb50a 100644
--- a/helix-view/src/editor.rs
+++ b/helix-view/src/editor.rs
@@ -4,7 +4,7 @@
     document::{
         DocumentOpenError, DocumentSavedEventFuture, DocumentSavedEventResult, Mode, SavePoint,
     },
-    events::{DocumentDidClose, DocumentDidOpen, DocumentFocusLost},
+    events::{DocumentDidClose, DocumentDidOpen, DocumentFocusLost, DocumentSaved},
     graphics::{CursorKind, Rect},
     handlers::Handlers,
     info::Info,
@@ -668,6 +668,10 @@ fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 pub struct CursorShapeConfig([CursorKind; 3]);
 
 impl CursorShapeConfig {
+    pub fn update(&mut self, mode: Mode, kind: CursorKind) {
+        self.0[mode as usize] = kind;
+    }
+
     pub fn from_mode(&self, mode: Mode) -> CursorKind {
         self.get(mode as usize).copied().unwrap_or_default()
     }
@@ -1189,6 +1193,17 @@ pub struct Editor {
 
     pub mouse_down_range: Option<Range>,
     pub cursor_cache: CursorCache,
+
+    pub editor_clipping: ClippingConfiguration,
+    pub user_defined_themes: HashMap<String, Theme>,
+}
+
+#[derive(Default)]
+pub struct ClippingConfiguration {
+    pub top: Option<u16>,
+    pub bottom: Option<u16>,
+    pub left: Option<u16>,
+    pub right: Option<u16>,
 }
 
 pub type Motion = Box<dyn Fn(&mut Editor)>;
@@ -1207,6 +1222,7 @@ pub enum EditorEvent {
 pub enum ConfigEvent {
     Refresh,
     Update(Box<Config>),
+    Change,
 }
 
 enum ThemeAction {
@@ -1310,6 +1326,8 @@ pub fn new(
             handlers,
             mouse_down_range: None,
             cursor_cache: CursorCache::default(),
+            editor_clipping: ClippingConfiguration::default(),
+            user_defined_themes: Default::default(),
         }
     }
 
@@ -1680,6 +1698,8 @@ fn replace_document_in_view(&mut self, current_view: ViewId, doc_id: DocumentId)
     pub fn switch(&mut self, id: DocumentId, action: Action) {
         use crate::tree::Layout;
 
+        log::info!("Switching view: {:?}", id);
+
         if !self.documents.contains_key(&id) {
             log::error!("cannot switch to document that does not exist (anymore)");
             return;
@@ -2012,6 +2032,11 @@ pub fn save<P: Into<PathBuf>>(
 
         self.write_count += 1;
 
+        dispatch(DocumentSaved {
+            editor: self,
+            doc: doc_id,
+        });
+
         Ok(())
     }
 
@@ -2027,6 +2052,8 @@ pub fn focus(&mut self, view_id: ViewId) {
         // if leaving the view: mode should reset and the cursor should be
         // within view
         if prev_id != view_id {
+            // TODO: Consult map for modes to change given file type?
+
             self.enter_normal_mode();
             self.ensure_cursor_in_view(view_id);
 
diff --git a/helix-view/src/events.rs b/helix-view/src/events.rs
index 0435e6a47..e85a84b07 100644
--- a/helix-view/src/events.rs
+++ b/helix-view/src/events.rs
@@ -24,6 +24,7 @@
     DiagnosticsDidChange<'a> { editor: &'a mut Editor, doc: DocumentId }
     // called **after** a document loses focus (but not when its closed)
     DocumentFocusLost<'a> { editor: &'a mut Editor, doc: DocumentId }
+    DocumentSaved<'a> { editor: &'a mut Editor, doc: DocumentId }
 
     LanguageServerInitialized<'a> {
         editor: &'a mut Editor,
diff --git a/helix-view/src/extension.rs b/helix-view/src/extension.rs
new file mode 100644
index 000000000..0c9855cc9
--- /dev/null
+++ b/helix-view/src/extension.rs
@@ -0,0 +1,107 @@
+use crate::DocumentId;
+
+pub fn document_id_to_usize(doc_id: &DocumentId) -> usize {
+    doc_id.0.into()
+}
+
+#[cfg(feature = "steel")]
+mod steel_implementations {
+
+    use steel::{
+        gc::unsafe_erased_pointers::CustomReference,
+        rvals::{as_underlying_type, Custom},
+    };
+
+    use crate::{
+        document::Mode,
+        editor::{
+            Action, AutoSave, BufferLine, CursorShapeConfig, FilePickerConfig, GutterConfig,
+            IndentGuidesConfig, LineEndingConfig, LineNumber, LspConfig, SearchConfig,
+            SmartTabConfig, StatusLineConfig, TerminalConfig, WhitespaceConfig,
+        },
+        graphics::{Color, Rect, Style, UnderlineStyle},
+        input::Event,
+        Document, DocumentId, Editor, ViewId,
+    };
+
+    impl steel::gc::unsafe_erased_pointers::CustomReference for Editor {}
+    steel::custom_reference!(Editor);
+
+    impl steel::rvals::Custom for Mode {
+        fn equality_hint(&self, other: &dyn steel::rvals::CustomType) -> bool {
+            if let Some(other) = as_underlying_type::<Self>(other) {
+                self == other
+            } else {
+                false
+            }
+        }
+    }
+    impl steel::rvals::Custom for Event {}
+    impl Custom for Style {
+        fn fmt(&self) -> Option<std::result::Result<String, std::fmt::Error>> {
+            Some(Ok(format!("{:?}", self)))
+        }
+    }
+    impl Custom for Color {
+        fn fmt(&self) -> Option<std::result::Result<String, std::fmt::Error>> {
+            Some(Ok(format!("{:?}", self)))
+        }
+    }
+    impl Custom for UnderlineStyle {}
+
+    impl CustomReference for Event {}
+    impl Custom for Rect {
+        fn equality_hint(&self, other: &dyn steel::rvals::CustomType) -> bool {
+            if let Some(other) = as_underlying_type::<Rect>(other) {
+                self == other
+            } else {
+                false
+            }
+        }
+    }
+    impl Custom for crate::graphics::CursorKind {
+        fn equality_hint(&self, other: &dyn steel::rvals::CustomType) -> bool {
+            if let Some(other) = as_underlying_type::<Self>(other) {
+                self == other
+            } else {
+                false
+            }
+        }
+    }
+    impl Custom for DocumentId {
+        fn equality_hint(&self, other: &dyn steel::rvals::CustomType) -> bool {
+            if let Some(other) = as_underlying_type::<DocumentId>(other) {
+                self == other
+            } else {
+                false
+            }
+        }
+    }
+    impl Custom for ViewId {
+        fn equality_hint(&self, other: &dyn steel::rvals::CustomType) -> bool {
+            if let Some(other) = as_underlying_type::<ViewId>(other) {
+                self == other
+            } else {
+                false
+            }
+        }
+    }
+    impl CustomReference for Document {}
+
+    impl Custom for Action {}
+
+    impl Custom for FilePickerConfig {}
+    impl Custom for StatusLineConfig {}
+    impl Custom for SearchConfig {}
+    impl Custom for TerminalConfig {}
+    impl Custom for WhitespaceConfig {}
+    impl Custom for CursorShapeConfig {}
+    impl Custom for BufferLine {}
+    impl Custom for LineNumber {}
+    impl Custom for GutterConfig {}
+    impl Custom for LspConfig {}
+    impl Custom for IndentGuidesConfig {}
+    impl Custom for LineEndingConfig {}
+    impl Custom for SmartTabConfig {}
+    impl Custom for AutoSave {}
+}
diff --git a/helix-view/src/graphics.rs b/helix-view/src/graphics.rs
index 3cd3c8626..c22d873f3 100644
--- a/helix-view/src/graphics.rs
+++ b/helix-view/src/graphics.rs
@@ -317,6 +317,32 @@ fn from(color: Color) -> Self {
     }
 }
 
+impl Color {
+    pub fn red(&self) -> Option<u8> {
+        if let Self::Rgb(r, _, _) = self {
+            Some(*r)
+        } else {
+            None
+        }
+    }
+
+    pub fn green(&self) -> Option<u8> {
+        if let Self::Rgb(_, g, _) = self {
+            Some(*g)
+        } else {
+            None
+        }
+    }
+
+    pub fn blue(&self) -> Option<u8> {
+        if let Self::Rgb(_, _, b) = self {
+            Some(*b)
+        } else {
+            None
+        }
+    }
+}
+
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 pub enum UnderlineStyle {
     Reset,
diff --git a/helix-view/src/info.rs b/helix-view/src/info.rs
index d1e90b5a0..fa5c4d450 100644
--- a/helix-view/src/info.rs
+++ b/helix-view/src/info.rs
@@ -40,18 +40,26 @@ pub fn new<T, K, V>(title: T, body: &[(K, V)]) -> Self
         let mut text = String::new();
 
         for (item, desc) in body {
-            let _ = writeln!(
-                text,
-                "{:width$}  {}",
-                item.as_ref(),
-                desc.as_ref(),
-                width = item_width
-            );
+            let mut line_iter = desc.as_ref().lines();
+
+            if let Some(first_line) = line_iter.next() {
+                let _ = writeln!(
+                    text,
+                    "{:width$}  {}",
+                    item.as_ref(),
+                    first_line,
+                    width = item_width
+                );
+            }
+
+            for line in line_iter {
+                let _ = writeln!(text, "{:width$}  {}", "", line, width = item_width);
+            }
         }
 
         Self {
             title,
-            width: text.lines().map(|l| l.width()).max().unwrap() as u16,
+            width: text.lines().map(|l| l.width()).max().unwrap_or(body.len()) as u16,
             height: body.len() as u16,
             text,
         }
diff --git a/helix-view/src/lib.rs b/helix-view/src/lib.rs
index 89a58839c..cb18593e9 100644
--- a/helix-view/src/lib.rs
+++ b/helix-view/src/lib.rs
@@ -20,6 +20,8 @@
 pub mod tree;
 pub mod view;
 
+pub mod extension;
+
 use std::num::NonZeroUsize;
 
 // uses NonZeroUsize so Option<DocumentId> use a byte rather than two
diff --git a/helix-view/src/theme.rs b/helix-view/src/theme.rs
index 61d490ff3..06c5bc3a8 100644
--- a/helix-view/src/theme.rs
+++ b/helix-view/src/theme.rs
@@ -330,10 +330,27 @@ pub fn name(&self) -> &str {
         &self.name
     }
 
+    pub fn set_name(&mut self, name: String) {
+        self.name = name;
+    }
+
     pub fn get(&self, scope: &str) -> Style {
         self.try_get(scope).unwrap_or_default()
     }
 
+    pub fn set(&mut self, scope: String, style: Style) {
+        if self.styles.insert(scope.to_string(), style).is_some() {
+            for (name, highlights) in self.scopes.iter().zip(self.highlights.iter_mut()) {
+                if *name == scope {
+                    *highlights = style;
+                }
+            }
+        } else {
+            self.scopes.push(scope);
+            self.highlights.push(style);
+        }
+    }
+
     /// Get the style of a scope, falling back to dot separated broader
     /// scopes. For example if `ui.text.focus` is not defined in the theme,
     /// `ui.text` is tried and then `ui` is tried.
@@ -382,7 +399,7 @@ pub fn is_16_color(&self) -> bool {
         })
     }
 
-    fn from_toml(value: Value) -> (Self, Vec<String>) {
+    pub fn from_toml(value: Value) -> (Self, Vec<String>) {
         if let Value::Table(table) = value {
             Theme::from_keys(table)
         } else {
@@ -404,7 +421,7 @@ fn from_keys(toml_keys: Map<String, Value>) -> (Self, Vec<String>) {
     }
 }
 
-struct ThemePalette {
+pub struct ThemePalette {
     palette: HashMap<String, Color>,
 }
 
diff --git a/helix-view/src/tree.rs b/helix-view/src/tree.rs
index aba947a21..56a6c2dd5 100644
--- a/helix-view/src/tree.rs
+++ b/helix-view/src/tree.rs
@@ -669,6 +669,13 @@ pub fn swap_split_in_direction(&mut self, direction: Direction) -> Option<()> {
     pub fn area(&self) -> Rect {
         self.area
     }
+
+    pub fn view_id_area(&self, id: ViewId) -> Option<Rect> {
+        self.nodes.get(id).map(|node| match &node.content {
+            Content::View(v) => v.area,
+            Content::Container(c) => c.area,
+        })
+    }
 }
 
 #[derive(Debug)]
diff --git a/rust-toolchain.toml b/rust-toolchain.toml
index 74c6fc7a2..f0c6c4d3c 100644
--- a/rust-toolchain.toml
+++ b/rust-toolchain.toml
@@ -1,3 +1,3 @@
 [toolchain]
-channel = "1.82.0"
+channel = "1.84.0"
 components = ["rustfmt", "rust-src", "clippy"]
diff --git a/steel-docs.md b/steel-docs.md
new file mode 100644
index 000000000..76ccf2fc3
--- /dev/null
+++ b/steel-docs.md
@@ -0,0 +1,2841 @@
+# /home/matt/.steel/cogs/helix/configuration.scm
+### **register-lsp-notification-handler**
+Register a callback to be called on LSP notifications sent from the server -> client
+that aren't currently handled by Helix as a built in.
+
+```scheme
+(register-lsp-notification-handler lsp-name event-name handler)
+```
+
+* lsp-name : string?
+* event-name : string?
+* function : (-> hash? any?) ;; Function where the first argument is the parameters
+
+# Examples
+```
+(register-lsp-notification-handler "dart"
+                                   "dart/textDocument/publishClosingLabels"
+                                   (lambda (args) (displayln args)))
+```
+### **cursor-shape**
+Shape for cursor in each mode
+
+(cursor-shape #:normal (normal 'block)
+              #:select (select 'block)
+              #:insert (insert 'block))
+
+# Examples
+
+```scheme
+(cursor-shape #:normal 'block #:select 'underline #:insert 'bar)
+```
+### **set-lsp-config!**
+Sets the language server config for a specific language server.
+
+```scheme
+(set-lsp-config! lsp config)
+```
+* lsp : string?
+* config: hash?
+
+This will overlay the existing configuration, much like the existing
+toml definition does.
+
+Available options for the config hash are:
+```scheme
+(hash "command" "<command>"
+      "args" (list "args" ...)
+      "environment" (hash "ENV" "VAR" ...)
+      "config" (hash ...)
+      "timeout" 100 ;; number
+      "required-root-patterns" (listof "pattern" ...))
+
+```
+
+# Examples
+```
+(set-lsp-config! "jdtls"
+   (hash "args" (list "-data" "/home/matt/code/java-scratch/workspace")))
+```
+### **file-picker-kw**
+Sets the configuration for the file picker using keywords.
+
+```scheme
+(file-picker-kw #:hidden #t
+                #:follow-symlinks #t
+                #:deduplicate-links #t
+                #:parents #t
+                #:ignore #t
+                #:git-ignore #t
+                #:git-exclude #t
+                #:git-global #t
+                #:max-depth #f) ;; Expects either #f or an int?
+```
+By default, max depth is `#f` while everything else is an int?
+
+To use this, call this in your `init.scm` or `helix.scm`:
+
+# Examples
+```scheme
+(file-picker-kw #:hidden #f)
+```
+### **file-picker**
+Sets the configuration for the file picker using var args.
+
+```scheme
+(file-picker . args)
+```
+
+The args are expected to be something of the value:
+```scheme
+(-> FilePickerConfiguration? bool?)    
+```
+
+These other functions in this module which follow this behavior are all
+prefixed `fp-`, and include:
+
+* fp-hidden
+* fp-follow-symlinks
+* fp-deduplicate-links
+* fp-parents
+* fp-ignore
+* fp-git-ignore
+* fp-git-global
+* fp-git-exclude
+* fp-max-depth
+
+By default, max depth is `#f` while everything else is an int?
+
+To use this, call this in your `init.scm` or `helix.scm`:
+
+# Examples
+```scheme
+(file-picker (fp-hidden #f) (fp-parents #f))
+```
+### **soft-wrap-kw**
+Sets the configuration for soft wrap using keyword args.
+
+```scheme
+(soft-wrap-kw #:enable #f
+              #:max-wrap 20
+              #:max-indent-retain 40
+              #:wrap-indicator "↪"
+              #:wrap-at-text-width #f)
+```
+
+The options are as follows:
+
+* #:enable:
+  Soft wrap lines that exceed viewport width. Default to off
+* #:max-wrap:
+  Maximum space left free at the end of the line.
+  This space is used to wrap text at word boundaries. If that is not possible within this limit
+  the word is simply split at the end of the line.
+
+  This is automatically hard-limited to a quarter of the viewport to ensure correct display on small views.
+
+  Default to 20
+* #:max-indent-retain
+  Maximum number of indentation that can be carried over from the previous line when softwrapping.
+  If a line is indented further then this limit it is rendered at the start of the viewport instead.
+
+  This is automatically hard-limited to a quarter of the viewport to ensure correct display on small views.
+
+  Default to 40
+* #:wrap-indicator
+  Indicator placed at the beginning of softwrapped lines
+
+  Defaults to ↪
+* #:wrap-at-text-width
+  Softwrap at `text_width` instead of viewport width if it is shorter
+
+# Examples
+```scheme
+(soft-wrap-kw #:sw-enable #t)
+```
+### **soft-wrap**
+Sets the configuration for soft wrap using var args.
+
+```scheme
+(soft-wrap . args)
+```
+
+The args are expected to be something of the value:
+```scheme
+(-> SoftWrapConfiguration? bool?)    
+```
+The options are as follows:
+
+* sw-enable:
+  Soft wrap lines that exceed viewport width. Default to off
+* sw-max-wrap:
+  Maximum space left free at the end of the line.
+  This space is used to wrap text at word boundaries. If that is not possible within this limit
+  the word is simply split at the end of the line.
+
+  This is automatically hard-limited to a quarter of the viewport to ensure correct display on small views.
+
+  Default to 20
+* sw-max-indent-retain
+  Maximum number of indentation that can be carried over from the previous line when softwrapping.
+  If a line is indented further then this limit it is rendered at the start of the viewport instead.
+
+  This is automatically hard-limited to a quarter of the viewport to ensure correct display on small views.
+
+  Default to 40
+* sw-wrap-indicator
+  Indicator placed at the beginning of softwrapped lines
+
+  Defaults to ↪
+* sw-wrap-at-text-width
+  Softwrap at `text_width` instead of viewport width if it is shorter
+
+# Examples
+```scheme
+(soft-wrap (sw-enable #t))
+```
+### **scrolloff**
+Padding to keep between the edge of the screen and the cursor when scrolling. Defaults to 5.
+### **scroll_lines**
+Number of lines to scroll at once. Defaults to 3
+### **mouse**
+Mouse support. Defaults to true.
+### **shell**
+Shell to use for shell commands. Defaults to ["cmd", "/C"] on Windows and ["sh", "-c"] otherwise.
+### **line-number**
+Line number mode.
+### **cursorline**
+Highlight the lines cursors are currently on. Defaults to false
+### **cursorcolumn**
+Highlight the columns cursors are currently on. Defaults to false
+### **middle-click-paste**
+Middle click paste support. Defaults to true
+### **auto-pairs**
+
+Automatic insertion of pairs to parentheses, brackets,
+etc. Optionally, this can be a list of 2-tuples to specify a
+global list of characters to pair. Defaults to true.
+### **auto-completion**
+Automatic auto-completion, automatically pop up without user trigger. Defaults to true.
+### **auto-format**
+Automatic formatting on save. Defaults to true.
+### **auto-save**
+Automatic save on focus lost and/or after delay.
+Time delay in milliseconds since last edit after which auto save timer triggers.
+Time delay defaults to false with 3000ms delay. Focus lost defaults to false.
+               
+### **text-width**
+Set a global text_width
+### **idle-timeout**
+Time in milliseconds since last keypress before idle timers trigger.
+Used for various UI timeouts. Defaults to 250ms.
+### **completion-timeout**
+
+Time in milliseconds after typing a word character before auto completions
+are shown, set to 5 for instant. Defaults to 250ms.
+               
+### **preview-completion-insert**
+Whether to insert the completion suggestion on hover. Defaults to true.
+### **completion-trigger-len**
+Length to trigger completions
+### **completion-replace**
+Whether to instruct the LSP to replace the entire word when applying a completion
+or to only insert new text
+### **auto-info**
+Whether to display infoboxes. Defaults to true.
+### **true-color**
+Set to `true` to override automatic detection of terminal truecolor support in the event of a false negative. Defaults to `false`.
+### **insert-final-newline**
+Whether to automatically insert a trailing line-ending on write if missing. Defaults to `true`
+### **color-modes**
+Whether to color modes with different colors. Defaults to `false`.
+### **gutters**
+Gutter configuration
+### **statusline**
+Configuration of the statusline elements
+### **undercurl**
+Set to `true` to override automatic detection of terminal undercurl support in the event of a false negative. Defaults to `false`.
+### **search**
+Search configuration
+### **lsp**
+Lsp config
+### **terminal**
+Terminal config
+### **rulers**
+Column numbers at which to draw the rulers. Defaults to `[]`, meaning no rulers
+### **whitespace**
+Whitespace config
+### **bufferline**
+Persistently display open buffers along the top
+### **indent-guides**
+Vertical indent width guides
+### **workspace-lsp-roots**
+Workspace specific lsp ceiling dirs
+### **default-line-ending**
+Which line ending to choose for new documents. Defaults to `native`. i.e. `crlf` on Windows, otherwise `lf`.
+### **smart-tab**
+Enables smart tab
+### **keybindings**
+Keybindings config
+### **inline-diagnostics-cursor-line-enable**
+Inline diagnostics cursor line
+### **inline-diagnostics-end-of-line-enable**
+Inline diagnostics end of line
+### **get-language-config**
+Get the configuration for a specific language
+### **set-language-config!**
+Set the language configuration
+# /home/matt/.steel/cogs/helix/commands.scm
+### **quit**
+Close the current view.
+### **quit!**
+Force close the current view, ignoring unsaved changes.
+### **open**
+Open a file from disk into the current view.
+### **buffer-close**
+Close the current buffer.
+### **buffer-close!**
+Close the current buffer forcefully, ignoring unsaved changes.
+### **buffer-close-others**
+Close all buffers but the currently focused one.
+### **buffer-close-others!**
+Force close all buffers but the currently focused one.
+### **buffer-close-all**
+Close all buffers without quitting.
+### **buffer-close-all!**
+Force close all buffers ignoring unsaved changes without quitting.
+### **buffer-next**
+Goto next buffer.
+### **buffer-previous**
+Goto previous buffer.
+### **write**
+Write changes to disk. Accepts an optional path (:write some/path.txt)
+### **write!**
+Force write changes to disk creating necessary subdirectories. Accepts an optional path (:write! some/path.txt)
+### **write-buffer-close**
+Write changes to disk and closes the buffer. Accepts an optional path (:write-buffer-close some/path.txt)
+### **write-buffer-close!**
+Force write changes to disk creating necessary subdirectories and closes the buffer. Accepts an optional path (:write-buffer-close! some/path.txt)
+### **new**
+Create a new scratch buffer.
+### **format**
+Format the file using an external formatter or language server.
+### **indent-style**
+Set the indentation style for editing. ('t' for tabs or 1-16 for number of spaces.)
+### **line-ending**
+Set the document's default line ending. Options: crlf, lf.
+### **earlier**
+Jump back to an earlier point in edit history. Accepts a number of steps or a time span.
+### **later**
+Jump to a later point in edit history. Accepts a number of steps or a time span.
+### **write-quit**
+Write changes to disk and close the current view. Accepts an optional path (:wq some/path.txt)
+### **write-quit!**
+Write changes to disk and close the current view forcefully. Accepts an optional path (:wq! some/path.txt)
+### **write-all**
+Write changes from all buffers to disk.
+### **write-all!**
+Forcefully write changes from all buffers to disk creating necessary subdirectories.
+### **write-quit-all**
+Write changes from all buffers to disk and close all views.
+### **write-quit-all!**
+Write changes from all buffers to disk and close all views forcefully (ignoring unsaved changes).
+### **quit-all**
+Close all views.
+### **quit-all!**
+Force close all views ignoring unsaved changes.
+### **cquit**
+Quit with exit code (default 1). Accepts an optional integer exit code (:cq 2).
+### **cquit!**
+Force quit with exit code (default 1) ignoring unsaved changes. Accepts an optional integer exit code (:cq! 2).
+### **theme**
+Change the editor theme (show current theme if no name specified).
+### **yank-join**
+Yank joined selections. A separator can be provided as first argument. Default value is newline.
+### **clipboard-yank**
+Yank main selection into system clipboard.
+### **clipboard-yank-join**
+Yank joined selections into system clipboard. A separator can be provided as first argument. Default value is newline.
+### **primary-clipboard-yank**
+Yank main selection into system primary clipboard.
+### **primary-clipboard-yank-join**
+Yank joined selections into system primary clipboard. A separator can be provided as first argument. Default value is newline.
+### **clipboard-paste-after**
+Paste system clipboard after selections.
+### **clipboard-paste-before**
+Paste system clipboard before selections.
+### **clipboard-paste-replace**
+Replace selections with content of system clipboard.
+### **primary-clipboard-paste-after**
+Paste primary clipboard after selections.
+### **primary-clipboard-paste-before**
+Paste primary clipboard before selections.
+### **primary-clipboard-paste-replace**
+Replace selections with content of system primary clipboard.
+### **show-clipboard-provider**
+Show clipboard provider name in status bar.
+### **change-current-directory**
+Change the current working directory.
+### **show-directory**
+Show the current working directory.
+### **encoding**
+Set encoding. Based on `https://encoding.spec.whatwg.org`.
+### **character-info**
+Get info about the character under the primary cursor.
+### **reload**
+Discard changes and reload from the source file.
+### **reload-all**
+Discard changes and reload all documents from the source files.
+### **update**
+Write changes only if the file has been modified.
+### **lsp-workspace-command**
+Open workspace command picker
+### **lsp-restart**
+Restarts the given language servers, or all language servers that are used by the current file if no arguments are supplied
+### **lsp-stop**
+Stops the given language servers, or all language servers that are used by the current file if no arguments are supplied
+### **tree-sitter-scopes**
+Display tree sitter scopes, primarily for theming and development.
+### **tree-sitter-highlight-name**
+Display name of tree-sitter highlight scope under the cursor.
+### **debug-start**
+Start a debug session from a given template with given parameters.
+### **debug-remote**
+Connect to a debug adapter by TCP address and start a debugging session from a given template with given parameters.
+### **debug-eval**
+Evaluate expression in current debug context.
+### **vsplit**
+Open the file in a vertical split.
+### **vsplit-new**
+Open a scratch buffer in a vertical split.
+### **hsplit**
+Open the file in a horizontal split.
+### **hsplit-new**
+Open a scratch buffer in a horizontal split.
+### **tutor**
+Open the tutorial.
+### **goto**
+Goto line number.
+### **set-language**
+Set the language of current buffer (show current language if no value specified).
+### **set-option**
+Set a config option at runtime.
+For example to disable smart case search, use `:set search.smart-case false`.
+### **toggle-option**
+Toggle a config option at runtime.
+For example to toggle smart case search, use `:toggle search.smart-case`.
+### **get-option**
+Get the current value of a config option.
+### **sort**
+Sort ranges in selection.
+### **reflow**
+Hard-wrap the current selection of lines to a given width.
+### **tree-sitter-subtree**
+Display the smallest tree-sitter subtree that spans the primary selection, primarily for debugging queries.
+### **config-reload**
+Refresh user config.
+### **config-open**
+Open the user config.toml file.
+### **config-open-workspace**
+Open the workspace config.toml file.
+### **log-open**
+Open the helix log file.
+### **insert-output**
+Run shell command, inserting output before each selection.
+### **append-output**
+Run shell command, appending output after each selection.
+### **pipe**
+Pipe each selection to the shell command.
+### **pipe-to**
+Pipe each selection to the shell command, ignoring output.
+### **run-shell-command**
+Run a shell command
+### **reset-diff-change**
+Reset the diff change at the cursor position.
+### **clear-register**
+Clear given register. If no argument is provided, clear all registers.
+### **redraw**
+Clear and re-render the whole UI
+### **move**
+Move the current buffer and its corresponding file to a different path
+### **yank-diagnostic**
+Yank diagnostic(s) under primary cursor to register, or clipboard by default
+### **read**
+Load a file into buffer
+### **echo**
+Prints the given arguments to the statusline.
+### **noop**
+Does nothing.
+# /home/matt/.steel/cogs/helix/misc.scm
+### **hx.cx->pos**
+DEPRECATED: Please use `cursor-position`
+### **cursor-position**
+Returns the cursor position within the current buffer as an integer
+### **hx.custom-insert-newline**
+DEPRECATED: Please use `insert-newline-hook`
+### **insert-newline-hook**
+Inserts a new line with the provided indentation.
+
+```scheme
+(insert-newline-hook indent-string)
+```
+
+indent-string : string?
+
+### **push-component!**
+
+Push a component on to the top of the stack.
+
+```scheme
+(push-component! component)
+```
+
+component : WrappedDynComponent?
+       
+### **pop-last-component!**
+DEPRECATED: Please use `pop-last-component-by-name!`
+### **pop-last-component-by-name!**
+Pops the last component off of the stack by name. In other words,
+it removes the component matching this name from the stack.
+
+```scheme
+(pop-last-component-by-name! name)
+```
+
+name : string?
+       
+### **enqueue-thread-local-callback**
+
+Enqueue a function to be run following this context of execution. This could
+be useful for yielding back to the editor in the event you want updates to happen
+before your function is run.
+
+```scheme
+(enqueue-thread-local-callback callback)
+```
+
+callback : (-> any?)
+   Function with no arguments.
+
+# Examples
+
+```scheme
+(enqueue-thread-local-callback (lambda () (theme "focus_nova")))
+```
+       
+### **set-status!**
+Sets the content of the status line
+### **send-lsp-command**
+Send an lsp command. The `lsp-name` must correspond to an active lsp.
+The method name corresponds to the method name that you'd expect to see
+with the lsp, and the params can be passed as a hash table. The callback
+provided will be called with whatever result is returned from the LSP,
+deserialized from json to a steel value.
+
+# Example
+```scheme
+(define (view-crate-graph)
+  (send-lsp-command "rust-analyzer"
+                    "rust-analyzer/viewCrateGraph"
+                    (hash "full" #f)
+                    ;; Callback to run with the result
+                    (lambda (result) (displayln result))))
+```
+### **acquire-context-lock**
+
+Schedule a function to run on the main thread. This is a fairly low level function, and odds are
+you'll want to use some abstractions on top of this.
+
+The provided function will get enqueued to run on the main thread, and during the duration of the functions
+execution, the provided mutex will be locked.
+
+```scheme
+(acquire-context-lock callback-fn mutex)
+```
+
+callback-fn : (-> void?)
+   Function with no arguments
+
+mutex : mutex?
+### **enqueue-thread-local-callback-with-delay**
+
+Enqueue a function to be run following this context of execution, after a delay. This could
+be useful for yielding back to the editor in the event you want updates to happen
+before your function is run.
+
+```scheme
+(enqueue-thread-local-callback-with-delay delay callback)
+```
+
+delay : int?
+   Time to delay the callback by in milliseconds
+
+callback : (-> any?)
+   Function with no arguments.
+
+# Examples
+
+```scheme
+(enqueue-thread-local-callback-with-delay 1000 (lambda () (theme "focus_nova"))) ;; Run after 1 second
+``
+       
+### **helix-await-callback**
+DEPRECATED: Please use `await-callback`
+### **await-callback**
+
+Await the given value, and call the callback function on once the future is completed.
+
+```scheme
+(await-callback future callback)
+```
+
+* future : future?
+* callback (-> any?)
+   Function with no arguments
+### **add-inlay-hint**
+
+Warning: this is experimental
+
+Adds an inlay hint at the given character index.
+
+```scheme
+(add-inlay-hint char-index completion)
+```
+
+char-index : int?
+completion : string?
+
+### **remove-inlay-hint**
+
+Warning: this is experimental
+
+Removes an inlay hint at the given character index. Note - to remove
+properly, the completion must match what was already there.
+
+```scheme
+(remove-inlay-hint char-index completion)
+```
+
+char-index : int?
+completion : string?
+
+# /home/matt/.steel/cogs/helix/editor.scm
+### **editor-focus**
+
+Get the current focus of the editor, as a `ViewId`.
+
+```scheme
+(editor-focus) -> ViewId
+```
+       
+### **editor-mode**
+
+Get the current mode of the editor
+
+```scheme
+(editor-mode) -> Mode?
+```
+       
+### **cx->themes**
+DEPRECATED: Please use `themes->list`
+### **themes->list**
+
+Get the current themes as a list of strings.
+
+```scheme
+(themes->list) -> (listof string?)
+```
+       
+### **editor-all-documents**
+
+Get a list of all of the document ids that are currently open.
+
+```scheme
+(editor-all-documents) -> (listof DocumentId?)
+```
+       
+### **cx->cursor**
+DEPRECATED: Please use `current-cursor`
+### **current-cursor**
+Gets the primary cursor position in screen coordinates,
+or `#false` if the primary cursor is not visible on screen.
+
+```scheme
+(current-cursor) -> (listof? (or Position? #false) CursorKind)
+```
+       
+### **editor-focused-buffer-area**
+
+Get the `Rect` associated with the currently focused buffer.
+
+```scheme
+(editor-focused-buffer-area) -> (or Rect? #false)
+```
+       
+### **editor->doc-id**
+Get the document from a given view.
+### **editor-switch!**
+Open the document in a vertical split.
+### **editor-set-focus!**
+Set focus on the view.
+### **editor-set-mode!**
+Set the editor mode.
+### **editor-doc-in-view?**
+Check whether the current view contains a document.
+### **set-scratch-buffer-name!**
+Set the name of a scratch buffer.
+### **set-buffer-uri!**
+Set the URI of the buffer
+### **editor-doc-exists?**
+Check if a document exists.
+### **editor-document-last-saved**
+Check when a document was last saved (returns a `SystemTime`)
+### **editor-document-dirty?**
+Check if a document has unsaved changes
+### **editor->text**
+Get the document as a rope.
+### **editor-document->path**
+Get the path to a document.
+### **register->value**
+Get register value as a list of strings.
+### **set-editor-clip-top!**
+Set the editor clipping at the top.
+### **set-editor-clip-right!**
+Set the editor clipping at the right.
+### **set-editor-clip-left!**
+Set the editor clipping at the left.
+### **set-editor-clip-bottom!**
+Set the editor clipping at the bottom.
+# /home/matt/.steel/cogs/helix/themes.scm
+### **register-theme**
+Register this theme with helix for use
+### **attribute**
+Class attributes, HTML tag attributes
+### **type**
+Types
+### **type.builtin**
+Primitive types provided by the language (`int`, `usize`)
+### **type.parameter**
+Generic type parameters (`T`)
+### **type.enum**
+Enum usage
+### **type.enum.variant**
+Enum variant
+### **constructor**
+Constructor usage
+### **constant**
+Constants usage
+### **constant.builtin**
+Special constants provided by the language (`true`, `false`, `nil`, etc)
+### **constant.builtin.boolean**
+A special case for highlighting individual booleans
+### **constant.character**
+Character usage
+### **constant.character.escape**
+Highlighting individual escape characters
+### **constant.numeric**
+Numbers
+### **constant.numeric.integer**
+Integers
+### **constant.numeric.float**
+Floats
+### **string**
+Highlighting strings
+### **string.regexp**
+Highlighting regular expressions
+### **string.special**
+Special strings
+### **string.special.path**
+Highlighting paths
+### **string.special.url**
+Highlighting URLs
+### **string.special.symbol**
+Erlang/Elixir atoms, Ruby symbols, Clojure keywords
+### **comment**
+Highlighting comments
+### **comment.line**
+Single line comments (`//`)
+### **comment.block**
+Block comments (`/* */`)
+### **comment.block.documentation**
+Documentation comments (e.g. `///` in Rust)
+### **variable**
+Variables
+### **variable.builtin**
+Reserved language variables (`self`, `this`, `super`, etc.)
+### **variable.parameter**
+Function parameters
+### **variable.other**
+Other variables
+### **variable.other.member**
+Fields of composite data types (e.g. structs, unions)
+### **variable.other.member.private**
+Private fields that use a unique syntax (currently just EMCAScript-based languages)
+### **label**
+Highlighting labels
+### **punctuation**
+Highlighting punctuation
+### **punctuation.delimiter**
+Commas, colon
+### **punctuation.bracket**
+Parentheses, angle brackets, etc.
+### **punctuation.special**
+String interpolation brackets
+### **keyword**
+Highlighting keywords
+### **keyword.control**
+Control keywords
+### **keyword.control.conditional**
+if, else
+### **keyword.control.repeat**
+for, while, loop
+### **keyword.control.import**
+import, export
+### **keyword.control.return**
+return keyword
+### **keyword.control.exception**
+exception keyword
+### **keyword.operator**
+or, in
+### **keyword.directive**
+Preprocessor directives (`#if` in C)
+### **keyword.function**
+fn, func
+### **keyword.storage**
+Keywords describing how things are stored
+### **keyword.storage.type**
+The type of something, `class`, `function`, `var`, `let`, etc
+### **keyword.storage.modifier**
+Storage modifiers like `static`, `mut`, `const`, `ref`, etc
+### **operator**
+Operators such as `||`, `+=`, `>`, etc
+### **function**
+Highlighting function calls
+### **function.builtin**
+Builtin functions
+### **function.method**
+Calling methods
+### **function.method.private**
+Private methods that use a unique syntax (currently just ECMAScript-based languages)
+### **function.macro**
+Highlighting macros
+### **function.special**
+Preprocessor in C
+### **tag**
+Tags (e.g. <body> in HTML)
+### **tag.builtin**
+Builtin tags
+### **markup**
+Highlighting markdown
+### **markup.heading**
+Markdown heading
+### **markup.heading.marker**
+Markdown heading marker
+### **markup.heading.marker.1**
+Markdown heading text h1
+### **markup.heading.marker.2**
+Markdown heading text h2
+### **markup.heading.marker.3**
+Markdown heading text h3
+### **markup.heading.marker.4**
+Markdown heading text h4
+### **markup.heading.marker.5**
+Markdown heading text h5
+### **markup.heading.marker.6**
+Markdown heading text h6
+### **markup.list**
+Markdown lists
+### **markup.list.unnumbered**
+Unnumbered markdown lists
+### **markup.list.numbered**
+Numbered markdown lists
+### **markup.list.checked**
+Checked markdown lists
+### **markup.list.unchecked**
+Unchecked markdown lists
+### **markup.bold**
+Markdown bold
+### **markup.italic**
+Markdown italics
+### **markup.strikethrough**
+Markdown strikethrough
+### **markup.link**
+Markdown links
+### **markup.link.url**
+URLs pointed to by links
+### **markup.link.label**
+non-URL link references
+### **markup.link.text**
+URL and image descriptions in links
+### **markup.quote**
+Markdown quotes
+### **markup.raw**
+Markdown raw
+### **markup.raw.inline**
+Markdown inline raw
+### **markup.raw.block**
+Markdown raw block
+### **diff**
+Version control changes
+### **diff.plus**
+Version control additions
+### **diff.plus.gutter**
+Version control addition gutter indicator
+### **diff.minus**
+Version control deletions
+### **diff.minus.gutter**
+Version control deletion gutter indicator
+### **diff.delta**
+Version control modifications
+### **diff.delta.moved**
+Renamed or moved files/changes
+### **diff.delta.conflict**
+Merge conflicts
+### **diff.delta.gutter**
+Gutter indicator
+### **markup.normal.completion**
+For completion doc popup UI
+### **markup.normal.hover**
+For hover popup UI
+### **markup.heading.completion**
+For completion doc popup UI
+### **markup.heading.hover**
+For hover popup UI
+### **markup.raw.inline.completion**
+For completion doc popup UI
+### **markup.raw.inline.hover**
+For hover popup UI
+### **ui.background.separator**
+Picker separator below input line
+### **ui.cursor.match**
+Matching bracket etc.
+### **ui.cursor.primary**
+Cursor with primary selection
+### **ui.debug.breakpoint**
+Breakpoint indicator, found in the gutter
+### **ui.debug.active**
+Indicator for the line at which debugging execution is paused at, found in the gutter
+### **ui.gutter**
+Gutter
+### **ui.gutter.selected**
+Gutter for the line the cursor is on
+### **ui.highlight.frameline**
+Line at which debugging execution is paused at
+### **ui.linenr**
+Line numbers
+### **ui.linenr.selected**
+Line number for the line the cursor is on
+### **ui.statusline**
+Statusline
+### **ui.statusline.inactive**
+Statusline (unfocused document)
+### **ui.statusline.normal**
+Statusline mode during normal mode (only if editor.color-modes is enabled)
+### **ui.statusline.insert**
+Statusline mode during insert mode (only if editor.color-modes is enabled)
+### **ui.statusline.select**
+Statusline mode during select mode (only if editor.color-modes is enabled)
+### **ui.statusline.separator**
+Separator character in statusline
+### **ui.bufferline**
+Style for the buffer line
+### **ui.bufferline.active**
+Style for the active buffer in buffer line
+### **ui.bufferline.background**
+Style for the bufferline background
+### **ui.popup**
+Documentation popups (e.g. Space + k)
+### **ui.popup.info**
+Prompt for multiple key options
+### **ui.window**
+Borderline separating splits
+### **ui.help**
+Description box for commands
+### **ui.text**
+Default text style, command prompts, popup text, etc.
+### **ui.text.focus**
+The currently selected line in the picker
+### **ui.text.inactive**
+Same as ui.text but when the text is inactive (e.g. suggestions)
+### **ui.text.info**
+The key: command text in ui.popup.info boxes
+### **ui.virtual.ruler**
+Ruler columns (see the editor.rules config)
+### **ui.virtual.whitespace**
+Visible whitespace characters
+### **ui.virtual.indent-guide**
+Vertical indent width guides
+### **ui.virtual.inlay-hint**
+Default style for inlay hints of all kinds
+### **ui.virtual.inlay-hint.parameter**
+Style for inlay hints of kind `parameter` (LSPs are not rquired to set a kind)
+### **ui.virtual.inlay-hint.type**
+Style for inlay hints of kind `type` (LSPs are not required to set a kind)
+### **ui.virtual.wrap**
+Soft-wrap indicator (see the editor.soft-wrap config)
+### **ui.virtual.jump-label**
+Style for virtual jump labels
+### **ui.menu**
+Code and command completion menus
+### **ui.menu.selected**
+Selected autocomplete item
+### **ui.menu.scroll**
+fg sets thumb color, bg sets track color of scrollbar
+### **ui.selection**
+For selections in the editing area
+### **ui.highlight**
+Highlighted lines in the picker preview
+### **ui.cursorline**
+The line of the cursor (if cursorline is enabled)
+### **ui.cursorline.primary**
+The line of the primary cursor (if cursorline is enabled)
+### **ui.cursorline.secondary**
+The line of the secondary cursor (if cursorline is enabled)
+### **ui.cursorcolumn.primary**
+The column of the primary cursor (if cursorcolumn is enabled)
+### **ui.cursorcolumn.secondary**
+The column of the secondary cursor (if cursorcolumn is enabled)
+### **warning**
+Diagnostics warning (gutter)
+### **error**
+Diagnostics error (gutter)
+### **info**
+Diagnostics info (gutter)
+### **hint**
+Diagnostics hint (gutter)
+### **diagnostic**
+Diagnostics fallback style (editing area)
+### **diagnostic.hint**
+Diagnostics hint (editing area)
+### **diagnostic.info**
+Diagnostics info (editing area)
+### **diagnostic.warning**
+Diagnostics warning (editing area)
+### **diagnostic.error**
+Diagnostics error (editing area)
+### **diagnostic.unnecessary**
+Diagnostics with unnecessary tag (editing area)
+### **diagnostic.deprecated**
+Diagnostics with deprecated tag (editing area)
+# /home/matt/.steel/cogs/helix/static.scm
+### **no_op**
+Do nothing
+### **move_char_left**
+Move left
+### **move_char_right**
+Move right
+### **move_line_up**
+Move up
+### **move_line_down**
+Move down
+### **move_visual_line_up**
+Move up
+### **move_visual_line_down**
+Move down
+### **extend_char_left**
+Extend left
+### **extend_char_right**
+Extend right
+### **extend_line_up**
+Extend up
+### **extend_line_down**
+Extend down
+### **extend_visual_line_up**
+Extend up
+### **extend_visual_line_down**
+Extend down
+### **copy_selection_on_next_line**
+Copy selection on next line
+### **copy_selection_on_prev_line**
+Copy selection on previous line
+### **move_next_word_start**
+Move to start of next word
+### **move_prev_word_start**
+Move to start of previous word
+### **move_next_word_end**
+Move to end of next word
+### **move_prev_word_end**
+Move to end of previous word
+### **move_next_long_word_start**
+Move to start of next long word
+### **move_prev_long_word_start**
+Move to start of previous long word
+### **move_next_long_word_end**
+Move to end of next long word
+### **move_prev_long_word_end**
+Move to end of previous long word
+### **move_next_sub_word_start**
+Move to start of next sub word
+### **move_prev_sub_word_start**
+Move to start of previous sub word
+### **move_next_sub_word_end**
+Move to end of next sub word
+### **move_prev_sub_word_end**
+Move to end of previous sub word
+### **move_parent_node_end**
+Move to end of the parent node
+### **move_parent_node_start**
+Move to beginning of the parent node
+### **extend_next_word_start**
+Extend to start of next word
+### **extend_prev_word_start**
+Extend to start of previous word
+### **extend_next_word_end**
+Extend to end of next word
+### **extend_prev_word_end**
+Extend to end of previous word
+### **extend_next_long_word_start**
+Extend to start of next long word
+### **extend_prev_long_word_start**
+Extend to start of previous long word
+### **extend_next_long_word_end**
+Extend to end of next long word
+### **extend_prev_long_word_end**
+Extend to end of prev long word
+### **extend_next_sub_word_start**
+Extend to start of next sub word
+### **extend_prev_sub_word_start**
+Extend to start of previous sub word
+### **extend_next_sub_word_end**
+Extend to end of next sub word
+### **extend_prev_sub_word_end**
+Extend to end of prev sub word
+### **extend_parent_node_end**
+Extend to end of the parent node
+### **extend_parent_node_start**
+Extend to beginning of the parent node
+### **find_till_char**
+Move till next occurrence of char
+### **find_next_char**
+Move to next occurrence of char
+### **extend_till_char**
+Extend till next occurrence of char
+### **extend_next_char**
+Extend to next occurrence of char
+### **till_prev_char**
+Move till previous occurrence of char
+### **find_prev_char**
+Move to previous occurrence of char
+### **extend_till_prev_char**
+Extend till previous occurrence of char
+### **extend_prev_char**
+Extend to previous occurrence of char
+### **repeat_last_motion**
+Repeat last motion
+### **replace**
+Replace with new char
+### **switch_case**
+Switch (toggle) case
+### **switch_to_uppercase**
+Switch to uppercase
+### **switch_to_lowercase**
+Switch to lowercase
+### **page_up**
+Move page up
+### **page_down**
+Move page down
+### **half_page_up**
+Move half page up
+### **half_page_down**
+Move half page down
+### **page_cursor_up**
+Move page and cursor up
+### **page_cursor_down**
+Move page and cursor down
+### **page_cursor_half_up**
+Move page and cursor half up
+### **page_cursor_half_down**
+Move page and cursor half down
+### **select_all**
+Select whole document
+### **select_regex**
+Select all regex matches inside selections
+### **split_selection**
+Split selections on regex matches
+### **split_selection_on_newline**
+Split selection on newlines
+### **merge_selections**
+Merge selections
+### **merge_consecutive_selections**
+Merge consecutive selections
+### **search**
+Search for regex pattern
+### **rsearch**
+Reverse search for regex pattern
+### **search_next**
+Select next search match
+### **search_prev**
+Select previous search match
+### **extend_search_next**
+Add next search match to selection
+### **extend_search_prev**
+Add previous search match to selection
+### **search_selection**
+Use current selection as search pattern
+### **search_selection_detect_word_boundaries**
+Use current selection as the search pattern, automatically wrapping with `\b` on word boundaries
+### **make_search_word_bounded**
+Modify current search to make it word bounded
+### **global_search**
+Global search in workspace folder
+### **extend_line**
+Select current line, if already selected, extend to another line based on the anchor
+### **extend_line_below**
+Select current line, if already selected, extend to next line
+### **extend_line_above**
+Select current line, if already selected, extend to previous line
+### **select_line_above**
+Select current line, if already selected, extend or shrink line above based on the anchor
+### **select_line_below**
+Select current line, if already selected, extend or shrink line below based on the anchor
+### **extend_to_line_bounds**
+Extend selection to line bounds
+### **shrink_to_line_bounds**
+Shrink selection to line bounds
+### **delete_selection**
+Delete selection
+### **delete_selection_noyank**
+Delete selection without yanking
+### **change_selection**
+Change selection
+### **change_selection_noyank**
+Change selection without yanking
+### **collapse_selection**
+Collapse selection into single cursor
+### **flip_selections**
+Flip selection cursor and anchor
+### **ensure_selections_forward**
+Ensure all selections face forward
+### **insert_mode**
+Insert before selection
+### **append_mode**
+Append after selection
+### **command_mode**
+Enter command mode
+### **file_picker**
+Open file picker
+### **file_picker_in_current_buffer_directory**
+Open file picker at current buffer's directory
+### **file_picker_in_current_directory**
+Open file picker at current working directory
+### **file_explorer**
+Open file explorer in workspace root
+### **file_explorer_in_current_buffer_directory**
+Open file explorer at current buffer's directory
+### **file_explorer_in_current_directory**
+Open file explorer at current working directory
+### **code_action**
+Perform code action
+### **buffer_picker**
+Open buffer picker
+### **jumplist_picker**
+Open jumplist picker
+### **symbol_picker**
+Open symbol picker
+### **changed_file_picker**
+Open changed file picker
+### **select_references_to_symbol_under_cursor**
+Select symbol references
+### **workspace_symbol_picker**
+Open workspace symbol picker
+### **diagnostics_picker**
+Open diagnostic picker
+### **workspace_diagnostics_picker**
+Open workspace diagnostic picker
+### **last_picker**
+Open last picker
+### **insert_at_line_start**
+Insert at start of line
+### **insert_at_line_end**
+Insert at end of line
+### **open_below**
+Open new line below selection
+### **open_above**
+Open new line above selection
+### **normal_mode**
+Enter normal mode
+### **select_mode**
+Enter selection extend mode
+### **exit_select_mode**
+Exit selection mode
+### **goto_definition**
+Goto definition
+### **goto_declaration**
+Goto declaration
+### **add_newline_above**
+Add newline above
+### **add_newline_below**
+Add newline below
+### **goto_type_definition**
+Goto type definition
+### **goto_implementation**
+Goto implementation
+### **goto_file_start**
+Goto line number <n> else file start
+### **goto_file_end**
+Goto file end
+### **extend_to_file_start**
+Extend to line number<n> else file start
+### **extend_to_file_end**
+Extend to file end
+### **goto_file**
+Goto files/URLs in selections
+### **goto_file_hsplit**
+Goto files in selections (hsplit)
+### **goto_file_vsplit**
+Goto files in selections (vsplit)
+### **goto_reference**
+Goto references
+### **goto_window_top**
+Goto window top
+### **goto_window_center**
+Goto window center
+### **goto_window_bottom**
+Goto window bottom
+### **goto_last_accessed_file**
+Goto last accessed file
+### **goto_last_modified_file**
+Goto last modified file
+### **goto_last_modification**
+Goto last modification
+### **goto_line**
+Goto line
+### **goto_last_line**
+Goto last line
+### **extend_to_last_line**
+Extend to last line
+### **goto_first_diag**
+Goto first diagnostic
+### **goto_last_diag**
+Goto last diagnostic
+### **goto_next_diag**
+Goto next diagnostic
+### **goto_prev_diag**
+Goto previous diagnostic
+### **goto_next_change**
+Goto next change
+### **goto_prev_change**
+Goto previous change
+### **goto_first_change**
+Goto first change
+### **goto_last_change**
+Goto last change
+### **goto_line_start**
+Goto line start
+### **goto_line_end**
+Goto line end
+### **goto_column**
+Goto column
+### **extend_to_column**
+Extend to column
+### **goto_next_buffer**
+Goto next buffer
+### **goto_previous_buffer**
+Goto previous buffer
+### **goto_line_end_newline**
+Goto newline at line end
+### **goto_first_nonwhitespace**
+Goto first non-blank in line
+### **trim_selections**
+Trim whitespace from selections
+### **extend_to_line_start**
+Extend to line start
+### **extend_to_first_nonwhitespace**
+Extend to first non-blank in line
+### **extend_to_line_end**
+Extend to line end
+### **extend_to_line_end_newline**
+Extend to line end
+### **signature_help**
+Show signature help
+### **smart_tab**
+Insert tab if all cursors have all whitespace to their left; otherwise, run a separate command.
+### **insert_tab**
+Insert tab char
+### **insert_newline**
+Insert newline char
+### **delete_char_backward**
+Delete previous char
+### **delete_char_forward**
+Delete next char
+### **delete_word_backward**
+Delete previous word
+### **delete_word_forward**
+Delete next word
+### **kill_to_line_start**
+Delete till start of line
+### **kill_to_line_end**
+Delete till end of line
+### **undo**
+Undo change
+### **redo**
+Redo change
+### **earlier**
+Move backward in history
+### **later**
+Move forward in history
+### **commit_undo_checkpoint**
+Commit changes to new checkpoint
+### **yank**
+Yank selection
+### **yank_to_clipboard**
+Yank selections to clipboard
+### **yank_to_primary_clipboard**
+Yank selections to primary clipboard
+### **yank_joined**
+Join and yank selections
+### **yank_joined_to_clipboard**
+Join and yank selections to clipboard
+### **yank_main_selection_to_clipboard**
+Yank main selection to clipboard
+### **yank_joined_to_primary_clipboard**
+Join and yank selections to primary clipboard
+### **yank_main_selection_to_primary_clipboard**
+Yank main selection to primary clipboard
+### **replace_with_yanked**
+Replace with yanked text
+### **replace_selections_with_clipboard**
+Replace selections by clipboard content
+### **replace_selections_with_primary_clipboard**
+Replace selections by primary clipboard
+### **paste_after**
+Paste after selection
+### **paste_before**
+Paste before selection
+### **paste_clipboard_after**
+Paste clipboard after selections
+### **paste_clipboard_before**
+Paste clipboard before selections
+### **paste_primary_clipboard_after**
+Paste primary clipboard after selections
+### **paste_primary_clipboard_before**
+Paste primary clipboard before selections
+### **indent**
+Indent selection
+### **unindent**
+Unindent selection
+### **format_selections**
+Format selection
+### **join_selections**
+Join lines inside selection
+### **join_selections_space**
+Join lines inside selection and select spaces
+### **keep_selections**
+Keep selections matching regex
+### **remove_selections**
+Remove selections matching regex
+### **align_selections**
+Align selections in column
+### **keep_primary_selection**
+Keep primary selection
+### **remove_primary_selection**
+Remove primary selection
+### **completion**
+Invoke completion popup
+### **hover**
+Show docs for item under cursor
+### **toggle_comments**
+Comment/uncomment selections
+### **toggle_line_comments**
+Line comment/uncomment selections
+### **toggle_block_comments**
+Block comment/uncomment selections
+### **rotate_selections_forward**
+Rotate selections forward
+### **rotate_selections_backward**
+Rotate selections backward
+### **rotate_selection_contents_forward**
+Rotate selection contents forward
+### **rotate_selection_contents_backward**
+Rotate selections contents backward
+### **reverse_selection_contents**
+Reverse selections contents
+### **expand_selection**
+Expand selection to parent syntax node
+### **shrink_selection**
+Shrink selection to previously expanded syntax node
+### **select_next_sibling**
+Select next sibling in the syntax tree
+### **select_prev_sibling**
+Select previous sibling the in syntax tree
+### **select_all_siblings**
+Select all siblings of the current node
+### **select_all_children**
+Select all children of the current node
+### **jump_forward**
+Jump forward on jumplist
+### **jump_backward**
+Jump backward on jumplist
+### **save_selection**
+Save current selection to jumplist
+### **jump_view_right**
+Jump to right split
+### **jump_view_left**
+Jump to left split
+### **jump_view_up**
+Jump to split above
+### **jump_view_down**
+Jump to split below
+### **swap_view_right**
+Swap with right split
+### **swap_view_left**
+Swap with left split
+### **swap_view_up**
+Swap with split above
+### **swap_view_down**
+Swap with split below
+### **transpose_view**
+Transpose splits
+### **rotate_view**
+Goto next window
+### **rotate_view_reverse**
+Goto previous window
+### **hsplit**
+Horizontal bottom split
+### **hsplit_new**
+Horizontal bottom split scratch buffer
+### **vsplit**
+Vertical right split
+### **vsplit_new**
+Vertical right split scratch buffer
+### **wclose**
+Close window
+### **wonly**
+Close windows except current
+### **select_register**
+Select register
+### **insert_register**
+Insert register
+### **copy_between_registers**
+Copy between two registers
+### **align_view_middle**
+Align view middle
+### **align_view_top**
+Align view top
+### **align_view_center**
+Align view center
+### **align_view_bottom**
+Align view bottom
+### **scroll_up**
+Scroll view up
+### **scroll_down**
+Scroll view down
+### **match_brackets**
+Goto matching bracket
+### **surround_add**
+Surround add
+### **surround_replace**
+Surround replace
+### **surround_delete**
+Surround delete
+### **select_textobject_around**
+Select around object
+### **select_textobject_inner**
+Select inside object
+### **goto_next_function**
+Goto next function
+### **goto_prev_function**
+Goto previous function
+### **goto_next_class**
+Goto next type definition
+### **goto_prev_class**
+Goto previous type definition
+### **goto_next_parameter**
+Goto next parameter
+### **goto_prev_parameter**
+Goto previous parameter
+### **goto_next_comment**
+Goto next comment
+### **goto_prev_comment**
+Goto previous comment
+### **goto_next_test**
+Goto next test
+### **goto_prev_test**
+Goto previous test
+### **goto_next_entry**
+Goto next pairing
+### **goto_prev_entry**
+Goto previous pairing
+### **goto_next_paragraph**
+Goto next paragraph
+### **goto_prev_paragraph**
+Goto previous paragraph
+### **dap_launch**
+Launch debug target
+### **dap_restart**
+Restart debugging session
+### **dap_toggle_breakpoint**
+Toggle breakpoint
+### **dap_continue**
+Continue program execution
+### **dap_pause**
+Pause program execution
+### **dap_step_in**
+Step in
+### **dap_step_out**
+Step out
+### **dap_next**
+Step to next
+### **dap_variables**
+List variables
+### **dap_terminate**
+End debug session
+### **dap_edit_condition**
+Edit breakpoint condition on current line
+### **dap_edit_log**
+Edit breakpoint log message on current line
+### **dap_switch_thread**
+Switch current thread
+### **dap_switch_stack_frame**
+Switch stack frame
+### **dap_enable_exceptions**
+Enable exception breakpoints
+### **dap_disable_exceptions**
+Disable exception breakpoints
+### **shell_pipe**
+Pipe selections through shell command
+### **shell_pipe_to**
+Pipe selections into shell command ignoring output
+### **shell_insert_output**
+Insert shell command output before selections
+### **shell_append_output**
+Append shell command output after selections
+### **shell_keep_pipe**
+Filter selections with shell predicate
+### **suspend**
+Suspend and return to shell
+### **rename_symbol**
+Rename symbol
+### **increment**
+Increment item under cursor
+### **decrement**
+Decrement item under cursor
+### **record_macro**
+Record macro
+### **replay_macro**
+Replay macro
+### **command_palette**
+Open command palette
+### **goto_word**
+Jump to a two-character label
+### **extend_to_word**
+Extend to a two-character label
+### **goto_next_tabstop**
+Goto next snippet placeholder
+### **goto_prev_tabstop**
+Goto next snippet placeholder
+### **rotate_selections_first**
+Make the first selection your primary one
+### **rotate_selections_last**
+Make the last selection your primary one
+### **insert_char**
+Insert a given character at the cursor cursor position
+### **insert_string**
+Insert a given string at the current cursor position
+### **set-current-selection-object!**
+Update the selection object to the current selection within the editor
+### **regex-selection**
+Run the given regex within the existing buffer
+### **replace-selection-with**
+Replace the existing selection with the given string
+### **cx->current-file**
+Get the currently focused file path
+### **enqueue-expression-in-engine**
+Enqueue an expression to run at the top level context, 
+       after the existing function context has exited.
+### **current_selection**
+Returns the current selection as a string
+### **load-buffer!**
+Evaluates the current buffer
+### **current-highlighted-text!**
+Returns the currently highlighted text as a string
+### **get-current-line-number**
+Returns the current line number
+### **current-selection-object**
+Returns the current selection object
+### **get-helix-cwd**
+Returns the current working directly that helix is using
+### **move-window-far-left**
+Moves the current window to the far left
+### **move-window-far-right**
+Moves the current window to the far right
+### **get-helix-scm-path**
+Returns the path to the helix.scm file as a string
+### **get-init-scm-path**
+Returns the path to the init.scm file as a string
+# /home/matt/.steel/cogs/helix/ext.scm
+### **eval-buffer**
+Eval the current buffer, morally equivalent to load-buffer!
+### **evalp**
+Eval prompt
+### **running-on-main-thread?**
+Check what the main thread id is, compare to the main thread
+### **hx.with-context**
+If running on the main thread already, just do nothing.
+Check the ID of the engine, and if we're already on the
+main thread, just continue as is - i.e. just block. This does
+not block on the function if this is running on another thread.
+
+```scheme
+(hx.with-context thunk)
+```
+thunk : (-> any?) ;; Function that has no arguments
+
+# Examples
+```scheme
+(spawn-native-thread
+  (lambda () 
+    (hx.with-context (lambda () (theme "nord")))))
+```
+### **hx.block-on-task**
+Block on the given function.
+```scheme
+(hx.block-on-task thunk)
+```
+thunk : (-> any?) ;; Function that has no arguments
+
+# Examples
+```scheme
+(define thread
+  (spawn-native-thread
+    (lambda () 
+      (hx.block-on-task (lambda () (theme "nord") 10)))))
+
+;; Some time later, in a different context - if done at the same time,
+;; this will deadline, since the join depends on the callback previously
+;; executing.
+(equal? (thread-join! thread) 10) ;; => #true
+```
+# /home/matt/.steel/cogs/helix/components.scm
+### **theme->bg**
+Gets the `Style` associated with the bg for the current theme
+### **theme->fg**
+Gets the `style` associated with the fg for the current theme
+### **theme-scope**
+Get the `Style` associated with the given scope from the current theme
+### **Position?**
+Check if the given value is a `Position`
+
+```scheme
+(Position? value) -> bool?
+```
+
+value : any?
+
+       
+### **Style?**
+Check if the given valuie is `Style`
+
+```scheme
+(Style? value) -> bool?
+```
+
+value : any?
+### **Buffer?**
+
+Checks if the given value is a `Buffer`
+
+```scheme
+(Buffer? value) -> bool?
+```
+
+value : any?
+       
+### **buffer-area**
+
+Get the `Rect` associated with the given `Buffer`
+
+```scheme
+(buffer-area buffer)
+```
+
+* buffer : Buffer?
+       
+### **frame-set-string!**
+
+Set the string at the given `x` and `y` positions for the given `Buffer`, with a provided `Style`.
+
+```scheme
+(frame-set-string! buffer x y string style)
+```
+
+buffer : Buffer?,
+x : int?,
+y : int?,
+string: string?,
+style: Style?,
+       
+### **SteelEventResult?**
+
+Check whether the given value is a `SteelEventResult`.
+
+```scheme
+(SteelEventResult? value) -> bool?
+```
+
+value : any?
+
+       
+### **new-component!**
+
+Construct a new dynamic component. This is used for creating widgets or floating windows
+that exist outside of the buffer. This just constructs the component, it does not push the component
+on to the component stack. For that, you'll use `push-component!`.
+
+```scheme
+(new-component! name state render function-map)
+```
+
+name : string? - This is the name of the comoponent itself.
+state : any? - Typically this is a struct that holds the state of the component.
+render : (-> state? Rect? Buffer?)
+   This is a function that will get called with each frame. The first argument is the state object provided,
+   and the second is the `Rect?` to render against, ultimately against the `Buffer?`.
+
+function-map : (hashof string? function?)
+   This is a hashmap of strings -> function that contains a few important functions:
+
+   "handle_event" : (-> state? Event?) -> SteelEventResult?
+
+       This is called on every event with an event object. There are multiple options you can use
+       when returning from this function:
+
+       * event-result/consume
+       * event-result/consume-without-rerender
+       * event-result/ignore
+       * event-result/close
+
+       See the associated docs for those to understand the implications for each.
+       
+   "cursor" : (-> state? Rect?) -> Position?
+
+       This tells helix where to put the cursor.
+   
+   "required_size": (-> state? (pair? int?)) -> (pair? int?)
+
+       Seldom used: TODO
+   
+### **position**
+
+Construct a new `Position`.
+
+```scheme
+(position row col) -> Position?
+```
+
+row : int?
+col : int?
+       
+### **position-row**
+
+Get the row associated with the given `Position`.
+
+```scheme
+(position-row pos) -> int?
+```
+
+pos : `Position?`
+       
+### **position-col**
+
+Get the col associated with the given `Position`.
+
+```scheme
+(position-col pos) -> int?
+```
+
+pos : `Position?`
+### **set-position-row!**
+Set the row for the given `Position`
+
+```scheme
+(set-position-row! pos row)
+```
+
+pos : Position?
+row : int?
+       
+### **set-position-col!**
+Set the col for the given `Position`
+
+```scheme
+(set-position-col! pos col)
+```
+
+pos : Position?
+col : int?
+       
+### **Rect?**
+Check if the given value is a `Rect`
+
+```scheme
+(Rect? value) -> bool?
+```
+
+value : any?
+
+       
+### **area**
+
+Constructs a new `Rect`.
+
+(area x y width height)
+
+* x : int?
+* y : int?
+* width: int?
+* height: int?
+
+# Examples
+
+```scheme
+(area 0 0 100 200)
+```
+### **area-x**
+Get the `x` value of the given `Rect`
+
+```scheme
+(area-x area) -> int?
+```
+
+area : Rect?
+       
+### **area-y**
+Get the `y` value of the given `Rect`
+
+```scheme
+(area-y area) -> int?
+```
+
+area : Rect?
+       
+### **area-width**
+Get the `width` value of the given `Rect`
+
+```scheme
+(area-width area) -> int?
+```
+
+area : Rect?
+       
+### **area-height**
+Get the `height` value of the given `Rect`
+
+```scheme
+(area-height area) -> int?
+```
+
+area : Rect?
+       
+### **Widget/list?**
+Check whether the given value is a list widget.
+
+```scheme
+(Widget/list? value) -> bool?
+```
+
+value : any?
+       
+### **widget/list**
+Creates a new `List` widget with the given items.
+
+```scheme
+(widget/list lst) -> Widget?
+```
+
+* lst : (listof string?)
+       
+### **widget/list/render**
+
+
+Render the given `Widget/list` onto the provided `Rect` within the given `Buffer`.
+
+```scheme
+(widget/list/render buf area lst)
+```
+
+* buf : `Buffer?`
+* area : `Rect?`
+* lst : `Widget/list?`
+       
+### **block**
+Creates a block with the following styling:
+
+```scheme
+(block)
+```
+
+* borders - all
+* border-style - default style + white fg
+* border-type - rounded
+* style - default + black bg
+       
+### **make-block**
+
+Create a `Block` with the provided styling, borders, and border type.
+
+
+```scheme
+(make-block style border-style borders border_type)
+```
+
+* style : Style?
+* border-style : Style?
+* borders : string?
+* border-type: String?
+
+Valid border-types include:
+* "plain"
+* "rounded"
+* "double"
+* "thick"
+
+Valid borders include:
+* "top"
+* "left"
+* "right"
+* "bottom"
+* "all"
+       
+### **block/render**
+
+Render the given `Block` over the given `Rect` onto the provided `Buffer`.
+
+```scheme
+(block/render buf area block)
+```
+
+buf : Buffer?
+area: Rect?
+block: Block?
+           
+       
+### **buffer/clear**
+Clear a `Rect` in the `Buffer`
+
+```scheme
+(buffer/clear area)
+```
+
+area : Rect?
+       
+### **buffer/clear-with**
+Clear a `Rect` in the `Buffer` with a default `Style`
+
+```scheme
+(buffer/clear-with area style)
+```
+
+area : Rect?
+style : Style?
+       
+### **set-color-rgb!**
+
+Mutate the r/g/b of a color in place, to avoid allocation.
+
+```scheme
+(set-color-rgb! color r g b)
+```
+
+color : Color?
+r : int?
+g : int?
+b : int?
+### **set-color-indexed!**
+
+Mutate this color to be an indexed color.
+
+```scheme
+(set-color-indexed! color index)
+```
+
+color : Color?
+index: int?
+   
+### **Color?**
+Check if the given value is a `Color`.
+
+```scheme
+(Color? value) -> bool?
+```
+
+value : any?
+
+       
+### **Color/Reset**
+
+Singleton for the reset color.
+       
+### **Color/Black**
+
+Singleton for the color black.
+       
+### **Color/Red**
+
+Singleton for the color red.
+       
+### **Color/White**
+
+Singleton for the color white.
+       
+### **Color/Green**
+
+Singleton for the color green.
+       
+### **Color/Yellow**
+
+Singleton for the color yellow.
+       
+### **Color/Blue**
+
+Singleton for the color blue.
+       
+### **Color/Magenta**
+
+Singleton for the color magenta.
+       
+### **Color/Cyan**
+
+Singleton for the color cyan.
+       
+### **Color/Gray**
+
+Singleton for the color gray.
+       
+### **Color/LightRed**
+
+Singleton for the color light read.
+       
+### **Color/LightGreen**
+
+Singleton for the color light green.
+       
+### **Color/LightYellow**
+
+Singleton for the color light yellow.
+       
+### **Color/LightBlue**
+
+Singleton for the color light blue.
+       
+### **Color/LightMagenta**
+
+Singleton for the color light magenta.
+       
+### **Color/LightCyan**
+
+Singleton for the color light cyan.
+       
+### **Color/LightGray**
+
+Singleton for the color light gray.
+       
+### **Color/rgb**
+
+Construct a new color via rgb.
+
+```scheme
+(Color/rgb r g b) -> Color?
+```
+
+r : int?
+g : int?
+b : int?
+       
+### **Color-red**
+
+Get the red component of the `Color?`.
+
+```scheme
+(Color-red color) -> int?
+```
+
+color * Color?
+       
+### **Color-green**
+
+Get the green component of the `Color?`.
+
+```scheme
+(Color-green color) -> int?
+```
+
+color * Color?
+### **Color-blue**
+
+Get the blue component of the `Color?`.
+
+```scheme
+(Color-blue color) -> int?
+```
+
+color * Color?
+### **Color/Indexed**
+
+
+Construct a new indexed color.
+
+```scheme
+(Color/Indexed index) -> Color?
+```
+
+* index : int?
+       
+### **set-style-fg!**
+
+
+Mutates the given `Style` to have the fg with the provided color.
+
+```scheme
+(set-style-fg! style color)
+```
+
+style : `Style?`
+color : `Color?`
+       
+### **style-fg**
+
+
+Constructs a new `Style` with the provided `Color` for the fg.
+
+```scheme
+(style-fg style color) -> Style
+```
+
+style : Style?
+color: Color?
+       
+### **style-bg**
+
+
+Constructs a new `Style` with the provided `Color` for the bg.
+
+```scheme
+(style-bg style color) -> Style
+```
+
+style : Style?
+color: Color?
+       
+### **style-with-italics**
+
+
+Constructs a new `Style` with italcs.
+
+```scheme
+(style-with-italics style) -> Style
+```
+
+style : Style?
+       
+### **style-with-bold**
+
+
+Constructs a new `Style` with bold styling.
+
+```scheme
+(style-with-bold style) -> Style
+```
+
+style : Style?
+       
+### **style-with-dim**
+
+
+Constructs a new `Style` with dim styling.
+
+```scheme
+(style-with-dim style) -> Style
+```
+
+style : Style?
+       
+### **style-with-slow-blink**
+
+
+Constructs a new `Style` with slow blink.
+
+```scheme
+(style-with-slow-blink style) -> Style
+```
+
+style : Style?
+       
+### **style-with-rapid-blink**
+
+
+Constructs a new `Style` with rapid blink.
+
+```scheme
+(style-with-rapid-blink style) -> Style
+```
+
+style : Style?
+       
+### **style-with-reversed**
+
+
+Constructs a new `Style` with revered styling.
+
+```scheme
+(style-with-reversed style) -> Style
+```
+
+style : Style?
+       
+### **style-with-hidden**
+
+Constructs a new `Style` with hidden styling.
+
+```scheme
+(style-with-hidden style) -> Style
+```
+
+style : Style?
+       
+### **style-with-crossed-out**
+
+
+Constructs a new `Style` with crossed out styling.
+
+```scheme
+(style-with-crossed-out style) -> Style
+```
+
+style : Style?
+       
+### **style->fg**
+
+
+Return the color on the style, or #false if not present.
+
+```scheme
+(style->fg style) -> (or Color? #false)
+```
+
+style : Style?
+           
+       
+### **style->bg**
+
+
+Return the color on the style, or #false if not present.
+
+```scheme
+(style->bg style) -> (or Color? #false)
+```
+
+style : Style?
+           
+       
+### **set-style-bg!**
+
+
+Mutate the background style on the given style to a given color.
+
+```scheme
+(set-style-bg! style color)
+```
+
+style : Style?
+color : Color?
+           
+       
+### **style-underline-color**
+
+
+Return a new style with the provided underline color.
+
+```scheme
+(style-underline-color style color) -> Style?
+
+```
+style : Style?
+color : Color?
+           
+       
+### **style-underline-style**
+
+Return a new style with the provided underline style.
+
+```scheme
+(style-underline-style style underline-style) -> Style?
+
+```
+
+style : Style?
+underline-style : UnderlineStyle?
+
+### **UnderlineStyle?**
+
+Check if the provided value is an `UnderlineStyle`.
+
+```scheme
+(UnderlineStyle? value) -> bool?
+
+```
+value : any?
+### **Underline/Reset**
+
+Singleton for resetting the underling style.
+       
+### **Underline/Line**
+
+Singleton for the line underline style.
+       
+### **Underline/Curl**
+
+Singleton for the curl underline style.
+       
+### **Underline/Dotted**
+
+Singleton for the dotted underline style.
+       
+### **Underline/Dashed**
+
+Singleton for the dashed underline style.
+       
+### **Underline/DoubleLine**
+
+Singleton for the double line underline style.
+       
+### **event-result/consume**
+
+Singleton for consuming an event. If this is returned from an event handler, the event
+will not continue to be propagated down the component stack. This also will trigger a
+re-render.
+       
+### **event-result/consume-without-rerender**
+
+Singleton for consuming an event. If this is returned from an event handler, the event
+will not continue to be propagated down the component stack. This will _not_ trigger
+a re-render.
+       
+### **event-result/ignore**
+
+Singleton for ignoring an event. If this is returned from an event handler, the event
+will not continue to be propagated down the component stack. This will _not_ trigger
+a re-render.
+       
+### **event-result/ignore-and-close**
+
+Singleton for ignoring an event. If this is returned from an event handler, the event
+will continue to be propagated down the component stack, and the component will be
+popped off of the stack and removed.
+       
+### **event-result/close**
+
+Singleton for consuming an event. If this is returned from an event handler, the event
+will not continue to be propagated down the component stack, and the component will
+be popped off of the stack and removed.
+       
+### **style**
+
+Constructs a new default style.
+
+```scheme
+(style) -> Style?
+```
+       
+### **Event?**
+Check if this value is an `Event`
+
+```scheme
+(Event? value) -> bool?
+```
+value : any?
+       
+### **key-event?**
+Checks if the given event is a key event.
+
+```scheme
+(key-event? event) -> bool?
+```
+
+* event : Event?
+       
+### **key-event-char**
+Get the character off of the event, if there is one.
+
+```scheme
+(key-event-char event) -> (or char? #false)
+```
+event : Event?
+       
+### **key-event-modifier**
+
+Get the key event modifier off of the event, if there is one.
+
+```scheme
+(key-event-modifier event) -> (or int? #false)
+```
+event : Event?
+       
+### **key-modifier-ctrl**
+
+The key modifier bits associated with the ctrl key modifier.
+       
+### **key-modifier-shift**
+
+The key modifier bits associated with the shift key modifier.
+       
+### **key-modifier-alt**
+
+The key modifier bits associated with the alt key modifier.
+       
+### **key-event-F?**
+Check if this key event is associated with an `F<x>` key, e.g. F1, F2, etc.
+
+```scheme
+(key-event-F? event number) -> bool?
+```
+event : Event?
+number : int?
+       
+### **mouse-event?**
+
+Check if this event is a mouse event.
+
+```scheme
+(mouse-event event) -> bool?
+```
+event : Event?
+### **event-mouse-kind**
+Convert the mouse event kind into an integer representing the state.
+
+```scheme
+(event-mouse-kind event) -> (or int? #false)
+```
+
+event : Event?
+
+This is the current mapping today:
+
+```rust
+match kind {
+   helix_view::input::MouseEventKind::Down(MouseButton::Left) => 0,
+   helix_view::input::MouseEventKind::Down(MouseButton::Right) => 1,
+   helix_view::input::MouseEventKind::Down(MouseButton::Middle) => 2,
+   helix_view::input::MouseEventKind::Up(MouseButton::Left) => 3,
+   helix_view::input::MouseEventKind::Up(MouseButton::Right) => 4,
+   helix_view::input::MouseEventKind::Up(MouseButton::Middle) => 5,
+   helix_view::input::MouseEventKind::Drag(MouseButton::Left) => 6,
+   helix_view::input::MouseEventKind::Drag(MouseButton::Right) => 7,
+   helix_view::input::MouseEventKind::Drag(MouseButton::Middle) => 8,
+   helix_view::input::MouseEventKind::Moved => 9,
+   helix_view::input::MouseEventKind::ScrollDown => 10,
+   helix_view::input::MouseEventKind::ScrollUp => 11,
+   helix_view::input::MouseEventKind::ScrollLeft => 12,
+   helix_view::input::MouseEventKind::ScrollRight => 13,
+}
+```
+
+Any unhandled event that does not match this will return `#false`.
+### **event-mouse-row**
+
+
+Get the row from the mouse event, of #false if it isn't a mouse event.
+
+```scheme
+(event-mouse-row event) -> (or int? #false)
+```
+
+event : Event?
+           
+       
+### **event-mouse-col**
+
+
+Get the col from the mouse event, of #false if it isn't a mouse event.
+
+```scheme
+(event-mouse-row event) -> (or int? #false)
+```
+
+event : Event?
+       
+### **mouse-event-within-area?**
+Check whether the given mouse event occurred within a given `Rect`.
+
+```scheme
+(mouse-event-within-area? event area) -> bool?
+```
+
+event : Event?
+area : Rect?
+       
+### **key-event-escape?**
+
+Check whether the given event is the key: escape
+
+```scheme
+(key-event-escape? event)
+```
+event: Event?
+### **key-event-backspace?**
+
+Check whether the given event is the key: backspace
+
+```scheme
+(key-event-backspace? event)
+```
+event: Event?
+### **key-event-enter?**
+
+Check whether the given event is the key: enter
+
+```scheme
+(key-event-enter? event)
+```
+event: Event?
+### **key-event-left?**
+
+Check whether the given event is the key: left
+
+```scheme
+(key-event-left? event)
+```
+event: Event?
+### **key-event-right?**
+
+Check whether the given event is the key: right
+
+```scheme
+(key-event-right? event)
+```
+event: Event?
+### **key-event-up?**
+
+Check whether the given event is the key: up
+
+```scheme
+(key-event-up? event)
+```
+event: Event?
+### **key-event-down?**
+
+Check whether the given event is the key: down
+
+```scheme
+(key-event-down? event)
+```
+event: Event?
+### **key-event-home?**
+
+Check whether the given event is the key: home
+
+```scheme
+(key-event-home? event)
+```
+event: Event?
+### **key-event-page-up?**
+
+Check whether the given event is the key: page-up
+
+```scheme
+(key-event-page-up? event)
+```
+event: Event?
+### **key-event-page-down?**
+
+Check whether the given event is the key: page-down
+
+```scheme
+(key-event-page-down? event)
+```
+event: Event?
+### **key-event-tab?**
+
+Check whether the given event is the key: tab
+
+```scheme
+(key-event-tab? event)
+```
+event: Event?
+### **key-event-delete?**
+
+Check whether the given event is the key: delete
+
+```scheme
+(key-event-delete? event)
+```
+event: Event?
+### **key-event-insert?**
+
+Check whether the given event is the key: insert
+
+```scheme
+(key-event-insert? event)
+```
+event: Event?
+### **key-event-null?**
+
+Check whether the given event is the key: null
+
+```scheme
+(key-event-null? event)
+```
+event: Event?
+### **key-event-caps-lock?**
+
+Check whether the given event is the key: caps-lock
+
+```scheme
+(key-event-caps-lock? event)
+```
+event: Event?
+### **key-event-scroll-lock?**
+
+Check whether the given event is the key: scroll-lock
+
+```scheme
+(key-event-scroll-lock? event)
+```
+event: Event?
+### **key-event-num-lock?**
+
+Check whether the given event is the key: num-lock
+
+```scheme
+(key-event-num-lock? event)
+```
+event: Event?
+### **key-event-print-screen?**
+
+Check whether the given event is the key: print-screen
+
+```scheme
+(key-event-print-screen? event)
+```
+event: Event?
+### **key-event-pause?**
+
+Check whether the given event is the key: pause
+
+```scheme
+(key-event-pause? event)
+```
+event: Event?
+### **key-event-menu?**
+
+Check whether the given event is the key: menu
+
+```scheme
+(key-event-menu? event)
+```
+event: Event?
+### **key-event-keypad-begin?**
+
+Check whether the given event is the key: keypad-begin
+
+```scheme
+(key-event-keypad-begin? event)
+```
+event: Event?
+# helix/core/text
+### **Rope?**
+Check if the given value is a rope
+### **rope->byte-slice**
+Take a slice of this rope using byte offsets
+
+```scheme
+(rope->byte-slice rope start end) -> Rope?
+```
+
+* rope: Rope?
+* start: (and positive? int?)
+* end: (and positive? int?)
+### **rope->line**
+Get the line at the given line index. Returns a rope.
+
+```scheme
+(rope->line rope index) -> Rope?
+
+```
+
+* rope : Rope?
+* index : (and positive? int?)
+### **rope->slice**
+Take a slice from using character indices from the rope.
+Returns a new rope value.
+
+```scheme
+(rope->slice rope start end) -> Rope?
+```
+
+* rope : Rope?
+* start: (and positive? int?)
+* end: (and positive? int?)
+### **rope->string**
+Convert the given rope to a string
+### **rope-byte->line**
+Convert the given byte offset to a line offset for a given rope
+
+```scheme
+(rope-byte->line rope byte-index) -> int?
+```
+
+* rope : Rope?
+* byte-index : int?
+
+            
+### **rope-char->byte**
+Convert the byte offset into a character offset for a given rope
+### **rope-char->line**
+Convert the given character offset to a line offset for a given rope
+
+```scheme
+(rope-char->line rope char-index) -> int?
+```
+
+* rope : Rope?
+* char-index : int?
+
+            
+### **rope-char-ref**
+Get the character at the given index
+### **rope-ends-with?**
+Check if the rope ends with a given pattern
+### **rope-insert-char**
+Insert a character at the given index
+### **rope-insert-string**
+Insert a string at the given index into the rope
+### **rope-len-bytes**
+Get the length of the rope in bytes
+### **rope-len-chars**
+Get the length of the rope in characters
+### **rope-len-lines**
+Get the number of lines in the rope
+### **rope-line->byte**
+Convert the given line index to a byte offset for a given rope
+
+```scheme
+(rope-line->byte rope line-offset) -> int?
+```
+
+* rope : Rope?
+* line-offset: int?
+            
+### **rope-line->char**
+Convert the given line index to a character offset for a given rope
+
+```scheme
+(rope-line->char rope line-offset) -> int?
+```
+
+* rope : Rope?
+* line-offset: int?
+            
+### **rope-starts-with?**
+Check if the rope starts with a given pattern
+### **rope-trim-start**
+Remove the leading whitespace from the given rope
+### **string->rope**
+Converts a string into a rope.
+
+```scheme
+(string->rope value) -> Rope?
+```
+
+* value : string?
+            
diff --git a/xtask/src/codegen.rs b/xtask/src/codegen.rs
new file mode 100644
index 000000000..470cbf8f1
--- /dev/null
+++ b/xtask/src/codegen.rs
@@ -0,0 +1,5 @@
+use helix_term::commands::ScriptingEngine;
+
+pub fn code_gen() {
+    ScriptingEngine::generate_sources()
+}
diff --git a/xtask/src/main.rs b/xtask/src/main.rs
index d4995ce35..5895e00d2 100644
--- a/xtask/src/main.rs
+++ b/xtask/src/main.rs
@@ -1,3 +1,4 @@
+mod codegen;
 mod docgen;
 mod helpers;
 mod path;
@@ -7,6 +8,7 @@
 type DynError = Box<dyn Error>;
 
 pub mod tasks {
+    use crate::codegen::code_gen;
     use crate::DynError;
     use std::collections::HashSet;
 
@@ -43,6 +45,62 @@ pub fn querycheck(languages: impl Iterator<Item = String>) -> Result<(), DynErro
         Ok(())
     }
 
+    pub fn codegen() {
+        code_gen()
+    }
+
+    pub fn install_steel() {
+        std::process::Command::new("cargo")
+            .args([
+                "install",
+                "--git",
+                "https://github.com/mattwparas/steel.git",
+                "steel-interpreter",
+                "steel-language-server",
+                "cargo-steel-lib",
+            ])
+            .spawn()
+            .unwrap()
+            .wait()
+            .unwrap();
+
+        std::process::Command::new("cargo")
+            .args([
+                "install",
+                "--git",
+                "https://github.com/mattwparas/steel.git",
+                "steel-forge",
+            ])
+            .spawn()
+            .unwrap()
+            .wait()
+            .unwrap();
+
+        println!("----------------------------");
+        println!("=> Finished installing steel");
+        println!("----------------------------");
+        println!("Warming up `forge`...");
+
+        std::process::Command::new("forge")
+            .args(["pkg", "refresh"])
+            .spawn()
+            .unwrap()
+            .wait()
+            .unwrap();
+
+        println!("Done.");
+        println!("----------------------------");
+
+        code_gen();
+
+        std::process::Command::new("cargo")
+            .args(["install", "--path", "helix-term", "--locked", "--force"])
+            .spawn()
+            .unwrap()
+            .wait()
+            .unwrap();
+    }
+
     pub fn themecheck(themes: impl Iterator<Item = String>) -> Result<(), DynError> {
         use helix_view::theme::Loader;
 
@@ -87,6 +145,7 @@ pub fn print_help() {
 Usage: Run with `cargo xtask <task>`, eg. `cargo xtask docgen`.
 
     Tasks:
+        steel:                     Install steel
         docgen                     Generate files to be included in the mdbook output.
         query-check [languages]    Check that tree-sitter queries are valid for the given
                                    languages, or all languages if none are specified.
@@ -104,6 +163,8 @@ fn main() -> Result<(), DynError> {
         None => tasks::print_help(),
         Some(t) => match t.as_str() {
             "docgen" => tasks::docgen()?,
+            "code-gen" => tasks::codegen(),
+            "steel" => tasks::install_steel(),
             "query-check" => tasks::querycheck(args)?,
             "theme-check" => tasks::themecheck(args)?,
             invalid => return Err(format!("Invalid task name: {}", invalid).into()),
-- 
2.50.0.windows.1

